<!DOCTYPE html>
<html style="display: none;" lang="zh">
    <head>
    <meta charset="utf-8">
    <!--
        © Material Theme
        https://github.com/viosey/hexo-theme-material
        Version: 1.5.0 -->
    <script>
        window.materialVersion = "1.5.0"
        // Delete localstorage with these tags
        window.oldVersion = [
            'codestartv1',
            '1.3.4',
            '1.4.0',
            '1.4.0b1'
        ]
    </script>

    <!-- dns prefetch -->
    <meta http-equiv="x-dns-prefetch-control" content="on">














    <!-- Title -->
    
    <title>
        
            C++点点滴滴（中） | 
        
        Azurery
    </title>

    <!-- Meta & Info -->
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="format-detection" content="telephone=no"/>
    <meta name="theme-color" content="#0097A7">
    <meta name="author" content="Magicmanoooo">
    <meta name="description" itemprop="description" content="蒟蒻一枚">
    <meta name="keywords" content=",C++">

    <!-- Import lsloader -->
    <script>(function(){window.lsloader={jsRunSequence:[],jsnamemap:{},cssnamemap:{}};lsloader.removeLS=function(key){try{localStorage.removeItem(key)}catch(e){}};lsloader.setLS=function(key,val){try{localStorage.setItem(key,val)}catch(e){}};lsloader.getLS=function(key){var val="";try{val=localStorage.getItem(key)}catch(e){val=""}return val};versionString="/*"+(window.materialVersion||"unknownVersion")+"*/";lsloader.clean=function(){try{var keys=[];for(var i=0;i<localStorage.length;i++){keys.push(localStorage.key(i))}keys.forEach(function(key){var data=lsloader.getLS(key);if(window.oldVersion){var remove=window.oldVersion.reduce(function(p,c){return p||data.indexOf("/*"+c+"*/")!==-1},false);if(remove){lsloader.removeLS(key)}}})}catch(e){}};lsloader.clean();lsloader.load=function(jsname,jspath,cssonload,isJs){if(typeof cssonload==="boolean"){isJs=cssonload;cssonload=undefined}isJs=isJs||false;cssonload=cssonload||function(){};var code;code=this.getLS(jsname);if(code&&code.indexOf(versionString)===-1){this.removeLS(jsname);this.requestResource(jsname,jspath,cssonload,isJs);return}if(code){var versionNumber=code.split(versionString)[0];if(versionNumber!=jspath){console.log("reload:"+jspath);this.removeLS(jsname);this.requestResource(jsname,jspath,cssonload,isJs);return}code=code.split(versionString)[1];if(isJs){this.jsRunSequence.push({name:jsname,code:code});this.runjs(jspath,jsname,code)}else{document.getElementById(jsname).appendChild(document.createTextNode(code));cssonload()}}else{this.requestResource(jsname,jspath,cssonload,isJs)}};lsloader.requestResource=function(name,path,cssonload,isJs){var that=this;if(isJs){this.iojs(path,name,function(path,name,code){that.setLS(name,path+versionString+code);that.runjs(path,name,code)})}else{this.iocss(path,name,function(code){document.getElementById(name).appendChild(document.createTextNode(code));that.setLS(name,path+versionString+code)},cssonload)}};lsloader.iojs=function(path,jsname,callback){var that=this;that.jsRunSequence.push({name:jsname,code:""});try{var xhr=new XMLHttpRequest;xhr.open("get",path,true);xhr.onreadystatechange=function(){if(xhr.readyState==4){if(xhr.status>=200&&xhr.status<300||xhr.status==304){if(xhr.response!=""){callback(path,jsname,xhr.response);return}}that.jsfallback(path,jsname)}};xhr.send(null)}catch(e){that.jsfallback(path,jsname)}};lsloader.iocss=function(path,jsname,callback,cssonload){var that=this;try{var xhr=new XMLHttpRequest;xhr.open("get",path,true);xhr.onreadystatechange=function(){if(xhr.readyState==4){if(xhr.status>=200&&xhr.status<300||xhr.status==304){if(xhr.response!=""){callback(xhr.response);cssonload();return}}that.cssfallback(path,jsname,cssonload)}};xhr.send(null)}catch(e){that.cssfallback(path,jsname,cssonload)}};lsloader.iofonts=function(path,jsname,callback,cssonload){var that=this;try{var xhr=new XMLHttpRequest;xhr.open("get",path,true);xhr.onreadystatechange=function(){if(xhr.readyState==4){if(xhr.status>=200&&xhr.status<300||xhr.status==304){if(xhr.response!=""){callback(xhr.response);cssonload();return}}that.cssfallback(path,jsname,cssonload)}};xhr.send(null)}catch(e){that.cssfallback(path,jsname,cssonload)}};lsloader.runjs=function(path,name,code){if(!!name&&!!code){for(var k in this.jsRunSequence){if(this.jsRunSequence[k].name==name){this.jsRunSequence[k].code=code}}}if(!!this.jsRunSequence[0]&&!!this.jsRunSequence[0].code&&this.jsRunSequence[0].status!="failed"){var script=document.createElement("script");script.appendChild(document.createTextNode(this.jsRunSequence[0].code));script.type="text/javascript";document.getElementsByTagName("head")[0].appendChild(script);this.jsRunSequence.shift();if(this.jsRunSequence.length>0){this.runjs()}}else if(!!this.jsRunSequence[0]&&this.jsRunSequence[0].status=="failed"){var that=this;var script=document.createElement("script");script.src=this.jsRunSequence[0].path;script.type="text/javascript";this.jsRunSequence[0].status="loading";script.onload=function(){that.jsRunSequence.shift();if(that.jsRunSequence.length>0){that.runjs()}};document.body.appendChild(script)}};lsloader.tagLoad=function(path,name){this.jsRunSequence.push({name:name,code:"",path:path,status:"failed"});this.runjs()};lsloader.jsfallback=function(path,name){if(!!this.jsnamemap[name]){return}else{this.jsnamemap[name]=name}for(var k in this.jsRunSequence){if(this.jsRunSequence[k].name==name){this.jsRunSequence[k].code="";this.jsRunSequence[k].status="failed";this.jsRunSequence[k].path=path}}this.runjs()};lsloader.cssfallback=function(path,name,cssonload){if(!!this.cssnamemap[name]){return}else{this.cssnamemap[name]=1}var link=document.createElement("link");link.type="text/css";link.href=path;link.rel="stylesheet";link.onload=link.onerror=cssonload;var root=document.getElementsByTagName("script")[0];root.parentNode.insertBefore(link,root)};lsloader.runInlineScript=function(scriptId,codeId){var code=document.getElementById(codeId).innerText;this.jsRunSequence.push({name:scriptId,code:code});this.runjs()};lsloader.loadCombo=function(jslist){var updateList="";var requestingModules={};for(var k in jslist){var LS=this.getLS(jslist[k].name);if(!!LS){var version=LS.split(versionString)[0];var code=LS.split(versionString)[1]}else{var version=""}if(version==jslist[k].path){this.jsRunSequence.push({name:jslist[k].name,code:code,path:jslist[k].path})}else{this.jsRunSequence.push({name:jslist[k].name,code:null,path:jslist[k].path,status:"comboloading"});requestingModules[jslist[k].name]=true;updateList+=(updateList==""?"":";")+jslist[k].path}}var that=this;if(!!updateList){var xhr=new XMLHttpRequest;xhr.open("get",combo+updateList,true);xhr.onreadystatechange=function(){if(xhr.readyState==4){if(xhr.status>=200&&xhr.status<300||xhr.status==304){if(xhr.response!=""){that.runCombo(xhr.response,requestingModules);return}}else{for(var i in that.jsRunSequence){if(requestingModules[that.jsRunSequence[i].name]){that.jsRunSequence[i].status="failed"}}that.runjs()}}};xhr.send(null)}this.runjs()};lsloader.runCombo=function(comboCode,requestingModules){comboCode=comboCode.split("/*combojs*/");comboCode.shift();for(var k in this.jsRunSequence){if(!!requestingModules[this.jsRunSequence[k].name]&&!!comboCode[0]){this.jsRunSequence[k].status="comboJS";this.jsRunSequence[k].code=comboCode[0];this.setLS(this.jsRunSequence[k].name,this.jsRunSequence[k].path+versionString+comboCode[0]);comboCode.shift()}}this.runjs()}})();</script>

    <!-- Import queue -->
    <script>function Queue(){this.dataStore=[];this.offer=b;this.poll=d;this.execNext=a;this.debug=false;this.startDebug=c;function b(e){if(this.debug){console.log("Offered a Queued Function.")}if(typeof e==="function"){this.dataStore.push(e)}else{console.log("You must offer a function.")}}function d(){if(this.debug){console.log("Polled a Queued Function.")}return this.dataStore.shift()}function a(){var e=this.poll();if(e!==undefined){if(this.debug){console.log("Run a Queued Function.")}e()}}function c(){this.debug=true}}var queue=new Queue();</script>

    <!-- Favicons -->
    <link rel="icon shortcut" type="image/ico" href="/img/favicon.png">
    <link rel="icon" sizes="192x192" href="/img/favicon.png">
    <link rel="apple-touch-icon" href="/img/favicon.png">

    <!--iOS -->
    <meta name="apple-mobile-web-app-title" content="Title">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="480">

    <!-- Add to homescreen for Chrome on Android -->
    <meta name="mobile-web-app-capable" content="yes">

    <!-- Add to homescreen for Safari on iOS -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="Azurery">

    <!-- Site Verification -->
    
    

    <!-- RSS -->
    

    <!--[if lte IE 9]>
        <link rel="stylesheet" href="/css/ie-blocker.css">

        
            <script src="/js/ie-blocker.zhCN.js"></script>
        
    <![endif]-->

    <!-- Import CSS -->
    
        <style id="material_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("material_css","/css/material.min.css?Z7a72R1E4SxzBKR/WGctOA==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
        <style id="style_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("style_css","/css/style.min.css?MKetZV3cUTfDxvMffaOezg==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>

        
            
                <style id="prettify_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("prettify_css","/css/prettify.min.css?zp8STOU9v89XWFEnN+6YmQ==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
                <style id="prettify_theme"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("prettify_theme","/css/prettify/vibrant-ink.min.css?e5E/qqGcGveS7VTH4M896w==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
            
        

    

    

    <!-- Config CSS -->

<!-- Other Styles -->
<style>
  body, html {
    font-family: Roboto, "Helvetica Neue", Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "微软雅黑", Arial, sans-serif;
    overflow-x: hidden !important;
  }
  
  code {
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
  }

  a {
    color: #00838F;
  }

  .mdl-card__media,
  #search-label,
  #search-form-label:after,
  #scheme-Paradox .hot_tags-count,
  #scheme-Paradox .sidebar_archives-count,
  #scheme-Paradox .sidebar-colored .sidebar-header,
  #scheme-Paradox .sidebar-colored .sidebar-badge{
    background-color: #0097A7 !important;
  }

  /* Sidebar User Drop Down Menu Text Color */
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:hover,
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:focus {
    color: #0097A7 !important;
  }

  #post_entry-right-info,
  .sidebar-colored .sidebar-nav li:hover > a,
  .sidebar-colored .sidebar-nav li:hover > a i,
  .sidebar-colored .sidebar-nav li > a:hover,
  .sidebar-colored .sidebar-nav li > a:hover i,
  .sidebar-colored .sidebar-nav li > a:focus i,
  .sidebar-colored .sidebar-nav > .open > a,
  .sidebar-colored .sidebar-nav > .open > a:hover,
  .sidebar-colored .sidebar-nav > .open > a:focus,
  #ds-reset #ds-ctx .ds-ctx-entry .ds-ctx-head a {
    color: #0097A7 !important;
  }

  .toTop {
    background: #757575 !important;
  }

  .material-layout .material-post>.material-nav,
  .material-layout .material-index>.material-nav,
  .material-nav a {
    color: #757575;
  }

  #scheme-Paradox .MD-burger-layer {
    background-color: #757575;
  }

  #scheme-Paradox #post-toc-trigger-btn {
    color: #757575;
  }

  .post-toc a:hover {
    color: #00838F;
    text-decoration: underline;
  }

</style>


<!-- Theme Background Related-->

    <style>
      body{
        background-image: url(/img/bg.png);
      }
    </style>




<!-- Fade Effect -->

    <style>
      .fade {
        transition: all 800ms linear;
        -webkit-transform: translate3d(0,0,0);
        -moz-transform: translate3d(0,0,0);
        -ms-transform: translate3d(0,0,0);
        -o-transform: translate3d(0,0,0);
        transform: translate3d(0,0,0);
        opacity: 1;
      }

      .fade.out{
        opacity: 0;
      }
    </style>


<!-- Import Font -->
<!-- Import Roboto -->

    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500" rel="stylesheet">


<!-- Import Material Icon -->

    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">




    <!-- Import jQuery -->
    
        <script>lsloader.load("jq_js","/js/jquery.min.js?qcusAULNeBksqffqUM2+Ig==", true)</script>
    

    <!-- The Open Graph protocol -->
    <meta property="og:url" content="http://yoursite.com">
    <meta property="og:type" content="blog">
    <meta property="og:title" content="C++点点滴滴（中） | Azurery">
    <meta property="og:image" content="http://yoursite.com/img/favicon.png" />
    <meta property="og:description" content="蒟蒻一枚">
    <meta property="og:article:tag" content="C++"> 

    
        <meta property="article:published_time" content="Sat Jul 21 2018 17:20:01 GMT+0800" />
        <meta property="article:modified_time" content="Tue Aug 21 2018 11:43:05 GMT+0800" />
    

    <!-- The Twitter Card protocol -->
    <meta name="twitter:title" content="C++点点滴滴（中） | Azurery">
    <meta name="twitter:description" content="蒟蒻一枚">
    <meta name="twitter:image" content="http://yoursite.com/img/favicon.png">
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:url" content="http://yoursite.com" />

    <!-- Add canonical link for SEO -->
    
        <link rel="canonical" href="http://yoursite.com/2018/07/21/C++点点滴滴（中）/index.html" />
    

    <!-- Structured-data for SEO -->
    
        


<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "mainEntityOfPage": "http://yoursite.com/2018/07/21/C++点点滴滴（中）/index.html",
    "headline": "C++点点滴滴（中）",
    "datePublished": "Sat Jul 21 2018 17:20:01 GMT+0800",
    "dateModified": "Tue Aug 21 2018 11:43:05 GMT+0800",
    "author": {
        "@type": "Person",
        "name": "Magicmanoooo",
        "image": {
            "@type": "ImageObject",
            "url": "/img/avatar.png"
        },
        "description": "秘境，探寻你的足迹"
    },
    "publisher": {
        "@type": "Organization",
        "name": "Azurery",
        "logo": {
            "@type":"ImageObject",
            "url": "/img/favicon.png"
        }
    },
    "keywords": ",C++",
    "description": "蒟蒻一枚",
}
</script>


    

    <!-- Analytics -->
    
    
    

    <!-- Custom Head -->
    

</head>


    
        <body id="scheme-Paradox" class="lazy">
            <div class="material-layout  mdl-js-layout has-drawer is-upgraded">
                

                <!-- Main Container -->
                <main class="material-layout__content" id="main">

                    <!-- Top Anchor -->
                    <div id="top"></div>

                    
                        <!-- Hamburger Button -->
                        <button class="MD-burger-icon sidebar-toggle">
                            <span class="MD-burger-layer"></span>
                        </button>
                    

                    <!-- Post TOC -->

    
    <!-- Back Button -->
    <!--
    <div class="material-back" id="backhome-div" tabindex="0">
        <a class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon"
           href="#" onclick="window.history.back();return false;"
           target="_self"
           role="button"
           data-upgraded=",MaterialButton,MaterialRipple">
            <i class="material-icons" role="presentation">arrow_back</i>
            <span class="mdl-button__ripple-container">
                <span class="mdl-ripple"></span>
            </span>
        </a>
    </div>
    -->


    <!-- Left aligned menu below button -->
    
    
    <button id="post-toc-trigger-btn"
        class="mdl-button mdl-js-button mdl-button--icon">
        <i class="material-icons">format_list_numbered</i>
    </button>

    <ul class="post-toc-wrap mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect" for="post-toc-trigger-btn" style="max-height:80vh; overflow-y:scroll;">
        <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#std-bind"><span class="post-toc-number">1.</span> <span class="post-toc-text">std::bind</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#std-ref-or-std-cref"><span class="post-toc-number">1.0.1.</span> <span class="post-toc-text">std::ref or std::cref</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#bind的基本原理"><span class="post-toc-number">2.</span> <span class="post-toc-text">bind的基本原理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#保存可调用对象及其形参"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">保存可调用对象及其形参</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#实现调用"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">实现调用</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#bind实现的关键技术"><span class="post-toc-number">3.</span> <span class="post-toc-text">bind实现的关键技术</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#将tuple展开为变参"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">将tuple展开为变参</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#根据占位符来选择合适的实参"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">根据占位符来选择合适的实参</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#具体实现"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">具体实现</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#std-is-member-function-pointer"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">std::is_member_function_pointer</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#pointer-reference"><span class="post-toc-number">3.5.</span> <span class="post-toc-text">pointer reference</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#智能指针"><span class="post-toc-number">4.</span> <span class="post-toc-text">智能指针</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#C-17之前，shared-ptr不支持动态数组，而unique-ptr支持"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">C++17之前，shared_ptr不支持动态数组，而unique_ptr支持</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#C-17中，可以使用std-shared-ptr管理动态数组。"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">C++ 17中，可以使用std::shared_ptr管理动态数组。</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#shared-ptr和unique-ptr指定删除器方式不同"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">shared_ptr和unique_ptr指定删除器方式不同</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#std-default-delete"><span class="post-toc-number">4.4.</span> <span class="post-toc-text">std::default_delete</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#通过std-tuple来实现函数调用"><span class="post-toc-number">5.</span> <span class="post-toc-text">通过std::tuple来实现函数调用</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#类型擦除（type-erasure）"><span class="post-toc-number">6.</span> <span class="post-toc-text">类型擦除（type erasure）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-通过多态来擦除类型"><span class="post-toc-number">6.1.</span> <span class="post-toc-text">1. 通过多态来擦除类型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-通过模板来擦除类型"><span class="post-toc-number">6.2.</span> <span class="post-toc-text">2. 通过模板来擦除类型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-通过某种通用类型来擦除类型"><span class="post-toc-number">6.3.</span> <span class="post-toc-text">4. 通过某种通用类型来擦除类型</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#实现any"><span class="post-toc-number">7.</span> <span class="post-toc-text">实现any</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#strtod"><span class="post-toc-number">8.</span> <span class="post-toc-text">strtod</span></a></li></ol>
    </ul>
    




<!-- Layouts -->

    <!-- Post Module -->
    <div class="material-post_container">

        <div class="material-post mdl-grid">
            <div class="mdl-card mdl-shadow--4dp mdl-cell mdl-cell--12-col">

                <!-- Post Header(Thumbnail & Title) -->
                
    <!-- Paradox Post Header -->
    
        
            <!-- Random Thumbnail -->
            <div class="post_thumbnail-random mdl-card__media mdl-color-text--grey-50">
            <script type="text/ls-javascript" id="post-thumbnail-script">
    var randomNum = Math.floor(Math.random() * 19 + 1);

    $('.post_thumbnail-random').attr('data-original', '/img/random/material-' + randomNum + '.png');
    $('.post_thumbnail-random').addClass('lazy');
</script>

        
    
            <p class="article-headline-p">
                C++点点滴滴（中）
            </p>
        </div>





                
                    <!-- Paradox Post Info -->
                    <div class="mdl-color-text--grey-700 mdl-card__supporting-text meta">

    <!-- Author Avatar -->
    <div id="author-avatar">
        <img src="/img/avatar.png" width="44px" height="44px" alt="Author Avatar"/>
    </div>
    <!-- Author Name & Date -->
    <div>
        <strong>Magicmanoooo</strong>
        <span>7月 21, 2018</span>
    </div>

    <div class="section-spacer"></div>

    <!-- Favorite -->
    <!--
        <button id="article-functions-like-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon btn-like">
            <i class="material-icons" role="presentation">favorite</i>
            <span class="visuallyhidden">favorites</span>
        </button>
    -->

    <!-- Qrcode -->
    
        <button id="article-functions-qrcode-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
    <i class="material-icons" role="presentation">devices other</i>
    <span class="visuallyhidden">devices other</span>
</button>
<ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-functions-qrcode-button">
    <li class="mdl-menu__item">在其它设备中阅读本文章</li>
    
        <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPYAAAD2CAAAAADAeSUUAAACzklEQVR42u3aQVLkQAwEwPn/p9nrRsCaKsksE+30iTBG7uwDsqR+fTzyemFjY2NjY2NjY2O/JfsVX18E+uv+52euI9z722TN2NjY2Gezv/nXX7748zNJzCT+as3Y2NjYD2C3r7m+f80uSoh/bHq7ZmxsbGzsa14OaJ9PSiBsbGxs7DpEDEhi1u0hbGxsbOxFU+m6edQ27tsU9Wu9NGxsbOy3Z88W+rs//9f5NjY2NvYbszct+2QpSXKaDSHqNWNjY2Mfys5bNptFJC2qpEm0WQk2Njb22ew6xKgVlRQSyUBiGAEbGxv7UHY7as1T0fW2zgqV1XgYGxsb+2j2pgjJy4bZNs0KlaKXho2NjX0EOyHlRyGToUKbJmfHMbGxsbGfzE4+/TfJ7N4xc1QmYWNjYx/KztPDXUck8+24q4GFjY2N/QR2y8sHwEna25QfxX1sbGzsQ9mz1v/s0M9dbalh8wsbGxv7aPaPfPrHh2zyaLP3YmNjY5/NzkNsBq6bI5htewsbGxv7mezZ5/5+lLuJU28ZNjY29gPYLfjnGlL5YKBYDzY2NvbR7Dx5bO4nxcm+4VVXYNjY2NjHsffFyWxD24KnLlGwsbGxH8Bui5N20cVQtsRH24GNjY19KDsf927GsZthbZK66lIEGxsb+zh2Ulq0w9fNVraHgaII2NjY2Iey8+SxObKTlCj7wfA3d7CxsbEPZV83klpMPmbYb3H9dmxsbOxD2e0S82STDwDy0qjdIGxsbOwnsNurHQmvGvpxk2uYt7GxsbGPYM8+6zcHbpJmUJ4s8+3GxsbGPps9SzZtKTIbHs/iF1MRbGxs7IPYs8STt5/amPlgINogbGxsbOxFM2hTnGyKFmxsbGzs9rDOXceA7hoqYGNjYz+NvWnoXP/tbPCwp2JjY2M/h90WD/c2kuqiYnTEBxsbG/tU9nMubGxsbGxsbGxs7Le5/gC95di7yhNvXwAAAABJRU5ErkJggg==">
    
</ul>

    

    <!-- Tags (bookmark) -->
    
    <button id="article-functions-viewtags-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
        <i class="material-icons" role="presentation">bookmark</i>
        <span class="visuallyhidden">bookmark</span>
    </button>
    <ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-functions-viewtags-button">
        <li class="mdl-menu__item">
        <a class="post_tag-link" href="/tags/C/">C++</a>
    </ul>
    

    <!-- Share -->
    <button id="article-fuctions-share-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
    <i class="material-icons" role="presentation">share</i>
    <span class="visuallyhidden">share</span>
</button>
<ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-fuctions-share-button">
    

    

    <!-- Share Weibo -->
    
        <a class="post_share-link" href="http://service.weibo.com/share/share.php?appkey=&title=C++点点滴滴（中）&url=http://yoursite.com/2018/07/21/C++点点滴滴（中）/index.html&pic=http://yoursite.com/img/favicon.png&searchPic=false&style=simple" target="_blank">
            <li class="mdl-menu__item">
                分享到微博
            </li>
        </a>
    

    <!-- Share Twitter -->
    
        <a class="post_share-link" href="https://twitter.com/intent/tweet?text=C++点点滴滴（中）&url=http://yoursite.com/2018/07/21/C++点点滴滴（中）/index.html&via=Magicmanoooo" target="_blank">
            <li class="mdl-menu__item">
                分享到 Twitter
            </li>
        </a>
    

    <!-- Share Facebook -->
    
        <a class="post_share-link" href="https://www.facebook.com/sharer/sharer.php?u=http://yoursite.com/2018/07/21/C++点点滴滴（中）/index.html" target="_blank">
            <li class="mdl-menu__item">
                分享到 Facebook
            </li>
        </a>
    

    <!-- Share Google+ -->
    
        <a class="post_share-link" href="https://plus.google.com/share?url=http://yoursite.com/2018/07/21/C++点点滴滴（中）/index.html" target="_blank">
            <li class="mdl-menu__item">
                分享到 Google+
            </li>
        </a>
    

    <!-- Share LinkedIn -->
    

    <!-- Share QQ -->
    
        <a class="post_share-link" href="http://connect.qq.com/widget/shareqq/index.html?site=Azurery&title=C++点点滴滴（中）&summary=蒟蒻一枚&pics=http://yoursite.com/img/favicon.png&url=http://yoursite.com/2018/07/21/C++点点滴滴（中）/index.html" target="_blank">
            <li class="mdl-menu__item">
                分享到 QQ
            </li>
        </a>
    

    <!-- Share Telegram -->
    
</ul>

</div>

                

                <!-- Post Content -->
                <div id="post-content" class="mdl-color-text--grey-700 mdl-card__supporting-text fade out">
    
        <h2 id="std-bind"><a href="#std-bind" class="headerlink" title="std::bind"></a><code>std::bind</code></h2><p>定义在<code>&lt;functional&gt;</code>，其原型为：</p>
<pre><code class="cpp">template&lt; class F, class... Args &gt;
/*unspecified*/ bind( F&amp;&amp; f, Args&amp;&amp;... args );

template&lt; class R, class F, class... Args &gt;
/*unspecified*/ bind( F&amp;&amp; f, Args&amp;&amp;... args );
</code></pre>
<p>为<code>f</code>生成的forwarding call wrapper。调用这个wrapper就如同调用<code>f</code>，其中一些参数绑定到<code>args</code>上。</p>
<p>其中，<code>f</code>是callable object（function object, pointer to function, reference to function, pointer to member function, or pointer to data member），一些参数将会与之进行绑定。<code>args</code>则是需要进行绑定的参数列表。未进行绑定的参数则由占位符<code>_1, _2, _3...</code>代替。</p>
<p>例子：</p>
<pre><code class="cpp">void f(int n1, int n2, int n3, const int&amp; n4, int n5) {
    std::cout&lt;&lt; n1 &lt;&lt; &#39; &#39;&lt;&lt; n2 &lt;&lt; &#39; &#39; &lt;&lt; n3 &lt;&lt; &#39; &#39; &lt;&lt; n4 &lt;&lt; &#39; &#39; &lt;&lt; n5 &lt;&lt; std::endl;
}

int g(int n1) { return n1; }

struct Foo {
    void print_sum(int n1, int n2) {
        std::cout&lt;&lt; n1+n2 &lt;&lt;std::endl;
    }
    int data = 10;
};

int main() {
    int n = 7;
    auto f1 = std::bind(f, std::placeholders::_2, std::placeholders::_1, 42, std::cref(n), n);
    n = 10;
    f1(1, 2, 1001);
    /// 2 1 42 10 7

    // 相当于调用f(12, g(12), 12, 4, 5)
    auto f2 = std::bind(f, std::placeholders::_3, std::bind(g, std::placeholders::_3), 
                std::placeholders::_3, 4, 5);
    f2(10, 11, 12);
    /// 12 12 12 4 5

    // bind to a pointer to member function
    Foo foo;
    auto f3 = std::bind(&amp;Foo::print_sum, &amp;foo, 95, std::placeholders::_1);
    f3(5);
    /// 100

    // bind to a pointer to data member
    auto f4 = std::bind(&amp;Foo::data, std::placeholders::_1);
    std::cout &lt;&lt; f4(foo) &lt;&lt; std::endl;
    // 10

    // smart pointer可以用来调用members of the referenced objects
    std::cout &lt;&lt; f4(std::make_shared&lt;Foo&gt;(foo)) &lt;&lt;&#39;\n&#39;
                &lt;&lt; f4(std::make_shared&lt;Foo&gt;(foo)) &lt;&lt;std::endl;
    // 10
    // 10
}    
</code></pre>
<h4 id="std-ref-or-std-cref"><a href="#std-ref-or-std-cref" class="headerlink" title="std::ref or std::cref"></a><code>std::ref</code> or <code>std::cref</code></h4><p>定义在<code>&lt;functional&gt;</code>，两者是用于生成<code>std::reference_wrapper</code>的helper function。</p>
<h2 id="bind的基本原理"><a href="#bind的基本原理" class="headerlink" title="bind的基本原理"></a><code>bind</code>的基本原理</h2><p><code>bind</code>实际上采用的是延迟计算（lazy evalution）的思想，即<strong>将可调用对象保存起来，然后在需要的时候再调用</strong>。</p>
<p>要实现一个<code>bind</code>需要解决两个问题：</p>
<ul>
<li>保存可调用对象及其形参</li>
<li>如何实现调用</li>
</ul>
<h3 id="保存可调用对象及其形参"><a href="#保存可调用对象及其形参" class="headerlink" title="保存可调用对象及其形参"></a>保存可调用对象及其形参</h3><p>首先要解决的问题是：如何将可调用对象保存起来，以便在后面调用。<strong>要保存可调用对象，需要保存两个东西，一个是可调用对象的实例，另一个是可调用对象的形参。</strong></p>
<p>保存可调用对象的实例比较简单，因为在进行<code>bind</code>时，需要直接传入这个可调用对象，所以可以将其作为一个成员变量（member variable）即可。而保存可调用对象的形参相对麻烦一点，因为形参是变参，不能直接将变参作为成员变量。如果要保存变参的话，需要使用<code>tuple</code>。</p>
<h3 id="实现调用"><a href="#实现调用" class="headerlink" title="实现调用"></a>实现调用</h3><p><code>bind</code>的形参是变参，可以是<code>0</code>个，也可能是多个（大部分情况下是占位符，还有可能占位符和实参都有）。正是由于<code>bind</code>绑定的灵活性，导致在调用的时候需要找出哪些是占位符，哪些是实参。如果某个一参数是实参便不处理，如果是占位符，就需要将这个占位符替换为对应的实参。</p>
<p>比如我们绑定了一个三元函数：<code>auto f = bind(&amp;func, _1, 2, _2);</code>。调用为：<code>f(1,3);</code>。一共三个参数，一个实参，两个占位符，调用时传入了两个实参，这时就需要将占位符<code>_1</code>替换为实参<code>1</code>，占位符<code>_2</code>替换为实参<code>3</code>。<strong>占位符的替换需要按照调用实参的顺序来替换，如果调用时的实参个数比占位符要多，则忽略多余的实参</strong>。<br>　　<br>调用的实参会先被转换为<code>tuple</code>，以便接下来替换占位符时，可以选取合适的实参。</p>
<h2 id="bind实现的关键技术"><a href="#bind实现的关键技术" class="headerlink" title="bind实现的关键技术"></a><code>bind</code>实现的关键技术</h2><h3 id="将tuple展开为变参"><a href="#将tuple展开为变参" class="headerlink" title="将tuple展开为变参"></a>将<code>tuple</code>展开为变参</h3><p>在绑定可调用对象时，将可调用对象的形参（可能含占位符）保存起来（保存到<code>tuple</code>中）。到了调用阶段，需要反过来将<code>tuple</code>展开为可变参数，因为这个可变参数才是可调用对象的形参，否则就无法实现调用了。</p>
<p>需要借助于一个整形序列（integer sequence）来将<code>tuple</code>变为可变参数。在展开<code>tuple</code>的过程中，还需要根据占位符来选择合适实参，即占位符要替换为调用实参。</p>
<h3 id="根据占位符来选择合适的实参"><a href="#根据占位符来选择合适的实参" class="headerlink" title="根据占位符来选择合适的实参"></a>根据占位符来选择合适的实参</h3><p>此处比较关键，因为<code>tuple</code>中可能含有占位符。在展开<code>tuple</code>时，如果发现某个元素类型为占位符，则从由调用实参生成的<code>tuple</code>中取出一个实参，用来作为变参的一个参数；当某个类型不为占位符时，则直接从绑定时生成的形参<code>tuple</code>中取出参数，用来作为变参的一个参数。最终<code>tuple</code>被展开为一个变参列表，列表中没有占位符，全是实参，就可以实现调用。</p>
<p><strong>【注意】：</strong>在替换占位符时，需要通过占位符的模板参数<code>I</code>来从<code>tuple</code>中选择合适的参数，因为占位符<code>place_holder&lt;I&gt;</code>的实例<code>_1</code>实际上<code>place_holder&lt;1&gt;</code>， 占位符实例<code>_2</code>实际上是<code>place_holder&lt;2&gt;</code>，所以可以根据占位符的模板参数来获取其顺序。</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><pre><code class="cpp">/// 借助整形序列来将tuple变为可变参数
/// 定义一个整形序列index_sequence
template&lt;int...&gt;
struct index_sequence {};

/// 通过继承的方式，将参数包展开
template&lt;int N, int...Indices&gt;
struct make_index : make_index&lt;N-1, N-1, Indices...&gt; {};

/*
make_index&lt;1,2,3&gt;::type的展开过程：

    make_index&lt;3&gt; : make_index&lt;2, 2&gt;{ }
    make_index&lt;2, 2&gt; : make_index&lt;1, 1, 2&gt;{ }
    make_index&lt;1, 1, 2&gt; : make_index&lt;0, 0, 1, 2&gt; {
        typedef index_sequence&lt;0, 1, 2&gt; type;
    }
*/
template&lt;int...Indices&gt;
struct make_index&lt;0, Indices...&gt; {
    typedef index_sequence&lt;Indices...&gt; type;
};

template&lt;int I&gt;
struct place_holder {};

place_holder&lt;1&gt; _1;    
place_holder&lt;2&gt; _2;    
place_holder&lt;3&gt; _3;    
place_holder&lt;4&gt; _4;    
place_holder&lt;5&gt; _5;    
place_holder&lt;6&gt; _6;    
place_holder&lt;7&gt; _7;    
place_holder&lt;8&gt; _8;    
place_holder&lt;9&gt; _9;    
place_holder&lt;10&gt; _10;        

/// template&lt; class F, class... Args &gt;
/// /*unspecified*/ bind( F&amp;&amp; f, Args&amp;&amp;... args );

/// template&lt; class R, class F, class... Args &gt;
/// /*unspecified*/ bind( F&amp;&amp; f, Args&amp;&amp;... args );

///成员类型result_type
// 1) 若F是指向函数或指向成员函数的指针，则result_type为F。
//    若F是具有嵌套typedef result_type的class type，则result_type为F::result_type 。
//      否则不定义result_type。
// 2) result_type直接为R 。

/// result type traits
template&lt;typename T&gt;
struct result_traits : result_traits&lt;decltype(&amp;T::operator())&gt; {};

template&lt;typename T&gt;
struct result_traits&lt;T*&gt; : result_traits&lt;T&gt; {};

// 1）function pointer  
template&lt;typename Ret, typename...Args&gt;
struct result_traits&lt;Ret(*)(Args...)&gt; { typedef Ret type; };

// 1）member function
template&lt;typename Ret, typename Cls, typename...Args&gt;
struct result_traits&lt;Ret(Cls::*)(Args...)&gt; { typedef Ret type; };

/// 如果类型不是占位符，则直接从tuple中取出（实际上是直接将此类型forwarding）
template&lt;typename T, typename Tuple&gt;
inline auto select(T&amp;&amp; val, Tuple&amp;) -&gt; 
    typename std::add_rvalue_reference&lt;decltype(std::declval&lt;T&gt;())&gt;::type {
        return std::forward&lt;T&gt;(val);
}

/// 如果类型是占位符，则需要根据占位符选择实参（实参一开始就被放入tuple中，直接根据index选取即可）
/// _1实际上为place_holder&lt;1&gt;。根据place_holder的模板参数I，从tuple中选择参数
/// 在tuple中，index从0开始，所以要获取place_holder&lt;I&gt;占位符的参数，则应在tuple中使用std::get&lt;I-1&gt;(tp)
template&lt;int I, typename Tuple&gt;
inline auto select(place_holder&lt;I&gt;&amp;, Tuple&amp; tp) -&gt; 
                decltype(std::get&lt;I-1&gt;(tp)) {
    return std::get&lt;I-1&gt;(tp);
}

// 判断T是否为一个pointer，但不能检测是否为成员指针或者成员函数指针
template&lt;typename T&gt;
struct is_pointer_noref : 
    std::is_pointer&lt;
        typename std::remove_reference&lt;T&gt;::type
    &gt; {};

// 判断T是否为一个non-static member function pointer（且不是*&amp;这种类型）
template&lt;typename T&gt;
struct is_member_function_noref :
    std::is_member_function_pointer&lt;    
        typename std::remove_reference&lt;T&gt;::type
    &gt; {};

/// 根据不同callable object，将调用不同的invoke函数
//callable object：
//  1. function object
//  2. pointer to function
//  3. reference to function
//  4. pointer to member function
//  5. pointer to data member(先不考虑)

/// 2. pointer to function（函数指针）
/// ===&gt; Func是一个指向对象或者函数的pointer
template&lt;typename Ret, typename Func, typename...Args&gt;
inline typename std::enable_if&lt;
    is_pointer_noref&lt;Func&gt;::value, 
    Ret&gt;::type invoke(Func&amp;&amp; f, Args&amp;&amp;...args) {
        return (*std::forward&lt;Func&gt;(f))(std::forward&lt;Args&gt;(args)...);
        //    (*f)(args...)
}

/// pointer to function（）
/// ===&gt; Func是一个指向函数或者对象的pointer，
///         第一个实参是一个member function pointer
template&lt;typename Ret, typename Func, typename Arg1, typename...Args&gt;
inline typename std::enable_if&lt;
    is_member_function_noref&lt;Func&gt;::value &amp;&amp; 
        is_pointer_noref&lt;Arg1&gt;::value,
    Ret&gt;::type  invoke(Func&amp;&amp; f, Arg1&amp;&amp; ptr, Args...args) {
        return (std::forward&lt;Arg1&gt;(ptr)-&gt; 
            *std::forward&lt;Func&gt;(f))(std::forward&lt;Args&gt;(args)...);
        /// (ptr-&gt;*f)(args...)
}     

/// 4. pointer to member function
/// ===&gt; 不是一个指向对象或者函数的pointer，而是一个member function pointer
template&lt;typename Ret, typename Func, typename Arg1, typename...Args&gt;
inline typename std::enable_if&lt;
    is_member_function_noref&lt;Func&gt;::value &amp;&amp; 
        !is_pointer_noref&lt;Arg1&gt;::value,
    Ret&gt;::type invoke(Func&amp;&amp; f, Arg1 obj, Args...args) {
        return (std::forward&lt;Arg&gt;(obj).
            *std::forward&lt;Func&gt;(f))(std::forward&lt;Args&gt;(args)...);
        // (obj.*f)(args...)
}

/// 既不是pointer，也不是member function，则只能是
template&lt;typename Ret, typename Func, typename...Args&gt;
inline typename std::enable_if&lt;
    !is_pointer_noref&lt;Func&gt;::value &amp;&amp; 
        !is_member_function_noref&lt;Func&gt;::value,
    Ret&gt;::type invoke(Func&amp;&amp; f, Args...args) {
        return std::forward&lt;Func&gt;(f)(std::forward&lt;Args&gt;(args)...);
        // f(args...)
}

template&lt;typename Func, typename...Args&gt;
struct bind_t {
    // 获取callable object的type
    typedef typename std::decay&lt;Func&gt;::type callable_type;
    // 将所有的参数类型都压入tuple中
    typedef std::tuple&lt;typename std::decay&lt;Args&gt;::type...&gt; argument_type;
    typedef typename result_traits&lt;callable_type&gt;::type result_type;
public:
    template&lt;typename T, typename...BindArgs&gt;
    bind_t(Func&amp; f, BindArgs&amp;...args) : m_func(f) , m_args(args...) {}

    // move ctor
    template&lt;typename Func, typename...BindArgs&gt;
    bind_t(Func&amp;&amp; f, BindArgs&amp;&amp;...args) : 
        m_func(std::move(f)) , m_args(std::move(args)...) {}

    /// call：根据传入的每一个实参，去一一对应相应的形参
    // std::tuple_size：获取传入的实参的数量
    // make_index：对传入的实参进行编号
    // forward_as_tuple：将callable object中的形参压入tuple中    
    template&lt;typename...CallableArgs&gt;
    result_type operator()(CallableArgs&amp;&amp;...cal_args) {
        return call(typename make_index&lt;std::tuple_size&lt;
                        argument_type&gt;::value
                    &gt;::type(),
                    std::forward_as_tuple(std::forward&lt;CallableArgs&gt;(cal_args)...));
        // template &lt;typename... Types&gt; 
        // tuple&lt;Types&amp;&amp;...&gt; forward_as_tuple(Types&amp;&amp;... elements) {
        //         return tuple&lt;Types&amp;&amp;...&gt;(std::forward&lt;Types&gt;(elements)...);
        // }
    }

    template&lt;int...Indices, typename ArgumentTuple&gt;
    result_type call(index_sequence&lt;Indices...&gt; in, ArgumentTuple arg_tp) {
        return invoke&lt;result_type&gt;(m_func, 
            select(std::get&lt;Indices&gt;(m_args), arg_tp)...);
        // select函数根据获取得到的index，从tuple中获取得到对应的参数
    }

private:
    callable_type m_func;
    argument_type m_args;
};

template&lt;typename Func, typename...Args&gt;
inline bind_t&lt;Func, Args...&gt; bind(Func&amp;&amp; f, Args&amp;&amp;...args) {
    return bind_t&lt;Func, Args...&gt;(std::forward&lt;Func&gt;(f), 
            std::forward&lt;Args&gt;(args)...);
}

template&lt;typename Func, typename...Args&gt;
inline bind_t&lt;Func, Args...&gt; bind(Func&amp; f, Args&amp;...args) {
    return bind_t&lt;Func, Args...&gt;(f, args...);
}
</code></pre>
<h3 id="std-is-member-function-pointer"><a href="#std-is-member-function-pointer" class="headerlink" title="std::is_member_function_pointer"></a><code>std::is_member_function_pointer</code></h3><p>用于检查<code>T</code>是否是一个non-static member function pointer。如果是，则返回一个member constant value：<code>true</code>。</p>
<p>可能实现：</p>
<pre><code class="cpp">template&lt;typename T&gt;
struct is_member_function_pointer_helper : std::false_type {};

template&lt;typename T, typename Cls&gt;
struct is_member_function_pointer_helper&lt;T Cls::*&gt; : std::is_function&lt;T&gt; {};

template&lt;typename T&gt;
struct is_member_function_pointer : is_member_function_pointer_helper&lt;
                    typename std::remove_cv&lt;T&gt;::type&gt;&gt; {};
</code></pre>
<p>例子：</p>
<pre><code class="cpp">public:
    void member() {}
};

int main() {
    static_assert(std::is_member_function_pointer&lt;
                        decltype(&amp;A::member)&gt;::value,
                  &quot;A::member is not a memeber function.&quot;);
}    
</code></pre>
<h3 id="pointer-reference"><a href="#pointer-reference" class="headerlink" title="pointer reference"></a>pointer reference</h3><pre><code class="cpp">int* m = new int(5);
    int* ptr = m;
    //ptr=new int(6);
    int*&amp; ptr_ref = ptr;
    ptr_ref=new int(6);

    std::cout&lt;&lt; &quot;m=&quot; &lt;&lt; *m &lt;&lt;std::endl;
    std::cout&lt;&lt; &quot;ptr=&quot;&lt;&lt; *ptr &lt;&lt;std::endl;
    std::cout&lt;&lt; &quot;ptr_ref=&quot; &lt;&lt; *(&amp;(*ptr_ref)) &lt;&lt; std::endl;
</code></pre>
<p>改变<code>ptr</code>的值，将改变<code>ptr_ref</code>的值，而<code>m</code>的值不会发生改变（改变<code>ptr_ref</code>的值的效果一样）。</p>
<p><a href="https://stackoverflow.com/a/37722942/5383517" target="_blank" rel="noopener">Pointer to reference</a></p>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h3 id="C-17之前，shared-ptr不支持动态数组，而unique-ptr支持"><a href="#C-17之前，shared-ptr不支持动态数组，而unique-ptr支持" class="headerlink" title="C++17之前，shared_ptr不支持动态数组，而unique_ptr支持"></a>C++17之前，<code>shared_ptr</code>不支持动态数组，而<code>unique_ptr</code>支持</h3><pre><code class="cpp">std::unique_ptr&lt;int[]&gt; uptr(new int[10]);    //ok
std::shared_ptr&lt;int[]&gt; sptr(new int[10]);    //error
</code></pre>
<p>如果试图通过<code>std::shared_ptr</code>来创建动态数组，则需要显式指定删除器（deleter）。例如：</p>
<pre><code class="cpp">std::shared_ptr&lt;int&gt; p(new int[10], [](int* p){delete[] p;}); //指定delete[]
</code></pre>
<p>此外，可以用<code>std::default_delete</code>作为删除器：</p>
<pre><code class="cpp">std::shared_ptr&lt;int&gt; p(new int[10], std::default_delete&lt;int[]&gt;);
</code></pre>
<p>对此，可以封装一个<code>make_shared_array</code>方法让<code>shared_ptr</code>支持动态数组：</p>
<pre><code class="cpp">template&lt;typename T&gt;
std::shared_ptr&lt;T&gt; make_shared_array(size_t size) {
    return std::shared_ptr&lt;T&gt;(new T[size], std::default_delete&lt;T[]&gt;());
}
int main() {
    std::shared_ptr&lt;int&gt; ptr = make_shared_array&lt;int&gt;(10);
}
</code></pre>
<p><code>std::unique_ptr</code>缺少一个类似于<code>make_shared</code>的<code>make_unique</code>方法（c++14已经加入了<code>make_unique</code>）。其实要实现一个make_unique方法是比较简单的：</p>
<pre><code class="cpp">namespace impl {
// 支持普通指针
template&lt;typename T, typename...Args&gt;
inline typename std::enable_if&lt;!std::is_array&lt;T&gt;::value,
            std::unique_ptr&lt;T&gt;&gt;::type make_unique(Args&amp;&amp;...args) {
    return std::unique_ptr&lt;T&gt;(new T(std::forward&lt;Args&gt;(args)...));
} 

// 支持动态数组。对于动态数组，std::extent的值将为0
template&lt;typename T&gt;
typename std::enable_if&lt;std::is_array&lt;T&gt;::value &amp;&amp;
                            std::extent&lt;T&gt;::value == 0,
            std::unique_ptr&lt;T&gt;&gt;::type make_unique(size_t size) {
    typedef typename std::remove_extent&lt;T&gt;::type U;
    return std::unique_ptr&lt;T&gt;(new U[size]);
}

// 排除定长数组的情况
template&lt;typename T, typename...Args&gt;
typename std::enable_if&lt;std::extent&lt;T&gt;::value != 0,
            void&gt;::type make_unique(Args&amp;&amp;...) = delete;
}
</code></pre>
<p>测试：</p>
<pre><code class="cpp">int main() {
    // Use the default constructor.
    std::unique_ptr&lt;Vec3&gt; v1 = impl::make_unique&lt;Vec3&gt;();
    // Use the constructor that matches these arguments
    std::unique_ptr&lt;Vec3&gt; v2 = impl::make_unique&lt;Vec3&gt;(0, 1, 2);
    // Create a unique_ptr to an array of 5 elements
    std::unique_ptr&lt;Vec3[]&gt; v3 = impl::make_unique&lt;Vec3[]&gt;(5);

    std::cout &lt;&lt; &quot;make_unique&lt;Vec3&gt;():      &quot; &lt;&lt; *v1 &lt;&lt; &#39;\n&#39;
              &lt;&lt; &quot;make_unique&lt;Vec3&gt;(0,1,2): &quot; &lt;&lt; *v2 &lt;&lt; &#39;\n&#39;
              &lt;&lt; &quot;make_unique&lt;Vec3[]&gt;(5):   &quot; &lt;&lt; &#39;\n&#39;;
    for (int i = 0; i &lt; 5; i++) {
        std::cout &lt;&lt; &quot;     &quot; &lt;&lt; v3[i] &lt;&lt; &#39;\n&#39;;
    }
}
// make_unique&lt;Vec3&gt;():      {x:0 y:0 z:0}
// make_unique&lt;Vec3&gt;(0,1,2): {x:0 y:1 z:2}
// make_unique&lt;Vec3[]&gt;(5):
//      {x:0 y:0 z:0}
//      {x:0 y:0 z:0}
//      {x:0 y:0 z:0}
//      {x:0 y:0 z:0}
//      {x:0 y:0 z:0}
</code></pre>
<p>实现思路：如果不是数组，则直接创建<code>unique_ptr</code>；如果是数组的话，先判断是否为定长数组，如果为定长数组，则编译不通过；如果是非定长数组，则获取数组中的元素类型，再根据传入的参数<code>size</code>创建动态数组的<code>unique_ptr</code>（<code>extent&lt;T&gt;::value</code>用来获取数组的长度，如果获取值为<code>0</code>，则说明不是定长数组）。</p>
<h3 id="C-17中，可以使用std-shared-ptr管理动态数组。"><a href="#C-17中，可以使用std-shared-ptr管理动态数组。" class="headerlink" title="C++ 17中，可以使用std::shared_ptr管理动态数组。"></a>C++ 17中，可以使用<code>std::shared_ptr</code>管理动态数组。</h3><p>其中，<code>std::shared_ptr</code>的template parameter需要使用<code>T[N]</code>或者<code>T[]</code>。使用烦那个是：</p>
<pre><code class="cpp">std::shared_ptr&lt;int[]&gt; ptr(new int[10]);
</code></pre>
<blockquote>
<p><code>template&lt;class Y&gt; explicit shared_ptr(Y* p);</code><br>Requires: <code>Y</code> shall be a complete type. The expression <code>delete[] p</code>, when T is an array type, or <code>delete p</code>, when <code>T</code> is not an array type, shall have well-defined behavior, and shall not throw exceptions.<br>…<br>Remarks: When <code>T</code> is an array type, this constructor shall not participate in overload resolution unless the expression <code>delete[] p</code> is well-formed and either <code>T</code> is <code>U[N]</code> and <code>Y(*)[N]</code> is convertible to <code>T*</code>, or <code>T</code> is  <code>U[]</code> and <code>Y(*)[]</code> is convertible to <code>T*</code>. …</p>
</blockquote>
<p>为了支持上述操作，成员类型<code>element_type</code>将被定义为：</p>
<pre><code class="cpp">using element_type = remove_extent&lt;T&gt;;
</code></pre>
<p>此外，还可以通过使用<code>operator[]</code>来访问数组中的元素：</p>
<pre><code class="cpp">element_type&amp; operator[](ptrdiff_t i) const;
</code></pre>
<h3 id="shared-ptr和unique-ptr指定删除器方式不同"><a href="#shared-ptr和unique-ptr指定删除器方式不同" class="headerlink" title="shared_ptr和unique_ptr指定删除器方式不同"></a><code>shared_ptr</code>和<code>unique_ptr</code>指定删除器方式不同</h3><pre><code class="cpp">std:: shared_ptr&lt;int&gt; ptr(new int(1), [](int*p){delete p;}); //ok
std::unique_ptr&lt;int&gt; ptr(new int(1), [](int*p){delete p;});  //error
</code></pre>
<p><code>std::unique_ptr</code>指定删除器的时候，需要确定删除器的类型，所以不能直接像<code>shared_ptr</code>那样指定删除器，可以这样写：</p>
<pre><code class="cpp">std::unique_ptr&lt;int, void(*)(int*)&gt; ptr(new int(1), [](int*p){delete p;});
</code></pre>
<p>这种写法在lambda没有捕获变量的情况下是正确的，如果捕获了变量则会编译报错：</p>
<pre><code class="cpp">std::unique_ptr&lt;int, void(*)(int*)&gt; ptr(new int(1), [&amp;](int*p){delete p;}); //错误，因为捕获了变量
</code></pre>
<p>lambda捕获变量后，<code>unique_ptr</code>报错的原因：<strong>lambda在没有捕获变量的情况下，是可以直接转换为函数指针的，捕获了就不能转换为函数指针</strong>。</p>
<p>如果希望<code>unique_ptr</code>的删除器支持lambda，可以这样写：</p>
<pre><code class="cpp">std::unique_ptr&lt;int, std::function&lt;void(int*)&gt;&gt; ptr(new int(1), [&amp;](int*p){delete p;});
</code></pre>
<p>此外，还可以自定义<code>unique_ptr</code>的删除器。例如：</p>
<pre><code class="cpp">struct deleter {
    void operator()(int* p) {
        std::cout&lt;&lt; &quot;delete&quot; &lt;&lt;std::endl;
        delete p;
    }
};

int main() {
    std::unique_ptr&lt;int, deleter&gt; p(new int(1));
}
</code></pre>
<p>智能指针可以很方便的管理当前程序库动态分配的内存，还可以用来管理第三方库分配的内存。<strong>第三方库分配的内存一般需要通过第三方库提供的释放接口才能释放，由于第三方库返回出来的指针一般都是原始指针，如果用完之后没有调用第三方库的释放接口，就很容易造成内存泄露</strong>。比如下面的代码：</p>
<pre><code class="cpp">void* p = GetHandle()-&gt;Create();
//do something…
GetHandle()-&gt;Release(p);
</code></pre>
<p>这段代码可能存在风险，在使用第三方库分配的内存过程中，可能忘记调用<code>Release</code>接口，可能中间不小心返回了，还有可能中间发生了异常，导致无法调用<code>Release</code>接口。这时可以用智能指针去管理第三方库的内存，只要出了作用域内存就会自动释放，不用显式地去调用释放接口，不用担心中途返回或者发生异常导致无法调用释放接口的问题。</p>
<pre><code class="cpp">void* p = GetHandle()-&gt;Create();
std::shared_ptr&lt;void&gt; sp(p, [this](void*p){ GetHandle()-&gt;Release(p);});
</code></pre>
<p>上面这段代码就可以保证，在任何时候都能正确释放第三方库分配的内存。虽然能解决问题，但还是有些繁琐，因为每个第三方库分配内存的地方都要调用这段代码。所以可以将这段代码提炼出来，作为一个公共函数，简化调用。</p>
<pre><code class="cpp">std::shared_ptr&lt;void&gt;  Guard(void* p) {
    return std::shared_ptr&lt;void&gt; sp(p, [this](void*p){ GetHandle()-&gt;Release(p);});
}
void* p = GetHandle()-&gt;Create();
auto sp = Guard(p);
//do something…
</code></pre>
<p>上面的代码通过<code>Guard</code>函数做了简化，用起来比较方便，但仍然不够安全，因为有可能使用者可能会这样写：</p>
<pre><code class="cpp">void* p = GetHandle()-&gt;Create();
Guard(p); //危险，这句结束之后p就被释放了
//do something…
</code></pre>
<p>这样写是有问题的，会导致访问野指针，因为<code>Guard(p);</code>是一个rvalue，如果不赋值给它一个指针的话，<code>Guard(p);</code>这句结束之后，就会释放，从而导致<code>p</code>提前释放了，后面就会访问野指针的内容。</p>
<p><code>auto sp = Guard(p);</code>需要一个赋值操作，忘记赋值则会导致指针提前释放，所以这种写法仍然不够安全。可以定义一个宏来解决这个问题：</p>
<pre><code class="cpp">#define GUARD(P) std::shared_ptr&lt;void&gt; p##p(p, [](void*p){ GetHandle()-&gt;Release(p);});

void* p = GetHandle()-&gt;Create();
GUARD(p); //安全
</code></pre>
<p>或者使用<code>std::unique_ptr</code>：</p>
<pre><code class="cpp">#define GUARD(P) std::unique_ptr&lt;void, void(*)(int*)&gt; p##p(p, [](void*p){ GetHandle()-&gt;Release(p);});
</code></pre>
<p><strong>【注意】：</strong><code>#</code>与<code>##</code>运算符</p>
<ul>
<li><code>#</code>将后面的宏参数进行字符串操作（即将后面的参数用双引号引起来）</li>
<li><code>##</code>用于连接。</li>
</ul>
<p>例子：</p>
<pre><code class="cpp">#define PRINT(NAME) printf(&quot;token&quot;#NAME&quot;=%d\n&quot;, token##NAME)

PRINT(9);
</code></pre>
<p>宏展开为：<code>printf(&quot;token&quot;#9&quot;=%d\n&quot;,token##9);</code>。<code>#9</code>即为<code>&quot;9&quot;</code>，<code>token##9</code>即为：<code>token9</code>。整个为：<code>printf(&quot;token&quot;&quot;9&quot;&quot;=%d\n&quot;,token9);</code><br>所以输出：<code>token9=9;</code></p>
<h3 id="std-default-delete"><a href="#std-default-delete" class="headerlink" title="std::default_delete"></a><code>std::default_delete</code></h3><p>定义在<code>&lt;memory&gt;</code>，其原型为：</p>
<pre><code class="cpp">template&lt; class T &gt; struct default_delete; //使用delete删除分配的单个对象的内存
template&lt; class T &gt; struct default_delete&lt;T[]&gt;; //此特化版本用delete[]来删除数组
</code></pre>
<p><code>std::default_delete</code>是在用户没有指定删除器的情况下，<code>std::unique_ptr</code>（对<code>std::shared_ptr</code>也适用）所采用的的默认删除策略。</p>
<h2 id="通过std-tuple来实现函数调用"><a href="#通过std-tuple来实现函数调用" class="headerlink" title="通过std::tuple来实现函数调用"></a>通过<code>std::tuple</code>来实现函数调用</h2><pre><code class="cpp">template&lt;int...&gt;
struct index_tuple {};

template&lt;int N, int... Indices&gt;
struct make_index : make_index&lt;N-1, N-1, Indices...&gt; {};

template&lt;int... Indices&gt;
struct make_index&lt;0, Indices...&gt; {
    typedef index_tuple&lt;Indices...&gt; type;
};

template&lt;typename Func, int... Indices, typename... Args&gt;
void call_helper(Func func, index_tuple&lt;Indices...&gt;, 
            const std::tuple&lt;Args...&gt;&amp; tup) {
    func(std::get&lt;Indices&gt;(tup)...);
}

template&lt;typename Func, typename... Args&gt;
void call(Func func, const std::tuple&lt;Args...&gt;&amp; tup) {
    call_helper(func, typename make_index&lt;sizeof...(Args)&gt;::type(), tup);
}

int func(int a, int b) {
    std::cout&lt;&lt; a+b &lt;&lt;std::endl;        
}

int main() {
    std::tuple&lt;int, int&gt; tup = std::make_tuple(1,2);

    call&lt;int(int,int), int&gt;(func, tup);
}
</code></pre>
<h2 id="类型擦除（type-erasure）"><a href="#类型擦除（type-erasure）" class="headerlink" title="类型擦除（type erasure）"></a>类型擦除（type erasure）</h2><p><strong>类型擦除就是将原有类型消除或者隐藏</strong>。需要擦除类型的原因：很多时候并不关心具体类型是什么或者根本就不需要这个类型。</p>
<p>C++中类型擦除方式主要有：</p>
<ol>
<li>通过多态来擦除类型</li>
<li>通过模板来擦除类型</li>
<li>通过某种容器来擦除类型</li>
<li>通过某种通用类型来擦除类型</li>
</ol>
<h3 id="1-通过多态来擦除类型"><a href="#1-通过多态来擦除类型" class="headerlink" title="1. 通过多态来擦除类型"></a>1. 通过多态来擦除类型</h3><p>这种方式比较常见，通过将派生类型（derived type）隐式转换成基类型（base type），再通过基类去多态地调用行为。</p>
<p>在这种情况下，不用关心派生类的具体类型，而只需要以一种统一的方式去做不同的事情即可。所以把派生类型转成基类型隐藏起来，这样不仅仅可以多态调用，还使程序具有良好的可扩展性。</p>
<p>然而这种方式仅仅是部分的类型擦除，因为基类型仍然存在。此外，这种类型擦除的方式还必须得以继承的方式方式进行，而且继承使得两个对象强烈地耦合在一起。所以，通过多态来擦除类型的方式有较多局限性。</p>
<h3 id="2-通过模板来擦除类型"><a href="#2-通过模板来擦除类型" class="headerlink" title="2. 通过模板来擦除类型"></a>2. 通过模板来擦除类型</h3><p>通过模板来擦除类型，本质上是把不同类型的共同行为进行抽象。这时，不同类型彼此之间不再需要通过继承（强耦合的方式）去获得共同的行为，而仅仅是通过模板就能获取共同行为，降低了不同类型之间的耦合，是一种很好的类型擦除方式。</p>
<p>然而，第二种方式虽然降低了对象间的耦合，但是还有一个问题没解决：<strong>基本类型始终需要指定，并没有消除基本类型</strong>。例如，不可能把一个<code>T</code>本身作为容器元素，而必须在容器初始化时就要到<code>T</code>的具体类型。而C++并没有像C#和Java中的<code>object</code>类型，是所有类型的基类。但可以用<code>boost.variant</code>类型来把各种不同的类型包起来，从而可以获得一种统一的类型，而且不同类型的对象间没有耦合关系，它仅仅是一个类型的容器。</p>
<pre><code class="cpp">struct blob {
    std::string pBuf;
    int size;
};

    typedef boost::variant&lt;double, int, std::string, blob&gt; Value;
    std::vector&lt;Value&gt; ivec;
    ivec.push_back(10);
    ivec.push_back(&quot;c++&quot;);
    ivec.push_back(1.1);
    ivec.push_back({&quot;java&quot;, 4});
</code></pre>
<p>上面的代码擦除了不同类型，使得不同的类型都可以放到一个容器中。通过<code>get&lt;T&gt;(Value)</code>便可以获取对应类型的值。</p>
<p>这种方式是通过某种容器把类型包起来，从而达到类型擦除的目的。它的缺点是这个通用的类型必须事先定义好，只能容纳声明的那些类型，增加一种新类型就不行了。</p>
<h3 id="4-通过某种通用类型来擦除类型"><a href="#4-通过某种通用类型来擦除类型" class="headerlink" title="4. 通过某种通用类型来擦除类型"></a>4. 通过某种通用类型来擦除类型</h3><p>通过这种方式可以消除之前的缺点，其类似于C#和Java中的<code>object</code>类型。这种通用类型是通过<code>boost.any</code>实现的，它不需要预先定义类型，不同类型都可以转成<code>any</code>。</p>
<h2 id="实现any"><a href="#实现any" class="headerlink" title="实现any"></a>实现<code>any</code></h2><p><code>any</code>能容纳所有类型的数据。因此，当赋值给<code>any</code>时，需要将值的类型擦除才行，即以一种通用的方式保存所有类型的数据。</p>
<p>基本思路：<strong>可以通过继承去擦除类型（type erasure），基类中不含模板参数，派生类中才有模板参数。这个模板参数类型正是赋值的类型，在赋值时，将创建的派生类对象赋值给基类指针，基类的派生类中携带了数据类型，基类只是原始数据的一个占位符，通过多态，它擦除了原始数据类型</strong>。因此，任何数据类型都可以赋值给它，从而实现了能存放所有类型数据的目标。当取数据时，需要向下转换成派生类型来获取原始数据；当转换失败时，打印详情，并抛出异常。由于<code>any</code>赋值时需要创建一个派生类对象，所以还需要管理该对象的生命周期，用<code>unique_ptr</code>去管理对象的生命周期。</p>
<pre><code class="cpp">struct any {
    any(void) : m_index(std::type_index(typeid(void))) {}
    any(const any&amp; other) : 
        m_ptr(other.clone()), m_index(other.m_index) {}
    any(any&amp;&amp; other) :
        m_ptr(std::move(other.m_ptr)), m_index(other.m_index) {}

    //在创建智能指针时，对于一般的类型，需要通过std::decay来移除引用和cv 
    //qualifier，从而得到原始类型

    //当使用普通类型T（即当T不是已知的的any类型时）创建any时，
    //便使用Perfect forwarding of T
    template&lt;typename T,
            typename = typename std::enable_if&lt;
                !std::is_same&lt;
                    typename std::decay&lt;T&gt;::type,
                    any&gt;::value,
            T&gt;::type
        &gt; any(T&amp;&amp; value) : 
            m_ptr(new derived(value)),
            m_index(std::type_index(
                typeid(typename std::decay&lt;T&gt;::type))) {}

    bool is_null() const {
        return !bool(m_ptr);
    }

    template&lt;typename T&gt;
    bool is_type() const {
        return m_index == std::type_index(typeid(T));
    }

    template&lt;typename T&gt;
    T&amp; any_cast() {
        if(!is_type&lt;T&gt;()) {
            std::cout&lt;&lt; &quot;cannot casting &quot;&lt;&lt; typeid(T).name()
                &lt;&lt; &quot; to &quot; &lt;&lt;m_index.name() &lt;&lt;std::endl;
            throw bad_cast();
        }
        auto derived_type = dynamic_cast&lt;derived&lt;T*&gt;*&gt;(m_ptr.get());
        return derived_type-&gt;m_value;
    }

    any&amp; operator=(const any&amp; other) {
        if(m_ptr == other.m_ptr) {
            return *this;
        }
        m_ptr = other.clone();
        m_index = other.m_index;
        return *this;
    }
private:
    struct base;
    typedef std::unique_ptr&lt;base&gt; base_ptr;

    struct base {
        virtual ~base() {}
        virtual base_ptr clone() const = 0;
    };

    template&lt;typename T&gt;
    struct derived : base {
        template&lt;typename U&gt;
        derived(U&amp;&amp; value) : m_value(std::forward&lt;U&gt;(value)) {}

        base_ptr clone() const {
            return base_ptr(new derived&lt;T&gt;(m_value));
        }

        T m_value;
    };

    base_ptr clone() const {
        if(m_ptr != nullptr) {
            return m_ptr -&gt; clone();
        }
        return nullptr;
    } 

    base_ptr m_ptr;
    std::type_index m_index;
}; 
</code></pre>
<p>扩展：<a href="https://github.com/thelink2012/any/blob/master/any.hpp" target="_blank" rel="noopener">any implementation</a></p>
<h2 id="strtod"><a href="#strtod" class="headerlink" title="strtod"></a><code>strtod</code></h2><p>函数原型为：</p>
<pre><code class="cpp">double strtod( const char* str, const** str_end);
</code></pre>
<p>把参数<code>str</code>所指向的字符串转换为一个浮点数（类型为<code>double</code>型）。如果<code>str_end</code>不为空，则指向转换中最后一个字符后的字符的指针会存储在<code>str_end</code>引用的位置。</p>

        
    

    
</div>


                

                <!-- Post Comments -->
                
                    
                
            </div>

            <!-- Post Prev & Next Nav -->
            <nav class="material-nav mdl-color-text--grey-50 mdl-cell mdl-cell--12-col">
    <!-- Prev Nav -->
    

    <!-- Section Spacer -->
    <div class="section-spacer"></div>

    <!-- Next Nav -->
    
        <a href="/2018/07/09/Linux ABI/" id="post_nav-older" class="next-content">
            旧篇
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_forward</i>
            </button>
        </a>
    
</nav>

        </div>
    </div>



                    
                        <!-- Overlay For Active Sidebar -->
<div class="sidebar-overlay"></div>

<!-- Material sidebar -->
<aside id="sidebar" class="sidebar sidebar-colored sidebar-fixed-left" role="navigation">
    <div id="sidebar-main">
        <!-- Sidebar Header -->
        <div class="sidebar-header header-cover" style="background-image: url(/img/sidebar_header.png);">
    <!-- Top bar -->
    <div class="top-bar"></div>

    <!-- Sidebar toggle button -->
    <button type="button" class="sidebar-toggle mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon" style="display: initial;" data-upgraded=",MaterialButton,MaterialRipple">
        <i class="material-icons">clear_all</i>
        <span class="mdl-button__ripple-container">
            <span class="mdl-ripple">
            </span>
        </span>
    </button>

    <!-- Sidebar Avatar -->
    <div class="sidebar-image">
        <img src="/img/avatar.png" alt="Magicmanoooo's avatar">
    </div>

    <!-- Sidebar Email -->
    <a data-toggle="dropdown" class="sidebar-brand" href="#settings-dropdown">
        838713968@qq.com
        <b class="caret"></b>
    </a>
</div>


        <!-- Sidebar Navigation  -->
        <ul class="nav sidebar-nav">
    <!-- User dropdown  -->
    <li class="dropdown">
        <ul id="settings-dropdown" class="dropdown-menu">
            
                <li>
                    <a href="mailto: 838713968@qq.com" target="_blank" title="Email Me">
                        
                            <i class="material-icons sidebar-material-icons sidebar-indent-left1pc-element">email</i>
                        
                        Email Me
                    </a>
                </li>
            
        </ul>
    </li>

    <!-- Homepage -->
    
        <li id="sidebar-first-li">
            <a href="/">
                
                    <i class="material-icons sidebar-material-icons">home</i>
                
                主页
            </a>
        </li>
        
    

    <!-- Archives  -->
    
        <li class="dropdown">
            <a href="#" class="ripple-effect dropdown-toggle" data-toggle="dropdown">
                
                    <i class="material-icons sidebar-material-icons">inbox</i>
                
                    归档
                <b class="caret"></b>
            </a>
            <ul class="dropdown-menu">
            <li>
                <a class="sidebar_archives-link" href="/archives/2018/07/">七月 2018<span class="sidebar_archives-count">5</span></a>
            </ul>
        </li>
        
    

    <!-- Categories  -->
    
        <li class="dropdown">
            <a href="#" class="ripple-effect dropdown-toggle" data-toggle="dropdown">
                
                    <i class="material-icons sidebar-material-icons">chrome_reader_mode</i>
                
                分类
                <b class="caret"></b>
            </a>
            <ul class="dropdown-menu">
                <li>
                
            </ul>
        </li>
        
    

    <!-- Pages  -->
    

    <!-- Article Number  -->
    
        <li>
            <a href="/archives">
                文章总数
                <span class="sidebar-badge">5</span>
            </a>
        </li>
        
    
</ul>


        <!-- Sidebar Footer -->
        <!--
I'm glad you use this theme, the development is no so easy, I hope you can keep the copyright, I will thank you so much.
If you still want to delete the copyrights, could you still retain the first one? Which namely "Theme Material"
It will not impact the appearance and can give developers a lot of support :)

很高兴您使用并喜欢该主题，开发不易 十分谢谢与希望您可以保留一下版权声明。
如果您仍然想删除的话 能否只保留第一项呢？即 "Theme Material"
它不会影响美观并可以给开发者很大的支持和动力。 :)
-->

<!-- Sidebar Divider -->

    <div class="sidebar-divider"></div>


<!-- Theme Material -->


<!-- Help & Support -->
<!--

    <a href="mailto:hiviosey@gmail.com" class="sidebar-footer-text-a">
        <div class="sidebar-text mdl-button mdl-js-button mdl-js-ripple-effect sidebar-footer-text-div" data-upgraded=",MaterialButton,MaterialRipple">
        sidebar.help
        <span class="mdl-button__ripple-container">
          <span class="mdl-ripple"></span>
        </span>
      </div>
    </a>

-->

<!-- Feedback -->
<!--

    <a href="https://github.com/viosey/hexo-theme-material/issues" target="_blank" class="sidebar-footer-text-a">
        <div class="sidebar-text mdl-button mdl-js-button mdl-js-ripple-effect sidebar-footer-text-div" data-upgraded=",MaterialButton,MaterialRipple">
        sidebar.feedback
        <span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span></div>
    </a>

-->

<!-- About Theme -->
<!--

    <a href="https://blog.viosey.com/index.php/Material.html" target="_blank" class="sidebar-footer-text-a">
        <div class="sidebar-text mdl-button mdl-js-button mdl-js-ripple-effect sidebar-footer-text-div" data-upgraded=",MaterialButton,MaterialRipple">
             sidebar.about_theme
            <span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span></div>
    </a>

-->

    </div>

    <!-- Sidebar Image -->
    

</aside>

                    

                    
                        <!-- Footer Top Button -->
                        <div id="back-to-top" class="toTop-wrap">
    <a href="#top" class="toTop">
        <i class="material-icons footer_top-i">expand_less</i>
    </a>
</div>

                    

                    <!--Footer-->
<footer class="mdl-mini-footer" id="bottom">
    
        <!-- Paradox Footer Left Section -->
        <div class="mdl-mini-footer--left-section sns-list">
    <!-- Twitter -->
    

    <!-- Facebook -->
    

    <!-- Google + -->
    

    <!-- Weibo -->
    
        <a href="https://weibo.com/5345088988/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-weibo">
                <span class="visuallyhidden">Weibo</span>
            </button><!--
     --></a>
    

    <!-- Instagram -->
    

    <!-- Tumblr -->
    

    <!-- Github -->
    
        <a href="https://github.com/Azurery" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-github">
                <span class="visuallyhidden">Github</span>
            </button><!--
     --></a>
    

    <!-- LinkedIn -->
    

    <!-- Zhihu -->
    
        <a href="https://www.zhihu.com/people/zhang-tao-60-41/activities" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-zhihu">
                <span class="visuallyhidden">Zhihu</span>
            </button><!--
     --></a>
    

    <!-- Bilibili -->
    
        <a href="https://space.bilibili.com/94222521/#/" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-bilibili">
                <span class="visuallyhidden">Bilibili</span>
            </button><!--
     --></a>
    

    <!-- Telegram -->
    
    
    <!-- V2EX -->
    
</div>


        <!--Copyright-->
        <div id="copyright">
            Copyright&nbsp;©&nbsp;2017&nbsp;-<script type="text/javascript">var fd = new Date();document.write("&nbsp;" + fd.getFullYear() + "&nbsp;");</script>Azurery
            
                <br>
                
                    只有永不遏止的奋斗，才能使青春之花，即使是凋谢，也是壮丽地凋谢
                
            
        </div>

        <!-- Paradox Footer Right Section -->

        <!--
        I am glad you use this theme, the development is no so easy, I hope you can keep the copyright.
        It will not impact the appearance and can give developers a lot of support :)

        很高兴您使用该主题，开发不易，希望您可以保留一下版权声明。
        它不会影响美观并可以给开发者很大的支持。 :)
        -->

        <div class="mdl-mini-footer--right-section">
            <div>
                <div class="footer-develop-div">Powered by <a href="https://hexo.io" target="_blank" class="footer-develop-a">Hexo</a></div>
                <div class="footer-develop-div">Theme - <a href="https://github.com/viosey/hexo-theme-material" target="_blank" class="footer-develop-a">Material</a></div>
            </div>
        </div>
    
</footer>


                    <!-- Import JS File -->

    <script>lsloader.load("lazyload_js","/js/lazyload.min.js?1BcfzuNXqV+ntF6gq+5X3Q==", true)</script>



    <script>lsloader.load("js_js","/js/js.min.js?V/53wGualMuiPM3xoetD5Q==", true)</script>



    <script>lsloader.load("np_js","/js/nprogress.js?pl3Qhb9lvqR1FlyLUna1Yw==", true)</script>


<script type="text/ls-javascript" id="NProgress-script">
    NProgress.configure({
        showSpinner: true
    });
    NProgress.start();
    $('#nprogress .bar').css({
        'background': '#29d'
    });
    $('#nprogress .peg').css({
        'box-shadow': '0 0 10px #29d, 0 0 15px #29d'
    });
    $('#nprogress .spinner-icon').css({
        'border-top-color': '#29d',
        'border-left-color': '#29d'
    });
    setTimeout(function() {
        NProgress.done();
        $('.fade').removeClass('out');
    }, 800);
</script>













<!-- UC Browser Compatible -->
<script>
	var agent = navigator.userAgent.toLowerCase();
	if(agent.indexOf('ucbrowser')>0) {
		document.write('<link rel="stylesheet" href="/css/uc.css">');
	   alert('由于 UC 浏览器使用极旧的内核，而本网站使用了一些新的特性。\n为了您能更好的浏览，推荐使用 Chrome 或 Firefox 浏览器。');
	}
</script>

<!-- Import prettify js  -->

    
        
            <script>lsloader.load("prettify_js","/js/prettify.min.js?WN07fivHQSMKWy7BmHBB6w==", true)</script>
        
    



<!-- Window Load -->
<!-- add class for prettify -->
<script type="text/ls-javascript" id="window-load">
    $(window).on('load', function() {
        // Post_Toc parent position fixed
        $('.post-toc-wrap').parent('.mdl-menu__container').css('position', 'fixed');
    });

    
        
            $(function() {
                $('pre').addClass('prettyprint linenums').attr('style', 'overflow:auto;');
                prettyPrint();
                })
        
    
    
</script>

<!-- MathJax Load-->


<!-- Bing Background -->


<script type="text/ls-javascript" id="lazy-load">
    // Offer LazyLoad
    queue.offer(function(){
        $('.lazy').lazyload({
            effect : 'show'
        });
    });

    // Start Queue
    $(document).ready(function(){
        setInterval(function(){
            queue.execNext();
        },200);
    });
</script>

<!-- Custom Footer -->



<script>
    (function(){
        var scriptList = document.querySelectorAll('script[type="text/ls-javascript"]')

        for (var i = 0; i < scriptList.length; ++i) {
            var item = scriptList[i];
            lsloader.runInlineScript(item.id,item.id);
        }
    })()
console.log('\n %c © Material Theme | Version: 1.5.0 | https://github.com/viosey/hexo-theme-material %c \n', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-left-radius:5px;border-bottom-left-radius:5px;', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-right-radius:5px;border-bottom-right-radius:5px;');
</script>

                </main>
            </div>
        </body>
    
</html>
