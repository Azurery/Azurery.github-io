<!DOCTYPE html>
<html style="display: none;" lang="zh">
    <head>
    <meta charset="utf-8">
    <!--
        © Material Theme
        https://github.com/viosey/hexo-theme-material
        Version: 1.5.0 -->
    <script>
        window.materialVersion = "1.5.0"
        // Delete localstorage with these tags
        window.oldVersion = [
            'codestartv1',
            '1.3.4',
            '1.4.0',
            '1.4.0b1'
        ]
    </script>

    <!-- dns prefetch -->
    <meta http-equiv="x-dns-prefetch-control" content="on">














    <!-- Title -->
    
    <title>
        
            C++点点滴滴（上） | 
        
        Azurery
    </title>

    <!-- Meta & Info -->
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="format-detection" content="telephone=no"/>
    <meta name="theme-color" content="#0097A7">
    <meta name="author" content="Magicmanoooo">
    <meta name="description" itemprop="description" content="蒟蒻一枚">
    <meta name="keywords" content=",C++">

    <!-- Import lsloader -->
    <script>(function(){window.lsloader={jsRunSequence:[],jsnamemap:{},cssnamemap:{}};lsloader.removeLS=function(key){try{localStorage.removeItem(key)}catch(e){}};lsloader.setLS=function(key,val){try{localStorage.setItem(key,val)}catch(e){}};lsloader.getLS=function(key){var val="";try{val=localStorage.getItem(key)}catch(e){val=""}return val};versionString="/*"+(window.materialVersion||"unknownVersion")+"*/";lsloader.clean=function(){try{var keys=[];for(var i=0;i<localStorage.length;i++){keys.push(localStorage.key(i))}keys.forEach(function(key){var data=lsloader.getLS(key);if(window.oldVersion){var remove=window.oldVersion.reduce(function(p,c){return p||data.indexOf("/*"+c+"*/")!==-1},false);if(remove){lsloader.removeLS(key)}}})}catch(e){}};lsloader.clean();lsloader.load=function(jsname,jspath,cssonload,isJs){if(typeof cssonload==="boolean"){isJs=cssonload;cssonload=undefined}isJs=isJs||false;cssonload=cssonload||function(){};var code;code=this.getLS(jsname);if(code&&code.indexOf(versionString)===-1){this.removeLS(jsname);this.requestResource(jsname,jspath,cssonload,isJs);return}if(code){var versionNumber=code.split(versionString)[0];if(versionNumber!=jspath){console.log("reload:"+jspath);this.removeLS(jsname);this.requestResource(jsname,jspath,cssonload,isJs);return}code=code.split(versionString)[1];if(isJs){this.jsRunSequence.push({name:jsname,code:code});this.runjs(jspath,jsname,code)}else{document.getElementById(jsname).appendChild(document.createTextNode(code));cssonload()}}else{this.requestResource(jsname,jspath,cssonload,isJs)}};lsloader.requestResource=function(name,path,cssonload,isJs){var that=this;if(isJs){this.iojs(path,name,function(path,name,code){that.setLS(name,path+versionString+code);that.runjs(path,name,code)})}else{this.iocss(path,name,function(code){document.getElementById(name).appendChild(document.createTextNode(code));that.setLS(name,path+versionString+code)},cssonload)}};lsloader.iojs=function(path,jsname,callback){var that=this;that.jsRunSequence.push({name:jsname,code:""});try{var xhr=new XMLHttpRequest;xhr.open("get",path,true);xhr.onreadystatechange=function(){if(xhr.readyState==4){if(xhr.status>=200&&xhr.status<300||xhr.status==304){if(xhr.response!=""){callback(path,jsname,xhr.response);return}}that.jsfallback(path,jsname)}};xhr.send(null)}catch(e){that.jsfallback(path,jsname)}};lsloader.iocss=function(path,jsname,callback,cssonload){var that=this;try{var xhr=new XMLHttpRequest;xhr.open("get",path,true);xhr.onreadystatechange=function(){if(xhr.readyState==4){if(xhr.status>=200&&xhr.status<300||xhr.status==304){if(xhr.response!=""){callback(xhr.response);cssonload();return}}that.cssfallback(path,jsname,cssonload)}};xhr.send(null)}catch(e){that.cssfallback(path,jsname,cssonload)}};lsloader.iofonts=function(path,jsname,callback,cssonload){var that=this;try{var xhr=new XMLHttpRequest;xhr.open("get",path,true);xhr.onreadystatechange=function(){if(xhr.readyState==4){if(xhr.status>=200&&xhr.status<300||xhr.status==304){if(xhr.response!=""){callback(xhr.response);cssonload();return}}that.cssfallback(path,jsname,cssonload)}};xhr.send(null)}catch(e){that.cssfallback(path,jsname,cssonload)}};lsloader.runjs=function(path,name,code){if(!!name&&!!code){for(var k in this.jsRunSequence){if(this.jsRunSequence[k].name==name){this.jsRunSequence[k].code=code}}}if(!!this.jsRunSequence[0]&&!!this.jsRunSequence[0].code&&this.jsRunSequence[0].status!="failed"){var script=document.createElement("script");script.appendChild(document.createTextNode(this.jsRunSequence[0].code));script.type="text/javascript";document.getElementsByTagName("head")[0].appendChild(script);this.jsRunSequence.shift();if(this.jsRunSequence.length>0){this.runjs()}}else if(!!this.jsRunSequence[0]&&this.jsRunSequence[0].status=="failed"){var that=this;var script=document.createElement("script");script.src=this.jsRunSequence[0].path;script.type="text/javascript";this.jsRunSequence[0].status="loading";script.onload=function(){that.jsRunSequence.shift();if(that.jsRunSequence.length>0){that.runjs()}};document.body.appendChild(script)}};lsloader.tagLoad=function(path,name){this.jsRunSequence.push({name:name,code:"",path:path,status:"failed"});this.runjs()};lsloader.jsfallback=function(path,name){if(!!this.jsnamemap[name]){return}else{this.jsnamemap[name]=name}for(var k in this.jsRunSequence){if(this.jsRunSequence[k].name==name){this.jsRunSequence[k].code="";this.jsRunSequence[k].status="failed";this.jsRunSequence[k].path=path}}this.runjs()};lsloader.cssfallback=function(path,name,cssonload){if(!!this.cssnamemap[name]){return}else{this.cssnamemap[name]=1}var link=document.createElement("link");link.type="text/css";link.href=path;link.rel="stylesheet";link.onload=link.onerror=cssonload;var root=document.getElementsByTagName("script")[0];root.parentNode.insertBefore(link,root)};lsloader.runInlineScript=function(scriptId,codeId){var code=document.getElementById(codeId).innerText;this.jsRunSequence.push({name:scriptId,code:code});this.runjs()};lsloader.loadCombo=function(jslist){var updateList="";var requestingModules={};for(var k in jslist){var LS=this.getLS(jslist[k].name);if(!!LS){var version=LS.split(versionString)[0];var code=LS.split(versionString)[1]}else{var version=""}if(version==jslist[k].path){this.jsRunSequence.push({name:jslist[k].name,code:code,path:jslist[k].path})}else{this.jsRunSequence.push({name:jslist[k].name,code:null,path:jslist[k].path,status:"comboloading"});requestingModules[jslist[k].name]=true;updateList+=(updateList==""?"":";")+jslist[k].path}}var that=this;if(!!updateList){var xhr=new XMLHttpRequest;xhr.open("get",combo+updateList,true);xhr.onreadystatechange=function(){if(xhr.readyState==4){if(xhr.status>=200&&xhr.status<300||xhr.status==304){if(xhr.response!=""){that.runCombo(xhr.response,requestingModules);return}}else{for(var i in that.jsRunSequence){if(requestingModules[that.jsRunSequence[i].name]){that.jsRunSequence[i].status="failed"}}that.runjs()}}};xhr.send(null)}this.runjs()};lsloader.runCombo=function(comboCode,requestingModules){comboCode=comboCode.split("/*combojs*/");comboCode.shift();for(var k in this.jsRunSequence){if(!!requestingModules[this.jsRunSequence[k].name]&&!!comboCode[0]){this.jsRunSequence[k].status="comboJS";this.jsRunSequence[k].code=comboCode[0];this.setLS(this.jsRunSequence[k].name,this.jsRunSequence[k].path+versionString+comboCode[0]);comboCode.shift()}}this.runjs()}})();</script>

    <!-- Import queue -->
    <script>function Queue(){this.dataStore=[];this.offer=b;this.poll=d;this.execNext=a;this.debug=false;this.startDebug=c;function b(e){if(this.debug){console.log("Offered a Queued Function.")}if(typeof e==="function"){this.dataStore.push(e)}else{console.log("You must offer a function.")}}function d(){if(this.debug){console.log("Polled a Queued Function.")}return this.dataStore.shift()}function a(){var e=this.poll();if(e!==undefined){if(this.debug){console.log("Run a Queued Function.")}e()}}function c(){this.debug=true}}var queue=new Queue();</script>

    <!-- Favicons -->
    <link rel="icon shortcut" type="image/ico" href="/img/favicon.png">
    <link rel="icon" sizes="192x192" href="/img/favicon.png">
    <link rel="apple-touch-icon" href="/img/favicon.png">

    <!--iOS -->
    <meta name="apple-mobile-web-app-title" content="Title">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="480">

    <!-- Add to homescreen for Chrome on Android -->
    <meta name="mobile-web-app-capable" content="yes">

    <!-- Add to homescreen for Safari on iOS -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="Azurery">

    <!-- Site Verification -->
    
    

    <!-- RSS -->
    

    <!--[if lte IE 9]>
        <link rel="stylesheet" href="/css/ie-blocker.css">

        
            <script src="/js/ie-blocker.zhCN.js"></script>
        
    <![endif]-->

    <!-- Import CSS -->
    
        <style id="material_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("material_css","/css/material.min.css?Z7a72R1E4SxzBKR/WGctOA==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
        <style id="style_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("style_css","/css/style.min.css?MKetZV3cUTfDxvMffaOezg==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>

        
            
                <style id="prettify_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("prettify_css","/css/prettify.min.css?zp8STOU9v89XWFEnN+6YmQ==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
                <style id="prettify_theme"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("prettify_theme","/css/prettify/vibrant-ink.min.css?e5E/qqGcGveS7VTH4M896w==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
            
        

    

    

    <!-- Config CSS -->

<!-- Other Styles -->
<style>
  body, html {
    font-family: Roboto, "Helvetica Neue", Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "微软雅黑", Arial, sans-serif;
    overflow-x: hidden !important;
  }
  
  code {
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
  }

  a {
    color: #00838F;
  }

  .mdl-card__media,
  #search-label,
  #search-form-label:after,
  #scheme-Paradox .hot_tags-count,
  #scheme-Paradox .sidebar_archives-count,
  #scheme-Paradox .sidebar-colored .sidebar-header,
  #scheme-Paradox .sidebar-colored .sidebar-badge{
    background-color: #0097A7 !important;
  }

  /* Sidebar User Drop Down Menu Text Color */
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:hover,
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:focus {
    color: #0097A7 !important;
  }

  #post_entry-right-info,
  .sidebar-colored .sidebar-nav li:hover > a,
  .sidebar-colored .sidebar-nav li:hover > a i,
  .sidebar-colored .sidebar-nav li > a:hover,
  .sidebar-colored .sidebar-nav li > a:hover i,
  .sidebar-colored .sidebar-nav li > a:focus i,
  .sidebar-colored .sidebar-nav > .open > a,
  .sidebar-colored .sidebar-nav > .open > a:hover,
  .sidebar-colored .sidebar-nav > .open > a:focus,
  #ds-reset #ds-ctx .ds-ctx-entry .ds-ctx-head a {
    color: #0097A7 !important;
  }

  .toTop {
    background: #757575 !important;
  }

  .material-layout .material-post>.material-nav,
  .material-layout .material-index>.material-nav,
  .material-nav a {
    color: #757575;
  }

  #scheme-Paradox .MD-burger-layer {
    background-color: #757575;
  }

  #scheme-Paradox #post-toc-trigger-btn {
    color: #757575;
  }

  .post-toc a:hover {
    color: #00838F;
    text-decoration: underline;
  }

</style>


<!-- Theme Background Related-->

    <style>
      body{
        background-image: url(/img/bg.png);
      }
    </style>




<!-- Fade Effect -->

    <style>
      .fade {
        transition: all 800ms linear;
        -webkit-transform: translate3d(0,0,0);
        -moz-transform: translate3d(0,0,0);
        -ms-transform: translate3d(0,0,0);
        -o-transform: translate3d(0,0,0);
        transform: translate3d(0,0,0);
        opacity: 1;
      }

      .fade.out{
        opacity: 0;
      }
    </style>


<!-- Import Font -->
<!-- Import Roboto -->

    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500" rel="stylesheet">


<!-- Import Material Icon -->

    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">




    <!-- Import jQuery -->
    
        <script>lsloader.load("jq_js","/js/jquery.min.js?qcusAULNeBksqffqUM2+Ig==", true)</script>
    

    <!-- The Open Graph protocol -->
    <meta property="og:url" content="http://yoursite.com">
    <meta property="og:type" content="blog">
    <meta property="og:title" content="C++点点滴滴（上） | Azurery">
    <meta property="og:image" content="http://yoursite.com/img/favicon.png" />
    <meta property="og:description" content="蒟蒻一枚">
    <meta property="og:article:tag" content="C++"> 

    
        <meta property="article:published_time" content="Mon Jul 09 2018 17:36:03 GMT+0800" />
        <meta property="article:modified_time" content="Fri Oct 26 2018 11:07:12 GMT+0800" />
    

    <!-- The Twitter Card protocol -->
    <meta name="twitter:title" content="C++点点滴滴（上） | Azurery">
    <meta name="twitter:description" content="蒟蒻一枚">
    <meta name="twitter:image" content="http://yoursite.com/img/favicon.png">
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:url" content="http://yoursite.com" />

    <!-- Add canonical link for SEO -->
    
        <link rel="canonical" href="http://yoursite.com/2018/07/09/C++点点滴滴（上）/index.html" />
    

    <!-- Structured-data for SEO -->
    
        


<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "mainEntityOfPage": "http://yoursite.com/2018/07/09/C++点点滴滴（上）/index.html",
    "headline": "C++点点滴滴（上）",
    "datePublished": "Mon Jul 09 2018 17:36:03 GMT+0800",
    "dateModified": "Fri Oct 26 2018 11:07:12 GMT+0800",
    "author": {
        "@type": "Person",
        "name": "Magicmanoooo",
        "image": {
            "@type": "ImageObject",
            "url": "/img/avatar.png"
        },
        "description": "秘境，探寻你的足迹"
    },
    "publisher": {
        "@type": "Organization",
        "name": "Azurery",
        "logo": {
            "@type":"ImageObject",
            "url": "/img/favicon.png"
        }
    },
    "keywords": ",C++",
    "description": "蒟蒻一枚",
}
</script>


    

    <!-- Analytics -->
    
    
    

    <!-- Custom Head -->
    

</head>


    
        <body id="scheme-Paradox" class="lazy">
            <div class="material-layout  mdl-js-layout has-drawer is-upgraded">
                

                <!-- Main Container -->
                <main class="material-layout__content" id="main">

                    <!-- Top Anchor -->
                    <div id="top"></div>

                    
                        <!-- Hamburger Button -->
                        <button class="MD-burger-icon sidebar-toggle">
                            <span class="MD-burger-layer"></span>
                        </button>
                    

                    <!-- Post TOC -->

    
    <!-- Back Button -->
    <!--
    <div class="material-back" id="backhome-div" tabindex="0">
        <a class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon"
           href="#" onclick="window.history.back();return false;"
           target="_self"
           role="button"
           data-upgraded=",MaterialButton,MaterialRipple">
            <i class="material-icons" role="presentation">arrow_back</i>
            <span class="mdl-button__ripple-container">
                <span class="mdl-ripple"></span>
            </span>
        </a>
    </div>
    -->


    <!-- Left aligned menu below button -->
    
    
    <button id="post-toc-trigger-btn"
        class="mdl-button mdl-js-button mdl-button--icon">
        <i class="material-icons">format_list_numbered</i>
    </button>

    <ul class="post-toc-wrap mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect" for="post-toc-trigger-btn" style="max-height:80vh; overflow-y:scroll;">
        <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#operator-priority"><span class="post-toc-number">1.</span> <span class="post-toc-text">operator priority</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Bool类型"><span class="post-toc-number">2.</span> <span class="post-toc-text">_Bool类型</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#arithmetic-types（算数类型）"><span class="post-toc-number">3.</span> <span class="post-toc-text">arithmetic types（算数类型）</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#C语言中的types"><span class="post-toc-number">4.</span> <span class="post-toc-text">C语言中的types</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#type-groups（类型分组）"><span class="post-toc-number">5.</span> <span class="post-toc-text">type groups（类型分组）</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#raw-sting-literal"><span class="post-toc-number">6.</span> <span class="post-toc-text">raw sting literal</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#nullptr-t"><span class="post-toc-number">7.</span> <span class="post-toc-text">nullptr_t</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#为什么0和NULL可以直接赋给指针"><span class="post-toc-number">8.</span> <span class="post-toc-text">为什么0和NULL可以直接赋给指针</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#intptr-t"><span class="post-toc-number">9.</span> <span class="post-toc-text">intptr_t</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#右值引用"><span class="post-toc-number">10.</span> <span class="post-toc-text">右值引用</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#移动"><span class="post-toc-number">10.0.1.</span> <span class="post-toc-text">移动</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#完美转发"><span class="post-toc-number">10.0.2.</span> <span class="post-toc-text">完美转发</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#sizeof的编译器实现"><span class="post-toc-number">11.</span> <span class="post-toc-text">sizeof的编译器实现</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Implementing-class-template-member-functions"><span class="post-toc-number">12.</span> <span class="post-toc-text">Implementing class template member functions</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#pragma-once"><span class="post-toc-number">13.</span> <span class="post-toc-text">pragma once</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#大端和小端问题"><span class="post-toc-number">14.</span> <span class="post-toc-text">大端和小端问题</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#空类对象占一个字节的原因"><span class="post-toc-number">15.</span> <span class="post-toc-text">空类对象占一个字节的原因</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#typeid"><span class="post-toc-number">16.</span> <span class="post-toc-text">typeid</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#static-cast与reinterpret-cast的区别"><span class="post-toc-number">17.</span> <span class="post-toc-text">static_cast与reinterpret_cast的区别</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#POD"><span class="post-toc-number">18.</span> <span class="post-toc-text">POD</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#定义了移动构造函数后，拷贝构造函数默认为删除的"><span class="post-toc-number">19.</span> <span class="post-toc-text">定义了移动构造函数后，拷贝构造函数默认为删除的</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#std-move"><span class="post-toc-number">20.</span> <span class="post-toc-text">std::move</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#char-a-void-20"><span class="post-toc-number">21.</span> <span class="post-toc-text">char*(*(*a)(void))[20];</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#特化和偏特化"><span class="post-toc-number">22.</span> <span class="post-toc-text">特化和偏特化</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#std-declval"><span class="post-toc-number">23.</span> <span class="post-toc-text">std::declval</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#std-void-t"><span class="post-toc-number">24.</span> <span class="post-toc-text">std::void_t</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Detection-Idiom-is-detected"><span class="post-toc-number">25.</span> <span class="post-toc-text">Detection Idiom:is_detected</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#template-template-parameters"><span class="post-toc-number">25.1.</span> <span class="post-toc-text">template template parameters</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#std-tuple"><span class="post-toc-number">26.</span> <span class="post-toc-text">std::tuple</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-make-tuple"><span class="post-toc-number">26.1.</span> <span class="post-toc-text">1. make_tuple</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-tuple-cat"><span class="post-toc-number">26.2.</span> <span class="post-toc-text">2. tuple_cat</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-std-tie"><span class="post-toc-number">26.3.</span> <span class="post-toc-text">3. std::tie</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#tuple-element"><span class="post-toc-number">26.4.</span> <span class="post-toc-text">tuple_element</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#type-traits"><span class="post-toc-number">27.</span> <span class="post-toc-text">type_traits</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#分派"><span class="post-toc-number">27.0.1.</span> <span class="post-toc-text">分派</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#使得某些代码能够通过编译"><span class="post-toc-number">27.0.2.</span> <span class="post-toc-text">使得某些代码能够通过编译</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#std-integral-constant"><span class="post-toc-number">27.1.</span> <span class="post-toc-text">std::integral_constant</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#true-type与false-type"><span class="post-toc-number">27.1.1.</span> <span class="post-toc-text">true_type与false_type</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#std-is-same"><span class="post-toc-number">27.1.2.</span> <span class="post-toc-text">std::is_same</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#std-add-pointer"><span class="post-toc-number">27.1.3.</span> <span class="post-toc-text">std::add_pointer</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#std-is-pointer"><span class="post-toc-number">27.1.4.</span> <span class="post-toc-text">std::is_pointer</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#std-remove-cv"><span class="post-toc-number">27.1.5.</span> <span class="post-toc-text">std::remove_cv</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#std-remove-reference"><span class="post-toc-number">27.1.6.</span> <span class="post-toc-text">std::remove_reference</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#std-is-array"><span class="post-toc-number">27.1.7.</span> <span class="post-toc-text">std::is_array</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#std-rank"><span class="post-toc-number">27.1.8.</span> <span class="post-toc-text">std::rank</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#std-extent"><span class="post-toc-number">27.1.9.</span> <span class="post-toc-text">std::extent</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#remove-extent"><span class="post-toc-number">27.1.10.</span> <span class="post-toc-text">remove_extent</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#is-convertible"><span class="post-toc-number">27.2.</span> <span class="post-toc-text">is_convertible</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#std-conditional"><span class="post-toc-number">27.3.</span> <span class="post-toc-text">std::conditional</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#std-decay"><span class="post-toc-number">28.</span> <span class="post-toc-text">std::decay</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#实现tuple"><span class="post-toc-number">29.</span> <span class="post-toc-text">实现tuple</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#CRTP"><span class="post-toc-number">30.</span> <span class="post-toc-text">CRTP</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-易错点"><span class="post-toc-number">30.1.</span> <span class="post-toc-text">1. 易错点</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#add-functionality"><span class="post-toc-number">30.2.</span> <span class="post-toc-text">add functionality</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#为什么不使用template-non-member-functions而选择CRTP。它们可能如下所示："><span class="post-toc-number">30.2.1.</span> <span class="post-toc-text">为什么不使用template non-member functions而选择CRTP。它们可能如下所示：</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#CRTP中的inheritance与classical-inheritance的区别："><span class="post-toc-number">30.3.</span> <span class="post-toc-text">CRTP中的inheritance与classical inheritance的区别：</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Static-interfaces"><span class="post-toc-number">30.4.</span> <span class="post-toc-text">Static interfaces</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#去除static-cast"><span class="post-toc-number">30.5.</span> <span class="post-toc-text">去除static_cast</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Adding-several-functionalities-with-CRTP"><span class="post-toc-number">30.6.</span> <span class="post-toc-text">Adding several functionalities with CRTP</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#std-enable-shared-from-this"><span class="post-toc-number">30.7.</span> <span class="post-toc-text">std::enable_shared_from_this</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#shared-from-this"><span class="post-toc-number">30.7.1.</span> <span class="post-toc-text">shared_from_this</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Functor"><span class="post-toc-number">31.</span> <span class="post-toc-text">Functor</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#RAII（Resource-Acquisition-Is-Initialization-）"><span class="post-toc-number">32.</span> <span class="post-toc-text">RAII（Resource Acquisition Is Initialization ）</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#static-cast-VS-const-static-VS-dynamic-cast-VS-reinterpret-cast"><span class="post-toc-number">33.</span> <span class="post-toc-text">static_cast VS const_static VS dynamic_cast VS reinterpret_cast</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#static-cast"><span class="post-toc-number">33.1.</span> <span class="post-toc-text">static_cast</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#const-cast"><span class="post-toc-number">33.2.</span> <span class="post-toc-text">const_cast</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#dynamic-cast"><span class="post-toc-number">33.3.</span> <span class="post-toc-text">dynamic_cast</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#copy-and-swap-idiom"><span class="post-toc-number">34.</span> <span class="post-toc-text">copy-and-swap idiom</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-为什么需要copy-and-swap-idiom"><span class="post-toc-number">34.1.</span> <span class="post-toc-text">1. 为什么需要copy-and-swap idiom</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-工作机制"><span class="post-toc-number">34.2.</span> <span class="post-toc-text">2. 工作机制</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-深入理解"><span class="post-toc-number">34.3.</span> <span class="post-toc-text">3. 深入理解</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#正确的做法"><span class="post-toc-number">34.4.</span> <span class="post-toc-text">正确的做法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#工作原理"><span class="post-toc-number">34.5.</span> <span class="post-toc-text">工作原理</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#const与constexpr的区别"><span class="post-toc-number">35.</span> <span class="post-toc-text">const与constexpr的区别</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#迭代器（iterator）"><span class="post-toc-number">36.</span> <span class="post-toc-text">迭代器（iterator）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#插入迭代器（insert-iterator）"><span class="post-toc-number">36.1.</span> <span class="post-toc-text">插入迭代器（insert_iterator）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#移动迭代器（move-iterator）"><span class="post-toc-number">36.2.</span> <span class="post-toc-text">移动迭代器（move_iterator）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#流迭代器（ostream-iterator）"><span class="post-toc-number">36.3.</span> <span class="post-toc-text">流迭代器（ostream_iterator）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#istream-iterator"><span class="post-toc-number">36.3.1.</span> <span class="post-toc-text">istream_iterator</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#ostream-iterator"><span class="post-toc-number">36.3.2.</span> <span class="post-toc-text">ostream_iterator</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#variadic-function"><span class="post-toc-number">37.</span> <span class="post-toc-text">variadic function</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-va-list："><span class="post-toc-number">37.1.</span> <span class="post-toc-text">1. va_list：</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-va-start："><span class="post-toc-number">37.2.</span> <span class="post-toc-text">2. va_start：</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-va-arg"><span class="post-toc-number">37.3.</span> <span class="post-toc-text">4. va_arg</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-va-end"><span class="post-toc-number">37.4.</span> <span class="post-toc-text">4. va_end</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#variadic-template"><span class="post-toc-number">38.</span> <span class="post-toc-text">variadic template</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#通过递归函数来展开参数包"><span class="post-toc-number">38.1.</span> <span class="post-toc-text">通过递归函数来展开参数包</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#逗号表达式展开参数包"><span class="post-toc-number">38.2.</span> <span class="post-toc-text">逗号表达式展开参数包</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#variadic-template-class"><span class="post-toc-number">38.3.</span> <span class="post-toc-text">variadic template class</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#通过继承方式展开参数包"><span class="post-toc-number">38.4.</span> <span class="post-toc-text">通过继承方式展开参数包</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#利用variadic-template去除repeated-code"><span class="post-toc-number">38.5.</span> <span class="post-toc-text">利用variadic template去除repeated code</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#利用variadic-template实现C-中的delegate"><span class="post-toc-number">38.6.</span> <span class="post-toc-text">利用variadic template实现C#中的delegate</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#如何打印variadic-template-parameter"><span class="post-toc-number">39.</span> <span class="post-toc-text">如何打印variadic template parameter</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#方法一"><span class="post-toc-number">39.1.</span> <span class="post-toc-text">方法一</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#方法二"><span class="post-toc-number">39.2.</span> <span class="post-toc-text">方法二</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#方法三"><span class="post-toc-number">39.3.</span> <span class="post-toc-text">方法三</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#方法四"><span class="post-toc-number">39.4.</span> <span class="post-toc-text">方法四</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#方法五"><span class="post-toc-number">39.5.</span> <span class="post-toc-text">方法五</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#方法六"><span class="post-toc-number">39.6.</span> <span class="post-toc-text">方法六</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#variadic-template的应用"><span class="post-toc-number">40.</span> <span class="post-toc-text">variadic template的应用</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#在compile-time获取一个integer-sequence中的最大值"><span class="post-toc-number">40.1.</span> <span class="post-toc-text">在compile-time获取一个integer sequence中的最大值</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#获取众多类型中的size的最大值"><span class="post-toc-number">40.2.</span> <span class="post-toc-text">获取众多类型中的size的最大值</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#std-alignment-of"><span class="post-toc-number">40.2.1.</span> <span class="post-toc-text">std::alignment_of</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#判断是否包含某个类型"><span class="post-toc-number">40.3.</span> <span class="post-toc-text">判断是否包含某个类型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#获取类型的索引"><span class="post-toc-number">40.4.</span> <span class="post-toc-text">获取类型的索引</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#在编译器遍历类型"><span class="post-toc-number">40.5.</span> <span class="post-toc-text">在编译器遍历类型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#function-traits"><span class="post-toc-number">40.6.</span> <span class="post-toc-text">function traits</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#根据索引查找类型"><span class="post-toc-number">40.7.</span> <span class="post-toc-text">根据索引查找类型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#实现variant"><span class="post-toc-number">40.8.</span> <span class="post-toc-text">实现variant</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#std-type-index"><span class="post-toc-number">40.9.</span> <span class="post-toc-text">std::type_index</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#std-type-index与std-type-info的区别"><span class="post-toc-number">40.9.1.</span> <span class="post-toc-text">std::type_index与std::type_info的区别</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#std-aligned-storage"><span class="post-toc-number">40.9.2.</span> <span class="post-toc-text">std::aligned_storage</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#std-forward-lt-Args-gt-or-std-forward-lt-Args-gt"><span class="post-toc-number">40.9.3.</span> <span class="post-toc-text">std::forward&lt;Args&gt; or std::forward&lt;Args...&gt;</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#alignas"><span class="post-toc-number">40.9.4.</span> <span class="post-toc-text">alignas</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#alignof-VS-alignas"><span class="post-toc-number">40.9.5.</span> <span class="post-toc-text">alignof VS alignas</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#利用using代替typedef声明function-pointer"><span class="post-toc-number">41.</span> <span class="post-toc-text">利用using代替typedef声明function pointer</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#根据元素类型获取tuple中的元素"><span class="post-toc-number">41.1.</span> <span class="post-toc-text">根据元素类型获取tuple中的元素</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#问题一："><span class="post-toc-number">42.</span> <span class="post-toc-text">问题一：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#问题二："><span class="post-toc-number">43.</span> <span class="post-toc-text">问题二：</span></a></li></ol>
    </ul>
    




<!-- Layouts -->

    <!-- Post Module -->
    <div class="material-post_container">

        <div class="material-post mdl-grid">
            <div class="mdl-card mdl-shadow--4dp mdl-cell mdl-cell--12-col">

                <!-- Post Header(Thumbnail & Title) -->
                
    <!-- Paradox Post Header -->
    
        
            <!-- Random Thumbnail -->
            <div class="post_thumbnail-random mdl-card__media mdl-color-text--grey-50">
            <script type="text/ls-javascript" id="post-thumbnail-script">
    var randomNum = Math.floor(Math.random() * 19 + 1);

    $('.post_thumbnail-random').attr('data-original', '/img/random/material-' + randomNum + '.png');
    $('.post_thumbnail-random').addClass('lazy');
</script>

        
    
            <p class="article-headline-p">
                C++点点滴滴（上）
            </p>
        </div>





                
                    <!-- Paradox Post Info -->
                    <div class="mdl-color-text--grey-700 mdl-card__supporting-text meta">

    <!-- Author Avatar -->
    <div id="author-avatar">
        <img src="/img/avatar.png" width="44px" height="44px" alt="Author Avatar"/>
    </div>
    <!-- Author Name & Date -->
    <div>
        <strong>Magicmanoooo</strong>
        <span>7月 09, 2018</span>
    </div>

    <div class="section-spacer"></div>

    <!-- Favorite -->
    <!--
        <button id="article-functions-like-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon btn-like">
            <i class="material-icons" role="presentation">favorite</i>
            <span class="visuallyhidden">favorites</span>
        </button>
    -->

    <!-- Qrcode -->
    
        <button id="article-functions-qrcode-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
    <i class="material-icons" role="presentation">devices other</i>
    <span class="visuallyhidden">devices other</span>
</button>
<ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-functions-qrcode-button">
    <li class="mdl-menu__item">在其它设备中阅读本文章</li>
    
        <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPYAAAD2CAAAAADAeSUUAAACzklEQVR42u3aQXLCMBAEQP7/afKABDOjhYpLap8oMLLal63d0eN55PXAxsbGxsbGxsbGviX7EV+/7/9j6Re/vrr/5RYvV2j3jI2NjX0CO99Ewm5Xbl9Tu2dsbGzsc9jXRSspMNcFLy9++dOLf2FjY2Njvyg510Xompo0RXlBxcbGxsbOl0jaifz+yYgKGxsbG3ttQNM2EknkkL/Kf5ilYWNjY9+e3Qa9d/j8D/k2NjY29i3Z7ZWUqMkKk9j4zXOxsbGxN2Xno//kzrWWpmXnYyZsbGzsE9ht1NoO9z8VRbRtSVG3sbGxsTdiT8ZMa8OgtpS2a2JjY2Ofxm4LWBvZThh5DICNjY19JnvSeCSA9iDO2n7qoBcbGxt7I/ZacZo0EtEYqCxmb0Za2NjY2Aewk3ZiMn7KR0t565If8cHGxsbelT1pLdrtTgphHidHQyVsbGzsTdmfCmXbza21PfUesLGxsTdl5+1HW3jWQog2JChaIGxsbOxN2Tk4/74tUWuwOiTGxsbG3pQ9D3onIW4bGOSvJmpFsLGxsbdgJ9S1EX8e2eZPz3cS1W1sbGzs7djtCD4pIWvrt0OuJO7FxsbG3pvdfk4KySRgmBweKgoYNjY29hbstQe3rcJaM5OHwdGa2NjY2Mew80H8M7jmrzJfvz6phI2Njb0Ru20t2s3lLzo/oFP/CxsbG/sAdhvBfqO8rY2NoqNF2NjY2Juy15qBvGmZvKZ2J8VQCRsbG3sjdl5O1r5fO2o5v7CxsbHPZK+N49siN1mtjYSxsbGxT2C3JaH9vh0DtUdzRh0YNjY29kbsedHKB0mfHRgVhQ0bGxv7AHZSPCb4bwyksLGxsbHnbUCyWlsaJxEyNjY2NvZnD9zkbc9aVFAc9MTGxsY+gN2GrJOX1Ya1eZuEjY2NfSa7DXq/UaLWooU8eMDGxsbelX3OhY2NjY2NjY2NjX2b6we3pPeqqt73AAAAAABJRU5ErkJggg==">
    
</ul>

    

    <!-- Tags (bookmark) -->
    
    <button id="article-functions-viewtags-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
        <i class="material-icons" role="presentation">bookmark</i>
        <span class="visuallyhidden">bookmark</span>
    </button>
    <ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-functions-viewtags-button">
        <li class="mdl-menu__item">
        <a class="post_tag-link" href="/tags/C/">C++</a>
    </ul>
    

    <!-- Share -->
    <button id="article-fuctions-share-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
    <i class="material-icons" role="presentation">share</i>
    <span class="visuallyhidden">share</span>
</button>
<ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-fuctions-share-button">
    

    

    <!-- Share Weibo -->
    
        <a class="post_share-link" href="http://service.weibo.com/share/share.php?appkey=&title=C++点点滴滴（上）&url=http://yoursite.com/2018/07/09/C++点点滴滴（上）/index.html&pic=http://yoursite.com/img/favicon.png&searchPic=false&style=simple" target="_blank">
            <li class="mdl-menu__item">
                分享到微博
            </li>
        </a>
    

    <!-- Share Twitter -->
    
        <a class="post_share-link" href="https://twitter.com/intent/tweet?text=C++点点滴滴（上）&url=http://yoursite.com/2018/07/09/C++点点滴滴（上）/index.html&via=Magicmanoooo" target="_blank">
            <li class="mdl-menu__item">
                分享到 Twitter
            </li>
        </a>
    

    <!-- Share Facebook -->
    
        <a class="post_share-link" href="https://www.facebook.com/sharer/sharer.php?u=http://yoursite.com/2018/07/09/C++点点滴滴（上）/index.html" target="_blank">
            <li class="mdl-menu__item">
                分享到 Facebook
            </li>
        </a>
    

    <!-- Share Google+ -->
    
        <a class="post_share-link" href="https://plus.google.com/share?url=http://yoursite.com/2018/07/09/C++点点滴滴（上）/index.html" target="_blank">
            <li class="mdl-menu__item">
                分享到 Google+
            </li>
        </a>
    

    <!-- Share LinkedIn -->
    

    <!-- Share QQ -->
    
        <a class="post_share-link" href="http://connect.qq.com/widget/shareqq/index.html?site=Azurery&title=C++点点滴滴（上）&summary=蒟蒻一枚&pics=http://yoursite.com/img/favicon.png&url=http://yoursite.com/2018/07/09/C++点点滴滴（上）/index.html" target="_blank">
            <li class="mdl-menu__item">
                分享到 QQ
            </li>
        </a>
    

    <!-- Share Telegram -->
    
</ul>

</div>

                

                <!-- Post Content -->
                <div id="post-content" class="mdl-color-text--grey-700 mdl-card__supporting-text fade out">
    
        <h2 id="operator-priority"><a href="#operator-priority" class="headerlink" title="operator priority"></a>operator priority</h2><p><img src="https://upload-images.jianshu.io/upload_images/1351548-7366cf241b9ff19a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="Bool类型"><a href="#Bool类型" class="headerlink" title="_Bool类型"></a><code>_Bool</code>类型</h2><p>C99开始引入，其定义在头文件中。其有两个值：0代表false和1代表true.<br><strong>【注意】：</strong><code>_Bool</code>类型的转换与其他integer类型的转换不同。</p>
<p>例如：<code>(bool)0.5</code>的值为<code>1</code>，而<code>(int)0.5</code>的值为<code>0</code>。</p>
<p>在gcc中，这个头文件的源码如下：</p>
<pre><code class="cpp">/* Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.
 */
#ifndef _STDBOOL_H
#define _STDBOOL_H
#ifndef __cplusplus
#define bool    _Bool
#define true    1
#define false    0
#else
/* __cplusplus ，应用于C++里，这里不用处理它*/
/* Supporting &lt;stdbool.h&gt; in C++ is a GCC extension.  */
#define _Bool    bool
#definebool    bool
#define false    false
#define true    true
#endif
/* __cplusplus */
/* Signal that all the definitions are present.  */
#define __bool_true_false_are_defined    1
#endif
/* stdbool.h */
</code></pre>
<p>可见，中定义了4个宏，<code>bool</code>、<code>true</code>、<code>false</code>、<code>__bool_true_false_are_defined</code>。 其中<code>bool</code>就是 <code>_Bool</code>类型，<code>true</code>和<code>false</code>的值为<code>1</code>和<code>0</code>，<code>__bool_true_false_are_defined</code>的值为<code>1</code>。</p>
<h2 id="arithmetic-types（算数类型）"><a href="#arithmetic-types（算数类型）" class="headerlink" title="arithmetic types（算数类型）"></a>arithmetic types（算数类型）</h2><ul>
<li><strong>Boolean type（布尔类型）</strong></li>
<li><strong>Character types（字符类型）</strong><ul>
<li><code>signed char</code></li>
<li><code>unsigned char</code></li>
<li><code>char</code> （注意：char不同于signed char和unsigned char）<br><strong>【注意】：</strong>在标注库中还定义了宽字符的typedef name：<code>wchar_t</code>、<code>char16_t</code>与<code>char32_t</code>。</li>
</ul>
</li>
<li><strong>Integer types（整数类型）</strong><ul>
<li><code>short int</code></li>
<li><code>unsigned short int</code></li>
<li><code>int</code></li>
<li><code>unsigned int</code></li>
<li><code>long int</code></li>
<li><code>unsigned long int</code></li>
<li><code>long long int</code></li>
<li><code>unsigned long long int</code></li>
</ul>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/1351548-2128e4102813ce2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<ul>
<li><strong>Real floating types（浮点数）</strong><ul>
<li><code>float</code></li>
<li><code>double</code></li>
<li><code>long double</code></li>
</ul>
</li>
</ul>
<h2 id="C语言中的types"><a href="#C语言中的types" class="headerlink" title="C语言中的types"></a>C语言中的types</h2><ul>
<li><strong>void</strong></li>
<li><strong>basic type（基本类型）</strong><ul>
<li>char</li>
<li>signed integer types（有符号整形）<ol>
<li>standard（标准型）<ul>
<li><code>signed char</code></li>
<li><code>short</code></li>
<li><code>int</code></li>
<li><code>long</code></li>
<li><code>long long</code>（since C99）</li>
</ul>
</li>
<li>extended（扩展型）<ul>
<li><code>implement—defined</code>（由编译器实现），例如<code>_int128</code>。</li>
</ul>
</li>
</ol>
</li>
<li>unsigned integer types（无符号整形）<ol>
<li>standard（标准型）<ul>
<li><code>_Bool</code></li>
<li><code>unsigned char</code></li>
<li><code>unsigned short</code></li>
<li><code>unsigned int</code></li>
<li><code>unsigned long</code></li>
<li><code>unsigned long long</code></li>
</ul>
</li>
<li>extended（扩展型）<ul>
<li><code>implement—defined</code>（由编译器实现），例如<code>_int128</code>。</li>
</ul>
</li>
</ol>
</li>
<li>floating types（浮点类型）<ul>
<li>real floating types<ul>
<li><code>float</code></li>
<li><code>double</code></li>
<li><code>long double</code></li>
</ul>
</li>
<li>complex types and imaginary types</li>
</ul>
</li>
</ul>
</li>
<li><strong>enumerated types（枚举类型）</strong></li>
<li><strong>derived types（派生类型）</strong><ul>
<li>array types</li>
<li>structure types</li>
<li>union types</li>
<li>function types</li>
<li>pointer types</li>
<li>atomic types</li>
</ul>
</li>
</ul>
<h2 id="type-groups（类型分组）"><a href="#type-groups（类型分组）" class="headerlink" title="type groups（类型分组）"></a>type groups（类型分组）</h2><ul>
<li><strong>object types（对象类型）：</strong>除了function types以外的所有类型</li>
<li><strong>character types</strong><ul>
<li><code>char</code></li>
<li><code>signed char</code></li>
<li><code>unsigned char</code></li>
</ul>
</li>
<li><strong>integer types</strong><ul>
<li><code>char</code></li>
<li><code>signed integer types</code></li>
<li><code>unsigned integer types</code></li>
<li><code>enumerated types</code></li>
</ul>
</li>
<li><strong>real types</strong><ul>
<li>integer types</li>
<li>real floating types</li>
</ul>
</li>
<li><strong>arithmetic types</strong><ul>
<li>integer types</li>
<li>floating types</li>
</ul>
</li>
<li><strong>scalar types（标量类型）</strong><ul>
<li>arithmetic types</li>
<li>pointer types</li>
</ul>
</li>
<li><strong>aggregate types（聚合类型）</strong><ul>
<li>array types</li>
<li>structure type（union和struct)</li>
</ul>
</li>
<li><strong>derived types</strong><ul>
<li>array types</li>
<li>function types</li>
<li>pointer</li>
</ul>
</li>
</ul>
<h2 id="raw-sting-literal"><a href="#raw-sting-literal" class="headerlink" title="raw sting literal"></a>raw sting literal</h2><p>这是一种比较特殊的string，它的用途是：在使用的过程中，可以忽略转义字符（escape character,例如<code>\n</code>,<code>\t</code>,<code>\&quot;</code>），即将转义字符当做普通的字符进行处理。其语法为：<code>R&quot;(xxxx)&quot;;</code>。</p>
<p>例子：</p>
<pre><code class="cpp">std::string normal_string = &quot;I&#39;m a normal string.\nI&#39;m also a normal string\n&quot;;
std::string raw_string = R&quot;(I&#39;m a raw string.\nI&#39;m also a raw string\n)&quot;;
</code></pre>
<p>输出结果为：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1351548-297fa63358c0108d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="nullptr-t"><a href="#nullptr-t" class="headerlink" title="nullptr_t"></a><code>nullptr_t</code></h2><p>起定义在<code>&lt;stddef&gt;</code>：<br><code>typedef deltype(nullptr) nullptr_t;</code><br>表示的是null pointer literal(空指针字面值常量）<code>nullptr</code>的类型，它既不是指针类型，也不是指向成员的指针类型。</p>
<p>即：<code>nullptr</code>是constant，而<code>nullptr_t</code>是<code>nullptr</code>的类型。</p>
<p><code>nullptr</code>是<code>std::nullptr_t</code>类型的一个pointer literal，而且它是一个prvalue（即不能利用<code>&amp;</code>对其进行取地址）。</p>
<ul>
<li>一个<code>std::nullptr_t</code>类型的prvalue是一个null pointer constant，这种这种integral null pointer constant能够被转换为<code>std::nullptr_t</code>，而反向转换则不允许。这允许为pointers和integers重载函数，并且通过传递<code>nullptr</code>来进行选择pointer version。而传入<code>NULL</code>或者<code>0</code>则会令人困惑地选择<code>int</code>版本。</li>
<li>将<code>nullptr_t</code>强制转换为ingeral type需要使用<code>reinterpret_cast</code>，其作用等同于<code>(void*)0</code>强制转换为integral type。<code>reinterpret_cast</code>不能将<code>nullptr_t</code>转换为任何pointer type。如果可能，应使用隐式转换或者<code>static_cast</code>。</li>
<li>标准规定：<code>sizeof(nullptr_t)</code>等同于<code>sizeof(void*)</code>。</li>
</ul>
<p><strong>【注】：</strong><br>尽管<code>NULL</code>的定义<code>#define NULL 0;</code>，但其并不保证其值就是<code>0</code>，也可以是<code>0L</code>，在进行调用<code>void f(int); void f(char *);</code>中将会产生歧义，而使用<code>nullpter</code>则只会选择pointer version（从不会选择<code>int</code>这一重载）。此外，<code>nullpter</code>还可以转换为<code>bool</code>。</p>
<p><code>nullptr</code>的简单实现：</p>
<pre><code class="cpp">const class nullptr_t {
public:
    template&lt;class T&gt;
    inline operator T*() const { 
        return 0; 
    }

    template&lt;class C, class T&gt;
    inline operator T C::*() const { 
        return 0; 
    }
private:
    void operator&amp;() const;
} nullptr = {};
</code></pre>
<p><a href="https://www.zhihu.com/question/67751356" target="_blank" rel="noopener">nullptr底层实现原理</a></p>
<h2 id="为什么0和NULL可以直接赋给指针"><a href="#为什么0和NULL可以直接赋给指针" class="headerlink" title="为什么0和NULL可以直接赋给指针"></a>为什么<code>0</code>和<code>NULL</code>可以直接赋给指针</h2><pre><code class="cpp">#if !defined(NULL) &amp;&amp; defined(__NEEDS_NULL)
#ifdef __cplusplus
#define NULL 0
#else
#define NULL ((void *)0)
#endif
#endif
</code></pre>
<blockquote>
<p>因为<code>0</code>是 null pointer constant ，<code>NULL</code>宏也会定义为一个 null pointer constant ， null pointer constant 可以用来给指针初始化和赋值是标准钦点的，结果是指针的值变为 null pointer value 【这并不代表值变为0！】，注意C++中<code>0</code>只有作为整数字面量的时候才是 null pointer constant，C的要求可能和C++不完全相同。</p>
</blockquote>
<h2 id="intptr-t"><a href="#intptr-t" class="headerlink" title="intptr_t"></a><code>intptr_t</code></h2><p>C99引入，使用int时，可以使用其来保证平台的通用性。它在不同的平台上编译时长度不同,integer type capable of holding a pointer。<br>其定义为：</p>
<pre><code class="cpp">#if  _WORDSIZE==64
  typedef long int intptr_t
#else
  typedef int intptr_t
#endif
</code></pre>
<p>使用<code>inptr_t</code>的场景：</p>
<ul>
<li>对<code>void*</code>不能进行bitwise operation，但可以对<code>intptr_t</code>进行。</li>
<li>在需要对一个地址进行bitwise operation的场景下，可以使用<code>intptr_t</code>。</li>
</ul>
<p><strong>【注】：</strong>但对于bitwise operation，最好还是使用<code>unsigned</code>版本的<code>uintptr_t</code>。</p>
<p>将<code>intptr_t</code>替代<code>void*</code>作为）通用存储（用于存储指针和整数值）并不是一个好主意。因为<code>intptr_t</code>不保证存在，即：首先，它是在C99才引入的。其次，并不需要足够大的整数类型来保证转换之后的指针值并且不会丢失信息。</p>
<p>将<code>int</code>转换为<code>intptr_t</code>不太可能丢失精度，但实际上并没有任何保证说明<code>intptr_t</code>比<code>int</code>更宽。如果要存储指针值，请将它们存储在指针对象中。任何只想对象 或者不完整对象的指针都可转换为<code>void*</code>，并且在返回时不会丢失信息。然而对于指向函数的指针却没有这样的保证（但任何指向函数的指针都可以转换为任意的指向函数类型的指针且不丢失信息）。</p>
<h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p><a href="https://www.zhihu.com/question/22111546/answer/30801982" target="_blank" rel="noopener">右值引用的解释</a></p>
<p><code>std::move</code>与<code>std::forward</code>的差别：<br><code>std::move</code>是无条件的转为右值引用，而<code>std::forward</code>是有条件的转为右值引用，更准确的说叫做Perfect forwarding（完美转发），而<code>std::forward里</code>面蕴含着的条件则是Reference Collapsing（引用折叠）。</p>
<pre><code class="cpp">template &lt;typename T&gt;
typename remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; arg) {
  return static_cast&lt;typename remove_reference&lt;T&gt;::type&amp;&amp;&gt;(arg);
}
</code></pre>
<p><strong>【注】</strong><br><code>std::move</code>只是将参数转换为引用而已，它从来不会移动什么。真正的移动操作是在移动构造函数或者移动赋值操作符中发生的：</p>
<pre><code class="cpp">T (T&amp;&amp; rhs);
T&amp; operator= (T&amp;&amp;rhs);
</code></pre>
<p><code>std::move</code>的作用：<strong>只是为了让调用构造函数的时候告诉编译器去选择移动构造函数</strong>。</p>
<h4 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h4><p>让编译器可以把费事的拷贝操作变成开销很小的移动操作。如果你有一个对象，需要移动到另一个对象，但是类中的数据都是不变的且源对象将不会再使用，那么为什么不直接让目标使用源的子数据的内存而要拷贝一份呢？移动语义就是提供了这种操作的语法，就像拷贝构造函数和拷贝赋值操作符让你能够拷贝对象一样，移动构造函数和移动赋值操作符让你能够移动一个对象。利用移动机制你还可以创造只能移动不能拷贝的类,比如<code>std::unique_ptr</code>。</p>
<h4 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h4><p>允许你在函数模板中，接受不确定的参数，然后将它们转发给其他函数。完美转发保证在转发的过程中传递的参数的类型和传入时候是完全相同的。</p>
<p><code>std::move</code>和<code>std::forward</code>仅仅是执行类型转换的函数而已。<code>std::move</code>无条件地将参数转换为右值引用，而<code>std::forward</code>仅当满足一定条件的时候将参数转换为右值引用。</p>
<p><strong>转发：</strong>某些函数需要将其中一个或多个参数连同类型不变地转发给其他函数，在这种情况下，需要保持被转发实参的所有性质，包括实参类型是否为<code>const</code>的以及实参是左值还是右值。</p>
<p>现编写一个函数，它接受一个可调用表达式和两个额外的参数。我们的函数将调用给定的可调用对象，将两个额外参数逆序传递给它。</p>
<pre><code class="cpp">//接受一个可调用对象和另外两个参数模板
//对“翻转”的参数调用给定的可调用对象
//flip1是一个不完整的实现：top-level const和引用丢失了
template &lt;typename F, typename T1, typename T2&gt;
void flip1(F f, T1 t1, T2 t2) {
    f(t2, t1);
}
</code></pre>
<p>这个函数在一般情况下可以完美运行，但当我们希望用它调用一个接受引用参数的函数就会出现问题：</p>
<pre><code class="cpp">void f(int v1, int&amp; v2) {
 std::cout&lt;&lt;v1&lt;&lt;&quot; &quot;&lt;&lt;++v2&lt;&lt;std::endl;
}
</code></pre>
<p>在这段代码找中，<code>f</code>改变了绑定到<code>v2</code>的实参的值。但是，如果我们通过flip1调用<code>f</code>，<code>f</code>所做的改变就不会影响实现：</p>
<pre><code class="cpp">f(42, i);
flip1(f, j, 42);
</code></pre>
<p>问题在于<code>j</code>被传递给flip1的参数<code>t1</code>。此参数是一个普通的、非引用的类型<code>int</code>，而非<code>int&amp;</code>。因此，这个flip1会被实例化为：<br><code>void flip1(void(*fcn)(int, int&amp;), int t1, int t2);</code><br><code>j</code>的值被拷贝到<code>t1</code>中。<code>f</code>中的引用参数被绑定到<code>t1</code>，而非<code>j</code>，从而其改变不会影响<code>j</code>。</p>
<p>为了通过翻转函数传递一个引用，需要重写函数，使其参数能够保持给定实参的“左值性”。此外，还希望保持参数的<code>const</code>属性。通过将一个函数参数定义为一个指向末班类型参数的右值引用，可以保持其对应实参的所有类型信息。而使用引用参数（无论左值还是右值）可以保持<code>const</code>属性，因为在引用类型中的是low-level const。如果将函数参数定义为<code>T1&amp;&amp;</code>和<code>T2&amp;&amp;</code>，通过引用折叠，便可以保持翻转实参的左值/右值属性。</p>
<pre><code class="cpp">template &lt;typename F, typename T1, typename T2&gt;
void flip2( F f, T1&amp;&amp; t1, T2&amp;&amp; t2){
    f(t2,t1);
}
</code></pre>
<p>与之前的版本一样，如果调用<code>flip2(f,j,42)</code>，将传递给参数<code>t1</code>一个左值<code>j</code>。但是，在flip2中，推断出<code>T1</code>的类型是<code>int&amp;</code>，这意味着<code>t1</code>的类型会折叠为<code>int&amp;</code>。由于是引用类型，<code>t1</code>被绑定到<code>j</code>上。当flip2调用<code>f</code>时，<code>f</code>中的引用参数<code>v2</code>被绑定到<code>t1</code>，也就是被绑定到<code>j</code>。当<code>f</code>递增到<code>v2</code>时，它也同时改变了<code>j</code>的值。但这个版本的flip2解决了一般的结果。虽然它对于一个接受左值引用的函数可以很好地工作，但不能用于接受右值引用参数的函数。例如：</p>
<pre><code class="cpp">void f(int&amp;&amp; i, int&amp; j) {
    std::cout&lt;&lt; i &lt;&lt;&quot; &quot;&lt;&lt;j &lt;&lt;std::endl;
}
</code></pre>
<p>如果试图通过flip2调用<code>g</code>，则参数<code>t2</code>将被传递给<code>g</code>的右值引用参数。即使传递一个右值flip2：</p>
<pre><code class="cpp">flip2(g,i,42);  //错误，不能从一个左值实例化int&amp;&amp;
</code></pre>
<p>传递给<code>g</code>的将是flip2中名为<code>t2</code>的参数。函数参数与其他任何变量一样，都是左值表达式。因此，flip2中对<code>g</code>的调用将传递给<code>g</code>的右值引用参数一个左值。</p>
<p>此时，可以使用forward再次重写翻转函数：</p>
<pre><code class="cpp">template &lt;typename F, typename T1, typename T2&gt;
void flip(F f, T1&amp;&amp; t1, T2&amp;&amp; t2) {
    f(std::forward&lt;T2&gt;(t2), std::forward&lt;T1&gt;(t2));
}
</code></pre>
<p><strong>【注】：</strong>如果一个函数参数是指向模板类型参数的右值引用，它对应的实参的<code>const</code>属性和左值/右值属性将得到保持。当用于一个指向模板参数类型的右值引用函数参数时，forward会保持实参类型的所有细节。<strong><code>std::move</code>只影响调用函数的选择，它本身不需要任何生成机器码</strong>。</p>
<h2 id="sizeof的编译器实现"><a href="#sizeof的编译器实现" class="headerlink" title="sizeof的编译器实现"></a><code>sizeof</code>的编译器实现</h2><p><code>sizeof</code>运算符中的内容会被编译器直接替换，即使是汇编代码也只能看到一个constant。Clang中<code>sizeof</code>的处理大致为以下。</p>
<p><a href="https://code.woboq.org/llvm/clang/lib/AST/ExprConstant.cpp.html#_ZN12_GLOBAL__N_116IntExprEvaluator29VisitUnaryExprOrTypeTraitExprEPKN5clang24UnaryExprOrTypeTraitExprE" target="_blank" rel="noopener">Clang的实现在<code>lib/AST/ExprConstant.cpp</code></a><br><code>VisitUnaryExprOrTypeTraitExpr</code>这个方法的主要作用是对<code>sizeof</code>、<code>alignof</code>或者<code>vec_step</code>进行求值，返回表达式的类型。</p>
<pre><code class="cpp">bool IntExprEvaluator::VisitUnaryExprOrTypeTraitExpr(
                                    const UnaryExprOrTypeTraitExpr *E) {
  switch(E-&gt;getKind()) {
  ... //other impl
  case UETT_SizeOf: {
    QualType SrcTy = E-&gt;getTypeOfArgument();
    // C++ [expr.sizeof]p2: &quot;When applied to a reference or a reference type,
    //   the result is the size of the referenced type.&quot;
    if (const ReferenceType *Ref = SrcTy-&gt;getAs&lt;ReferenceType&gt;())
      SrcTy = Ref-&gt;getPointeeType();
    CharUnits Sizeof;
    if (!HandleSizeof(Info, E-&gt;getExprLoc(), SrcTy, Sizeof))
      return false;
    return Success(Sizeof, E);
  }
  ...  //other impl
  llvm_unreachable(&quot;unknown expr/type trait&quot;);
}
</code></pre>
<p>其中的主要方法是<code>HandleSizeof</code>，结果会存放在结构为<code>CharUnits</code>的<code>Sizeof</code>之中，而<code>CharUnits</code>为Clang内部的一个数据结构，其定义为：</p>
<blockquote>
<p>/// CharUnits - This is an opaque type for sizes expressed in character units.<br>  /// Instances of this type represent a quantity as a multiple of the size<br>  /// of the standard C type, char, on the target architecture. As an opaque<br>  /// type, CharUnits protects you from accidentally combining operations on<br>  /// quantities in bit units and character units.<br>  ///<br>  /// In both C and C++, an object of type ‘char’, ‘signed char’, or ‘unsigned<br>  /// char’ occupies exactly one byte, so ‘character unit’ and ‘byte’ refer to<br>  /// the same quantity of storage. However, we use the term ‘character unit’<br>  /// rather than ‘byte’ to avoid an implication that a character unit is<br>  /// exactly 8 bits.<br>  ///<br>  /// For portability, never assume that a target character is 8 bits wide. Use<br>  /// CharUnit values wherever you calculate sizes, offsets, or alignments<br>  /// in character units.</p>
</blockquote>
<p><code>HandleSizeof</code>方法主要用于以char units为单位，获取给定类型的size。</p>
<pre><code class="cpp">static bool HandleSizeof(EvalInfo &amp;Info, SourceLocation Loc,
                         QualType Type, CharUnits &amp;Size) {
  // sizeof(void), __alignof__(void), sizeof(function) = 1 as a gcc extension.
  if (Type-&gt;isVoidType() || Type-&gt;isFunctionType()) {
    Size = CharUnits::One();
    return true;
  }
  if (Type-&gt;isDependentType()) {
    Info.FFDiag(Loc);
    return false;
  }
  if (!Type-&gt;isConstantSizeType()) {
    // sizeof(vla) is not a constantexpr: C99 6.5.3.4p2.
    // FIXME: Better diagnostic.
    Info.FFDiag(Loc);
    return false;
  }
  Size = Info.Ctx.getTypeSizeInChars(Type);
  return true;
}
</code></pre>
<p>在上述代码中，可以得知为什么<code>sizeof</code>中的内容会被替代：如果给定的类型为<code>void</code>或者function type，则编译器会直接将其替换为<code>CharUnits::One()</code>常量（即一个<code>char</code>的大小），所以在进行汇编的时候只能看见常量（汇编属于code generation的工作，而这里的代码发生在code generation之前）。此外，还需要判断<code>Type</code>是否为<code>isConstantSizeType</code>，因为需要在编译器计算出来。最后将<code>Type</code>传递给<code>getTypeSizeInChars</code>方法。</p>
<p><code>getTypeSizeInChars</code>方法主要用以返回specified type的大小，这个方法对于imcomplete type不起作用。</p>
<pre><code class="cpp">CharUnits ASTContext::getTypeSizeInChars(const Type *T) const {
  return getTypeInfoInChars(T).first;
}
</code></pre>
<p>对于<code>getTypeInfoInChars</code>方法，</p>
<pre><code class="cpp">std::pair&lt;CharUnits, CharUnits&gt;
ASTContext::getTypeInfoInChars(QualType T) const {
  return getTypeInfoInChars(T.getTypePtr());
}
</code></pre>
<p>由于这个方法返回一个<code>std::pair</code>，所以在前面的调用中会有有<code>first</code>这个东西。但发现这个方法调用的还是<code>getTypeInfoInChars</code>，但参数是一个<code>TypePointer</code>，重载方法为：</p>
<pre><code class="cpp">std::pair&lt;CharUnits, CharUnits&gt;
ASTContext::getTypeInfoInChars(const Type *T) const {
  if (const auto *CAT = dyn_cast&lt;ConstantArrayType&gt;(T))
    return getConstantArrayInfoInChars(*this, CAT);
  TypeInfo Info = getTypeInfo(T);
  return std::make_pair(toCharUnitsFromBits(Info.Width),
                        toCharUnitsFromBits(Info.Align));
</code></pre>
<p>随后转到<code>getTypeInfo</code>这个方法：</p>
<pre><code class="cpp">TypeInfo ASTContext::getTypeInfo(const Type *T) const {
  TypeInfoMap::iterator I = MemoizedTypeInfo.find(T);
  if (I != MemoizedTypeInfo.end())
    return I-&gt;second;
  // This call can invalidate MemoizedTypeInfo[T], so we need a second lookup.
  TypeInfo TI = getTypeInfoImpl(T);
  MemoizedTypeInfo[T] = TI;
  return TI;
}
</code></pre>
<h2 id="Implementing-class-template-member-functions"><a href="#Implementing-class-template-member-functions" class="headerlink" title="Implementing class template member functions"></a>Implementing class template member functions</h2><p>Implementing class template member functions和普通的class member functions不同。class template member functions的声明与定义需要在同一个头文件之中。</p>
<p>例子：</p>
<pre><code class="cpp">//B.H
template &lt;class t&gt;
class b
{
public:
    b() ;
    ~b() ;
} ;
// B.CPP
#include &quot;B.H&quot;
template &lt;class t&gt;
b&lt;t&gt;::b()
{
}
template &lt;class t&gt;
b&lt;t&gt;::~b()
{
}
//MAIN.CPP
#include &quot;B.H&quot;
void main()
{
     b&lt;int&gt; bi ;
     b &lt;float&gt; bf ;
}
</code></pre>
<p>当编译<code>B.cpp</code>的时候，编译器能够同时看到声明与定义，在这时，编译器不需要为template classes生成任何定义，因为在目前为止还没有产生实例（instantiation）。当编译器编译<code>main.cpp</code>的时候有两个实例：模板类<code>B&lt;int&gt;</code>和<code>B&lt;float&gt;</code>。这个时候编译器拥有声明却没有定义，所以会报错。</p>
<p><strong>【注】：</strong>c++标准里规定：a function template shall be defined in every translation unit in which it is implicitly instantiated。</p>
<h2 id="pragma-once"><a href="#pragma-once" class="headerlink" title="pragma once"></a><code>pragma once</code></h2><p><code>#pragma one</code>是一个非标准单被广泛支持的预编译指令，用于说明在一次编译的过程中，当前的源文件只会被包含一次。</p>
<p>例子：</p>
<pre><code class="cpp">//file &quot;grandparent.h&quot;
#pragma once
struct foo {
    int member;
};

//file &quot;parent.h&quot;
#include &quot;grandparent.h&quot;

//file &quot;child.c&quot;
#include &quot;grandparent.h&quot;
#include &quot;parent.h&quot;
</code></pre>
<p>在此例中，<code>grandparent.h</code>被同时包含在<code>parent.h</code>和<code>child.h</code>中，这将导致编译错误，因为具有给定名称的struct只能在编译中定义一次。而<code>#pragma once</code>指令通过忽略<code>grandparent.h</code>的subsequent inclusions来避免这一问题。</p>
<h2 id="大端和小端问题"><a href="#大端和小端问题" class="headerlink" title="大端和小端问题"></a>大端和小端问题</h2><ul>
<li>把指针类型<code>reinterpret_cast</code>会有字节序问题。如：<pre><code class="cpp"> int a=0x12345678;
 char* c=reinterpret_cast&lt;char*&gt;(&amp;a);
 printf(&quot;%x %x %x %x\n&quot;, c[0], c[1], c[2], c[3]);
 // 小端输出： 78 56 34 12
 // 大端输出： 12 34 56 78 
</code></pre>
</li>
<li>使用union做转换<pre><code class="cpp">union {
    int a;
    char c[4];
 }u;
 u.a=0x12345678;
 printf(&quot;%x %x %x %x\n&quot;, c[0], c[1], c[2], c[3]);
 // 小端输出： 12 34 56 78
 // 大端输出：  78 56 34 12
</code></pre>
</li>
<li>涉及读写内存外的数据，例如文件、文件流等。<h2 id="空类对象占一个字节的原因"><a href="#空类对象占一个字节的原因" class="headerlink" title="空类对象占一个字节的原因"></a>空类对象占一个字节的原因</h2><blockquote>
<p>因为BS大大当年说要确保两个不一样的对象拥有不同的地址—“To ensure that the addresses of two different objects will be different.”  就用那1byte来在内存中占用不同地址了。:)又因为这些空class没有赋值的意义，所以就没必要占用更多内存。</p>
</blockquote>
<h2 id="typeid"><a href="#typeid" class="headerlink" title="typeid"></a><code>typeid</code></h2>例如：<pre><code class="cpp">int i=1;
const char* name=typeid(i).name();
</code></pre>
上述的<code>typeid(i)</code>不需要做任何runtime动作，而仅仅是compile time时的行为——它使用变量<code>i</code>的静态类型，便可以知道这是对<code>int</code>类型做<code>typeid</code>运算，最后可以直接找出<code>int</code>对应的<code>std::type_info</code>对象返回。<blockquote>
<p>If expression is not a glvalue expression of polymorphic type, typeid does not evaluate the expression, and the std::type_info object it identifies represents the static type of the expression. Lvalue-to-rvalue, array-to-pointer, or function-to-pointer conversions are not performed.</p>
</blockquote>
</li>
</ul>
<p>此时的<code>typeid</code>运算符跟<code>sizeof</code>运算符的大部分情况一致，只需要编译器算出表达式的静态类型就足矣。计算出表达式的静态类型是C++编译器的基本功能，类型检查、类型推导等功能都依赖它。</p>
<p>但<code>typeid</code>运算符应用在一个指向多态类型对象的指针上时，<code>typeid</code>的实现才需要runtime行为。</p>
<blockquote>
<p>If expression is a glvalue expression that identifies an object of a polymorphic type (that is, a class that declares or inherits at least one virtual function), the typeid expression evaluates the expression and then refers to the std::type_info object that represents the dynamic type of the expression. If the glvalue expression is obtained by applying the unary * operator to a pointer and the pointer is a null pointer value, an exception of type std::bad_typeid or a type derived from std::bad_typeid is thrown.</p>
</blockquote>
<p>实现的时候，通常会在class的<code>vtable</code>里会有个slot，保存着指向该class所对应的<code>std::type_info</code>对象的指针。</p>
<p>在Clang中，前段Parser会调用<code>ang/lib/Parse/ParseExprCXX.cpp</code>中的<a href="https://code.woboq.org/llvm/clang/lib/Parse/ParseExprCXX.cpp.html#_ZN5clang6Parser14ParseCXXTypeidEv" target="_blank" rel="noopener"><code>ParseCXXTypeid</code></a>方法，主要用于识别<code>typeid</code>关键字、括号等信息。</p>
<pre><code class="cpp">ExprResult Parser::ParseCXXTypeid() {
  assert(Tok.is(tok::kw_typeid) &amp;&amp; &quot;Not &#39;typeid&#39;!&quot;);
  SourceLocation OpLoc = ConsumeToken();
  SourceLocation LParenLoc, RParenLoc;
  BalancedDelimiterTracker T(*this, tok::l_paren);
  // typeid expressions are always parenthesized.
  if (T.expectAndConsume(diag::err_expected_lparen_after, &quot;typeid&quot;))
    return ExprError();
  LParenLoc = T.getOpenLocation();
  ExprResult Result;
  // C++0x [expr.typeid]p3:
  //   When typeid is applied to an expression other than an lvalue of a
  //   polymorphic class type [...] The expression is an unevaluated
  //   operand (Clause 5).
  //
  // Note that we can&#39;t tell whether the expression is an lvalue of a
  // polymorphic class type until after we&#39;ve parsed the expression; we
  // speculatively assume the subexpression is unevaluated, and fix it up
  // later.
  //
  // We enter the unevaluated context before trying to determine whether we
  // have a type-id, because the tentative parse logic will try to resolve
  // names, and must treat them as unevaluated.
  EnterExpressionEvaluationContext Unevaluated(
      Actions, Sema::ExpressionEvaluationContext::Unevaluated,
      Sema::ReuseLambdaContextDecl);
  if (isTypeIdInParens()) {
    TypeResult Ty = ParseTypeName();
    // Match the &#39;)&#39;.
    T.consumeClose();
    RParenLoc = T.getCloseLocation();
    if (Ty.isInvalid() || RParenLoc.isInvalid())
      return ExprError();
    Result = Actions.ActOnCXXTypeid(OpLoc, LParenLoc, /*isType=*/true,
                                    Ty.get().getAsOpaquePtr(), RParenLoc);
  } else {
    Result = ParseExpression();
    // Match the &#39;)&#39;.
    if (Result.isInvalid())
      SkipUntil(tok::r_paren, StopAtSemi);
    else {
      T.consumeClose();
      RParenLoc = T.getCloseLocation();
      if (RParenLoc.isInvalid())
        return ExprError();
      Result = Actions.ActOnCXXTypeid(OpLoc, LParenLoc, /*isType=*/false,
                                      Result.get(), RParenLoc);
    }
  }
  return Result;
}
</code></pre>
<p>关键之处在于<a href="https://code.woboq.org/llvm/clang/lib/Sema/SemaExprCXX.cpp.html#_ZN5clang4Sema14ActOnCXXTypeidENS_14SourceLocationES1_bPvS1_" target="_blank" rel="noopener"><code>ActOnCXXTypeid</code></a>方法，其会通过<code>&amp;PP.getIdentifierTable().get(&quot;type_info&quot;)</code>从<code>IdentifierTable</code>中寻找有关<code>type_info</code>的信息，然后也可以从这个方法中获取有关runtime多态的信息。</p>
<p>Clang实现运行时的动态是通过<code>vtable</code>里面插入的<code>std::type_info</code>来做的，然后在运行时通过取<code>vtable</code>的<code>type_info</code>来达到目的。</p>
<h2 id="static-cast与reinterpret-cast的区别"><a href="#static-cast与reinterpret-cast的区别" class="headerlink" title="static_cast与reinterpret_cast的区别"></a><code>static_cast</code>与<code>reinterpret_cast</code>的区别</h2><p><img src="https://upload-images.jianshu.io/upload_images/1351548-83f965959b63ac50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="POD"><a href="#POD" class="headerlink" title="POD"></a>POD</h2><p>POD类型为plain old data，简称旧数据。POD本意是直接能与C library二进制直接交流的类型，但其中也有C++独有的类型。</p>
<p><strong>POD类型的要求：</strong></p>
<ul>
<li>标量类型（scalar type）<ul>
<li>算数（整数、浮点数）类型（arithmetic type）</li>
<li>枚举类型（enum type）</li>
<li>指针类型（pointer type）</li>
<li>指向成员的指针类型（pointer-to-member type)</li>
<li><code>std::nullpter_t</code> type</li>
<li>以上类型的cv-qualified version</li>
</ul>
</li>
<li>POD 类（<code>class</code>/<code>struct</code>和<code>union</code>）<ul>
<li>POD struct</li>
<li>POD union</li>
</ul>
</li>
<li>以上类型的数组和 cv 限定版本</li>
</ul>
<p><strong>POD struct和POD union的要求：</strong></p>
<ul>
<li>平凡类（trivial class）</li>
<li>标准布局类（standard-layout class）</li>
<li>没有非POD class类型或者其数组的non-static 数据成员</li>
</ul>
<p><strong>平凡类（trivial class）的要求：</strong></p>
<ul>
<li>可平凡拷贝类（trivially-copyable class）<ul>
<li>copy ctor、move ctor、copy assignment operator、move assigment operator均为trivial或者被删除</li>
<li>上述特殊成员函数<strong>至少有一个没有被删除</strong></li>
<li>拥有trivial且未被删除的dtor</li>
</ul>
</li>
<li>所有默认ctor均为trivial或者被删除，或至少有一个未被删除</li>
</ul>
<p><strong>平凡默认构造函数（trivial default ctor）的要求：</strong></p>
<ul>
<li>该ctor不是用户提供的（user-provided，即隐式定义或者显示<code>=default</code>）</li>
<li>类没有虚函数或者虚基类</li>
<li>所有non-static数据成员都没有默认初始化器（initilizer）</li>
<li>所有直接基类都有平凡默认构造函数（trivial default ctor）</li>
<li>每个类类型成员（class type member，或者类类型数组成员的元素）拥有平凡默认构造函数</li>
</ul>
<p><strong>平凡析构函数（trivial dtor）的要求：</strong></p>
<ul>
<li>dtor不是用户提供（隐式定义或者显示<code>=default</code>）</li>
<li>所有直接基类都有trivial dtor</li>
<li>每个类类型成员（或者类类型数组成员的元素）拥有trivial dtor</li>
</ul>
<p><strong>平凡复制/移动构造函数（trivial copy/move ctor）要求：</strong></p>
<ul>
<li>该ctor不是的用户提供（隐式定义或显式<code>=default</code>）</li>
<li>类没有虚函数或虚基类</li>
<li>为每个直接基类子对象选择的复制/移动构造函数为平凡（即直接基类的子对象拥有trivial copy/move ctor）</li>
<li>为每个类类型成员（或类类型数组成员的元素）选择的复制/移动构造函数为平凡 </li>
</ul>
<p><strong>平凡复制/移动运算符（trivial copy/move assignment operator）要求：</strong></p>
<ul>
<li>该赋值运算符不是用户提供（隐式定义或显式<code>=default</code>）</li>
<li>类没有虚函数或虚基类</li>
<li>为每个直接基类子对象选择的复制/移动赋值运算符为平凡</li>
<li>为每个类类型成员（或类类型数组成员的元素）选择的复制/移动赋值运算符为平凡</li>
</ul>
<p><strong>【注意】：</strong>平凡的拷贝/移动构造函数、平凡的拷贝/移动赋值运算符的行为等价于用<code>std::memmove</code>或<code>std::memcpy</code>拷贝对象表示。<strong>平凡的默认构造函行为等价于没有操作</strong>。</p>
<p><strong>标准布局类型（standard layout type）的要求：</strong></p>
<ul>
<li>没有非标准布局类型的基类</li>
<li>没有虚函数或虚基类</li>
<li>对于每个直接或间接基类，该基类的只有一个子对象</li>
<li>没有非标准布局类型（或其数组）或者引用类型的non-static数据成员</li>
<li>所有non-static数据成员拥有同一访问控制（<code>public</code>/<code>protected</code>/<code>private</code>）</li>
<li>该类和基类中的所有non-static数据成员、位域都在同一个类中声明</li>
</ul>
<p>简而言之，POD类型就是<strong>同时满足标准布局类型和平凡类型的类型</strong>。</p>
<p>其他关于<a href="https://zhuanlan.zhihu.com/p/29746508" target="_blank" rel="noopener">POD类型的参考</a></p>
<h2 id="定义了移动构造函数后，拷贝构造函数默认为删除的"><a href="#定义了移动构造函数后，拷贝构造函数默认为删除的" class="headerlink" title="定义了移动构造函数后，拷贝构造函数默认为删除的"></a>定义了移动构造函数后，拷贝构造函数默认为删除的</h2><p>对于<a href="https://msdn.microsoft.com/en-us/library/dn457344.aspx" target="_blank" rel="noopener">Visual Studio</a>：</p>
<blockquote>
<p>Visual Studio does not support defaulted move constructors or move-assignment operators as the C++11 standard mandates.</p>
</blockquote>
<p>copy constructor的默认生成是为了与C兼容，当年没有这个特性的话C++就没人用了。但是很多情况下默认生成的copy constructor是会造成问题的，因此标准委员会早就想把这个特性去除，但为了向后兼容还是一直留着。而C++11里加入了<code>move</code>，它在历史遗留的code里是不可能出现的，不存在兼容问题，所以你定义了move constructor后copy constructor就不默认生成了。</p>
<p>这其实表明，标准委员会倾向的代码风格是<strong>：在需要default copy constructor 的时候手动加入<code>= default</code>（所谓opt-in，目前来讲就是move constructor定义后的情况），而不是在不需要default copy constructor的时候手动加<code>= delete</code>（所谓opt-out，目前的其他情况）</strong></p>
<p>例子：<br>如果定义了destructor，copy constructor很可能会出问题，但历史上这时仍会生成default copy constructor。在C++11里已经把这种情况下的default copy constructor定为了“deprecated”，也就是说未来的某个版本里也许就会变成“如果定义了move constructor或destructor，default copy constructor默认为deleted”。</p>
<p>参考：<a href="https://stackoverflow.com/questions/11255027/why-user-defined-move-constructor-disables-the-implicit-copy-constructor" target="_blank" rel="noopener">Why user-defined move-constructor disables the implicit copy-constructor?
</a></p>
<h2 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a><code>std::move</code></h2><p><strong><code>std::move</code>并不会真正地移动对象，真正的移动操作是在移动构造函数、移动赋值函数等完成的，<code>std::move</code>只是将参数转换为右值引用而已（相当于一个<code>static_cast</code>）</strong>。<code>std::move</code>只影响调用函数的选择，它本身不需要任何生成机器码</p>
<pre><code class="cpp">std::string str = &quot;test&quot;;
string&amp;&amp; r = std::move(str);
</code></pre>
<p>在上述代码中，只定义了一个指向<code>str</code>的右值引用，<code>str</code>并没有被移走。随后执行<code>std::string t(r);</code><br>，需要注意的是右值引用用于表达式中时会变为左值，所以这里调用的其实是拷贝构造函数，<code>str</code>自然也不会被移走。如果要移走的话还要加一次<code>std::move</code>，比如<code>std::string t(std::move(r));</code>，<code>str</code>就能被移走了。</p>
<h2 id="char-a-void-20"><a href="#char-a-void-20" class="headerlink" title="char*(*(*a)(void))[20];"></a><code>char*(*(*a)(void))[20];</code></h2><pre><code class="cpp">void (*a)(void)
</code></pre>
<p>名为<code>a</code>的函数指针，指向<strong>接受类型为<code>void</code>，返回类型也为<code>void</code> 的函数</strong>。</p>
<pre><code class="cpp">`char *(*a)(void)
</code></pre>
<p>名叫<code>a</code>的函数指针，指向<strong>接受类型为<code>void</code>，返回类型为<code>char</code>指针的函数</strong>。</p>
<pre><code class="cpp">char (*(*a)(void))[20]
</code></pre>
<p>名为<code>a</code>的函数指针，指向<strong>接受类型为<code>void</code>，返回类型为指向长度 20 的<code>char</code>数组的指针的函数</strong>。</p>
<pre><code class="cpp">char *(*(*a)(void))[20]
</code></pre>
<p>名叫为<code>a</code>的函数指针，指向<strong>接受类型为<code>void</code>，返回类型为指向长度 20 的<code>char*</code>数组的指针的函数</strong>。</p>
<h2 id="特化和偏特化"><a href="#特化和偏特化" class="headerlink" title="特化和偏特化"></a>特化和偏特化</h2><p>所谓模板特例化，即对于通例中的某种或某些情况做单独专门实现，最简单的情况是对每个模板参数指定一个具体值，这成为完全特例化（full specialization）。另外，可以限制模板参数在一个范围取值或满足一定关系等，这称为部分特例化（partial specialization）。<strong>用数学上集合的概念，通例模板参数所有可取的值组合构成全集U，完全特例化对U中某个元素进行专门定义，部分特例化对U的某个真子集进行专门定义</strong>。</p>
<p>需要特化或者偏特化的原因：<strong>因为编译器认为，对于特定的类型，如果你能对某一功能更好的实现，那么就该听你的</strong>。</p>
<p>在某些情况下，通用模板的定义对特定类型并不适合。当不能使用模板版本时，可以定义类型或者函数模板的一个特例化版本。</p>
<p>一个特化版本就是模板的一个独立的定义，在其中一个或者多个模板参数被指定为特定的类型。特化的形式为：<code>template &lt;&gt;</code>，其中<code>&lt;&gt;</code>指出将为原模板的所有模板参数提供实参。</p>
<p><strong>特化就是将模板的参数写死，针对这样一种具体的实现，告诉编译器要去生成的是这段代码，而非是将参数传入模板当种简单的替换。 偏特化就属于特化和原模板之间，有些参数被写定，有些参数还是<code>T</code>根据实例化的时候去替换。</strong></p>
<p>例子：</p>
<pre><code class="cpp">template&lt;typename T1, typename T2&gt;  
class Test  {  
public:  
    Test(T1 i,T2 j):a(i),b(j){cout&lt;&lt;&quot;模板类&quot;&lt;&lt;endl;}  
private:  
    T1 a;  
    T2 b;  
};  

template&lt;&gt;  
class Test&lt;int , char&gt;  {  
public:  
    Test(int i, char j):a(i),b(j){cout&lt;&lt;&quot;全特化&quot;&lt;&lt;endl;}  
private:  
    int a;  
    char b;  
};  

template &lt;typename T2&gt;  
class Test&lt;char, T2&gt;  
{  
public:  
    Test(char i, T2 j):a(i),b(j){cout&lt;&lt;&quot;偏特化&quot;&lt;&lt;endl;}  
private:  
    char a;  
    T2 b;  
};  

Test&lt;double , double&gt; t1(0.1,0.2);  
Test&lt;int , char&gt; t2(1,&#39;A&#39;);  
Test&lt;char, bool&gt; t3(&#39;A&#39;,true); 
</code></pre>
<p><strong>【注】：</strong>当特化一个函数模板时，必须为原模板中的每个模板参数都提供实参。</p>
<h2 id="std-declval"><a href="#std-declval" class="headerlink" title="std::declval"></a><code>std::declval</code></h2><p>定义在<code>&lt;utility&gt;</code>，其原型为：</p>
<pre><code class="cpp">template&lt;class T&gt;
typename std::add_rvalue_reference&lt;T&gt;::type declval() noexcept;
</code></pre>
<p>作用是<strong>将任意类型<code>T</code>转换为引用类型，从而使得可以在<code>decltype</code>表达式中，不需要经过构造函数就能够使用member function</strong>。</p>
<p>通常在模板中适应<code>declval</code>，它所接受的模板实参通常可能没有构造函数，但有相同的成员函数，并返回所需类型。</p>
<p>其返回值不能够被调用，因此不会返回值。返回的类型为<code>T&amp;&amp;</code>，如果<code>T</code>是<code>void</code>，此情况下的返回类型是<code>T</code>。</p>
<p>例子：</p>
<pre><code class="cpp">#include &lt;utility&gt;
#include &lt;iostream&gt;

struct Default { int foo() const { return 1; } };

struct NonDefault {
    NonDefault(const NonDefault&amp;) { }
    int foo() const { return 1; }
};

int main() {
    decltype(Default().foo()) n1 = 1;                   // type of n1 is int
//  decltype(NonDefault().foo()) n2 = n1;               // error: no default constructor
    decltype(std::declval&lt;NonDefault&gt;().foo()) n2 = n1; // type of n2 is int
    std::cout &lt;&lt; &quot;n1 = &quot; &lt;&lt; n1 &lt;&lt; &#39;\n&#39;
              &lt;&lt; &quot;n2 = &quot; &lt;&lt; n2 &lt;&lt; &#39;\n&#39;;
}
</code></pre>
<p>扩展：<a href="https://arne-mertz.de/2017/01/decltype-declval/" target="_blank" rel="noopener">Modern C++ Features – decltype and std::declval</a></p>
<h2 id="std-void-t"><a href="#std-void-t" class="headerlink" title="std::void_t"></a><code>std::void_t</code></h2><p>C++17的新特性，在早期的C++版本中实现这个功能需要：</p>
<pre><code class="cpp">template&lt;typename... Ts&gt; struct make_void { typedef void type;};
template&lt;typename... Ts&gt; using void_t = typename make_void&lt;Ts...&gt;::type;
</code></pre>
<p>其原型为：<br><code>template&lt; class ... &gt; using void_t = void;</code></p>
<p>例子：</p>
<pre><code class="cpp">template&lt; class , class = void &gt;
struct has_member : std::false_type { };

// specialized as has_member&lt; T , void &gt; or discarded (sfinae)
template&lt; class T &gt;
struct has_member&lt; T , void_t&lt; decltype( T::member ) &gt; &gt; : std::true_type { };

class A {
public:
    int member;
};

class B {
};

static_assert( has_member&lt; A &gt;::value , &quot;A&quot; );
static_assert( has_member&lt; B &gt;::value , &quot;B&quot; );
</code></pre>
<p>个人理解：</p>
<ol>
<li><code>has_member&lt; A &gt;</code><ul>
<li><code>has_member&lt; A , void_t&lt; decltype( A::member ) &gt; &gt;</code><ul>
<li><code>A::member exists</code></li>
<li><code>decltype( A::member )</code> is well-formed</li>
<li><code>void_t&lt;&gt;</code> is valid and evaluates to void</li>
</ul>
</li>
<li><code>has_member&lt; A , void &gt;</code> and therefore it chooses the specialized template</li>
<li><code>has_member&lt; T , void &gt;</code> and evaluates to <code>true_type</code></li>
</ul>
</li>
<li><code>has_member&lt; B &gt;</code><ul>
<li><code>has_member&lt; B , void_t&lt; decltype( B::member ) &gt; &gt;</code><ul>
<li><code>B::member</code> does not exist</li>
<li><code>decltype( B::member )</code> is ill-formed and fails silently (sfinae)</li>
<li><code>has_member&lt; B , expression-sfinae &gt;</code> so this template is discarded</li>
</ul>
</li>
<li>compiler finds <code>has_member&lt; B , class = void &gt;</code> with <code>void</code> as default argument</li>
<li><code>has_member&lt; B &gt;</code> evaluates to <code>false_type</code></li>
</ul>
</li>
</ol>
<p>当遇到<code>has_member&lt; A &gt;::value</code>时，编译器会去查找<code>has_member</code>，最终找到primary class template，即<code>template&lt; class , class = void &gt;
struct has_member;</code>。此时，模板参数列表<code>&lt;A&gt;</code>会与primary template的参数列表进行比较。因为primary template拥有两个参数，但此时只提供了一个参数，则剩余的参数将会被默认为default template argument：<code>void</code>。这就如同书写了<code>has_member&lt;A, void&gt;::value</code>。</p>
<p>现在，将模板参数列表与<code>has_memeber</code>的特化版本进行比较。仅当没有特化版本与之匹配时，primary template才会被用作后备。所以偏特化版本将会被考虑进来：</p>
<pre><code class="cpp">template&lt; class T &gt;
struct has_member&lt; T , void_t&lt; decltype( T::member ) &gt; &gt; : std::true_type { };
</code></pre>
<p>编译器试图将模板参数：<code>A, void</code>与偏特化中定义的模式：<code>T</code>和<code>void_t&lt;...&gt;</code>进行逐个匹配。首先，进行模板参数推导。上面的偏特化仍然是一个拥有模板参数的模板，需要参数进行“填充”。</p>
<p>第一个模式<code>T</code>允许编译器推导出模板参数<code>T</code>。这是一个trivial deduction，但考虑到想<code>T const&amp;</code>这样的模式，所以仍然需要进行推导出<code>T</code>。对于模式<code>T</code>和模板参数<code>A</code>，可以推导出<code>T</code>为<code>A</code>。</p>
<p>在第二种模式<code>void_t&lt; decltype( T::member ) &gt;</code>中，模板参数<code>T</code>出现在无法从任何模板参数推导出来的上下文（context）中，有以下两个原因：</p>
<ul>
<li><code>decltype</code>中的表达式将无法由模板参数显示地推导得到，因为它可能是arbitrarily complex（The expression inside decltype is explicitly excluded from template argument deduction. I guess this is because it can be arbitrarily complex.）。</li>
<li>即使使用了像<code>void_t &lt;T&gt;</code>没有<code>decltype</code>的模式，在今后解析的别名模板（alias template）上还是会发生<code>T</code>的推导。也就是说，当解析了别名模板，然后尝试从resulting pattern中推导出类型<code>T</code>。然而，得到的resulting pattern是<code>void</code>，它不依赖与<code>T</code>，因此不允许找到<code>T</code>的一个特定类型。</li>
<li>现在模板参数的推导便结束了，被推导出来的模板参数被替换（substituted）。这就产生了以下的特化代码：<pre><code class="cpp">template&lt;&gt;
struct has_member&lt; A, void_t&lt; decltype( A::member ) &gt; &gt; : true_type { };
</code></pre>
现在可以计算（evaluate）类型<code>void_t&lt; decltype( A::member ) &gt; &gt;</code>，它被替换之后是well-formed，因此不会发生Substitution Failure。所以将得到：<pre><code class="cpp">template &lt;&gt;
struct has_member&lt;A, void&gt; : true_type { };
</code></pre>
现在将这个特化版本的模板参数列表与之前提供的原始模板参数<code>has_member&lt;A&gt;::value</code>进行比较。两种类型完全匹配，因此选择这个版本的特化。</li>
</ul>
<p>此外，当我们定义下列模板时：</p>
<pre><code class="cpp">template&lt; class , class = int &gt; // &lt;-- int here instead of void
struct has_member : false_type { };

template&lt; class T &gt;
struct has_member&lt; T , void_t&lt; decltype( T::member ) &gt; &gt; : true_type { };
</code></pre>
<p>我们最终得到了相同的特化：</p>
<pre><code class="cpp">template&lt;&gt;
struct has_member&lt;A, void&gt; : true_type { };
</code></pre>
<p>但是<code>has_member&lt;A&gt;::value</code>的模板参数列表已经变成了<code>&lt;A, int&gt;</code>。参数并与能够与特化版本的参数匹配，所以将选择primary template。</p>
<p><strong>为什么需要使用<code>void_t</code></strong><br>如果不使用<code>void_t</code>，则偏特化版本的模板将永远不会被匹配上，因为<code>decltype</code>将<code>T</code>求值为非<code>void</code>，这就将导致不会匹配上偏特化版本，从而只能选择primary template。现在如果你知道函数最终将总是会返回一个相同类型时，你便可以随意地更改primary template的默认参数。</p>
<p>这就需要引入<code>void_t</code>，因为<code>void_t</code>只是一个identity type trait，<br>即无论什么情况下，都是产生<code>void</code>。这就意味着在第二个例子中，无论<code>decltype</code>的计算结果如何，第二个模板参数都将为<code>void</code>，因此如果<code>decltype</code>是well-formed，将匹配成功并选择这个特化版本。</p>
<h2 id="Detection-Idiom-is-detected"><a href="#Detection-Idiom-is-detected" class="headerlink" title="Detection Idiom:is_detected"></a>Detection Idiom:<code>is_detected</code></h2><p>即使有了<code>void_t</code>，但每次需要一个新的判定时就得再重写一次SFINAE，显得有点儿不够直观。</p>
<pre><code class="cpp">template &lt;typename T&gt;
using has_type_t = typename T::type;
template &lt;typename T&gt;
using has_type = is_detected&lt;has_type_t, T&gt;;
</code></pre>
<p>虽然<code>is_detected</code>还没有进入标准，但依然可以在 C++11 中实现：</p>
<pre><code class="cpp">template &lt;typename, template &lt;typename...&gt; class Op, typename... T&gt;
struct is_detected_impl : std::false_type {};
template &lt;template &lt;typename...&gt; class Op, typename... T&gt;
struct is_detected_impl&lt;void_t&lt;Op&lt;T...&gt;&gt;, Op, T...&gt; : std::true_type {};

template &lt;template &lt;typename...&gt; class Op, typename... T&gt;
using is_detected = is_detected_impl&lt;void, Op, T...&gt;;
</code></pre>
<p>下面是用<code>is_detected</code>判断成员函数是否存在：</p>
<pre><code class="cpp">template &lt;typename T&gt;
using has_get_t = decltype(std::declval&lt;T&amp;&gt;().get());
template &lt;typename T&gt;
using has_get = is_detected&lt;has_get_t, T&gt;;
</code></pre>
<h3 id="template-template-parameters"><a href="#template-template-parameters" class="headerlink" title="template template parameters"></a>template template parameters</h3><p>需要使用template template syntax来传递一个参数，其类型是依赖于另一个template的template，如下所示：</p>
<pre><code class="cpp">template &lt;template&lt;class&gt; class H, class S&gt;
void f(const H&lt;S&gt; &amp;value) {
}
</code></pre>
<p>这里，<code>H</code>是一个模板，但希望这个函数能够处理<code>H</code>的所有特化。</p>
<p>实际上，模板模板参数的用处非常明显。 一旦你了解到C ++ stdlib没有为标准容器类型定义流输出操作符的漏洞，便可以继续写下这样的东西：</p>
<pre><code class="cpp">template&lt;typename T&gt;
static inline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, std::list&lt;T&gt; const&amp; v) {
    out &lt;&lt; &#39;[&#39;;
    if (!v.empty()) {
        for (typename std::list&lt;T&gt;::const_iterator i = v.begin(); ;) {
            out &lt;&lt; *i;
            if (++i == v.end())
                break;
            out &lt;&lt; &quot;, &quot;;
        }
    }
    out &lt;&lt; &#39;]&#39;;
    return out;
}
</code></pre>
<p>然后你会发现，对于<code>vector</code>的代码也与上面的类。实际上，即使对于大量的<code>map</code>类型，它仍然是相同的。在继续编写模板之前，有必要检查引用以回忆序列容器接受2个模板参数 - 对于值类型和分配器。 虽然分配器是默认的，但我们仍然应该在模板运算符&lt;&lt;中考虑它的存在：</p>
<pre><code class="cpp">template&lt;typename T, template&lt;class,class...&gt; class C, class... Args&gt;
std::ostream&amp; operator &lt;&lt;(std::ostream&amp; os, const C&lt;T,Args...&gt;&amp; objs) {
    os &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; &#39;\n&#39;;
    for (auto const&amp; obj : objs)
        os &lt;&lt; obj &lt;&lt; &#39; &#39;;
    return os;
}

int main() {
    std::vector&lt;float&gt; vf { 1.1, 2.2, 3.3, 4.4 };
    std::cout &lt;&lt; vf &lt;&lt; &#39;\n&#39;;

    std::list&lt;char&gt; lc { &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39; };
    std::cout &lt;&lt; lc &lt;&lt; &#39;\n&#39;;

    std::deque&lt;int&gt; di { 1, 2, 3, 4 };
    std::cout &lt;&lt; di &lt;&lt; &#39;\n&#39;;

    return 0;
}

/// std::ostream &amp;operator&lt;&lt;(std::ostream &amp;, const C&lt;T, Args...&gt; &amp;) [T = float, C = vector, Args = &lt;std::__1::allocator&lt;float&gt;&gt;]
///1.1 2.2 3.3 4.4 
///std::ostream &amp;operator&lt;&lt;(std::ostream &amp;, const C&lt;T, Args...&gt; &amp;) [T = char, C = list, Args = &lt;std::__1::allocator&lt;char&gt;&gt;]
///a b c d 
///std::ostream &amp;operator&lt;&lt;(std::ostream &amp;, const C&lt;T, Args...&gt; &amp;) [T = int, C = deque, Args = &lt;std::__1::allocator&lt;int&gt;&gt;]
///1 2 3 4 
</code></pre>
<p><strong><code>__PRETTY_FUNCTION__</code></strong> 为非标准宏，</p>
<ol>
<li><p>若用g++编译C++程序， <code>__FUNCTION__</code>只能输出类的成员函数名，不会输出类名。而<code>__PRETTY_FUNCTION__</code>则会以<code>&lt;return-type&gt; &lt;class-name&gt;::&lt;member-function-name&gt;(&lt;parameters-list&gt;)</code>的格式输出成员函数的详悉信息(注: 只会输出<code>parameters-list</code>的形参类型, 而不会输出形参名).</p>
</li>
<li><p>若用gcc编译C程序，<code>__PRETTY_FUNCTION__</code>跟<code>__FUNCTION__</code>的功能相同。</p>
</li>
</ol>
<blockquote>
<p>在C99标准中，加入了一个有用的、类似宏的表达式<code>__func__</code>，它会报告未修饰过的、正在被访问的函数名。<code>__func__</code><strong>不是一个宏，因为预处理器对此函数一无所知</strong>。相反，它是作为一个隐式声明的常量字符数组实现的：<code>static const char __func__[] = &quot;function-name&quot;;</code> 。ISO C++却不完全支持所有的C99扩展，大多数的编译器提供商都使用<code>__FUNCTION__</code>取而代之，而<code>__FUNCTION__</code>通常是一个定义为 <code>__func__</code>的宏，之所以使用这个名字，是因为它已受到了大多数的广泛支持。<br>在Visual Studio 2005中，默认情况下，此特性是激活的。在IDE环境中，不能识别<code>__func__</code>，而要用<code>__FUNCTION__</code>代替。GCC 3.0及更高的版本同时支持<code>__func__</code>和<code>__FUNCTION__</code>。<br><code>__FUNCDNAME__</code>：返回函数的修饰名，<code>__FUNCSIG__</code>：返回返回签名。</p>
</blockquote>
<p>例子：</p>
<pre><code class="cpp">int read(int x) {
    std::cout&lt;&lt;__FUNCTION__&lt;&lt;&#39;\n&#39;
            &lt;&lt;__FUNCDNAME__&lt;&lt;&#39;\n&#39;
            &lt;&lt;__FUNCSIG__&lt;&lt;std::endl;
}

int main() {
    read(5);
}
///read
///?read@@YAHH@Z
///int __cdecl read(int)
///int read(int)
</code></pre>
<h2 id="std-tuple"><a href="#std-tuple" class="headerlink" title="std::tuple"></a><code>std::tuple</code></h2><h3 id="1-make-tuple"><a href="#1-make-tuple" class="headerlink" title="1. make_tuple"></a>1. <code>make_tuple</code></h3><pre><code class="cpp">template&lt; class... Types &gt;
tuple&lt;VTypes...&gt; make_tuple( Types&amp;&amp;... args );
</code></pre>
<p>创建一个tuple对象，并根据参数类型推导目标类型。返回值类型为：<code>std::tuple&lt;VTypes...&gt;(std::forward&lt;Types&gt;(t)...)</code>。<br>其可能实现为：</p>
<pre><code class="cpp">template &lt;class T&gt;
struct unwrap_refwrapper {
    using type = T;
};

template &lt;class T&gt;
struct unwrap_refwrapper&lt;std::reference_wrapper&lt;T&gt;&gt; {
    using type = T&amp;;
};

template &lt;class T&gt;
using special_decay_t = typename unwrap_refwrapper&lt;typename std::decay&lt;T&gt;::type&gt;::type;

template &lt;class... Types&gt;
auto make_tuple(Types&amp;&amp;... args) {
    return std::tuple&lt;special_decay_t&lt;Types&gt;...&gt;(std::forward&lt;Types&gt;(args)...);
}
</code></pre>
<h3 id="2-tuple-cat"><a href="#2-tuple-cat" class="headerlink" title="2. tuple_cat"></a>2. <code>tuple_cat</code></h3><p>将参数中的所有<code>tuple</code>连接成一个<code>tuple</code>。</p>
<p>例子：</p>
<pre><code class="cpp">template &lt;typename Tuple, std::size_t N&gt;
struct TuplePrint{
    static void print(const Tuple&amp; t){
        TuplePrint&lt;Tuple,N-1&gt;::print(t);
        std::cout&lt;&lt;&quot;, &quot;&lt;&lt;std::get&lt;N-1&gt;(t);
    }
};

template &lt;typename Tuple&gt;
struct TuplePrint&lt;Tuple,1&gt;{
    static void print(const Tuple&amp; t){
        std::cout&lt;&lt;std::get&lt;0&gt;(t);
    }
};

template &lt;typename...Args&gt;
void print(const std::tuple&lt;Args...&gt;&amp; t){
    std::cout&lt;&lt;&quot;( &quot;;
    TuplePrint&lt;decltype(t),sizeof...(Args)&gt;::print(t);
    std::cout&lt;&lt;&quot; )\n&quot;;
}

int main(){
    std::tuple&lt;int,std::string,float&gt; t1(10,&quot;test&quot;,3.14);
    int n=7;
    auto t2=std::tuple_cat(t1,std::make_pair(&quot;Foo&quot;,&quot;bar&quot;),t1,std::tie(n));
    n=10;
    print(t2);
}
///    ( 10, test, 3.14, Foo, bar, 10, test, 3.14, 10 )
</code></pre>
<h3 id="3-std-tie"><a href="#3-std-tie" class="headerlink" title="3. std::tie"></a>3. <code>std::tie</code></h3><p>Creates a tuple of lvalue references to its arguments or instances of <code>std::ignore</code>.</p>
<p>例子：</p>
<pre><code class="cpp">int main() {
    std::set&lt;std::string&gt; set_of_str;
    bool inserted;
    std::tie(std::ignore, inserted) = set_of_str.insert(&quot;Test&quot;);
    if (inserted) {
        std::cout &lt;&lt; &quot;Value was inserted sucessfully\n&quot;;
    }
}
</code></pre>
<p>上述代码，<code>set::insert</code>返回一个<code>std::pair</code>，其中<code>first</code>是插入元素的迭代器，第二个是<code>bool</code>，表示是否插入了元素。</p>
<p><code>std::tie</code>创建一个左值引用<code>tuple</code>。 当利用<code>insert</code>进行插入时，它将<code>std::tie</code>中的变量设置为<code>std::pair</code>的<code>first</code>和<code>second</code>成员。</p>
<p><strong><code>std::ignore</code></strong></p>
<blockquote>
<p>An object of unspecified type such that any value can be assigned to it with no effect. Intended for use with <code>std::tie</code> when unpacking a <code>std::tuple</code>, as a placeholder for the arguments that are not used.</p>
</blockquote>
<p>这段代码的作用：忽略<code>Test</code>的的迭代器，并将<code>assigned</code>赋值给<code>std::pair</code>的成员<code>second</code>（用于表明一个元素是否被插入）。</p>
<h3 id="tuple-element"><a href="#tuple-element" class="headerlink" title="tuple_element"></a><code>tuple_element</code></h3><p>在编译期根据索引，返回该<code>tuple</code>元素的type。<br>可能实现为：</p>
<pre><code class="cpp">template &lt;std::size_t I, typename T&gt;
struct tuple_element;

///    recursive case
template &lt;std::size_t I, typename Head, typename...Tail&gt;
struct tuple_element&lt;I, std::tuple&lt;Head, Tail...&gt;&gt; { };

///    base case
template &lt;typename Head, typename...Tail&gt;
struct tuple_element&lt;0, std::tuple&lt;Head, Tail...&gt;&gt; {
    typedef Head type;
};
</code></pre>
<p>例子：</p>
<pre><code class="cpp">template &lt;typename...Args&gt;
struct type_list {
    template &lt;std::size_t I&gt;
    using type = typename std::tuple_element&lt;I, std::tuple&lt;Args...&gt;&gt;::type;
};

int main() {
    std::cout&lt;&lt;std::boolalpha;
    type_list&lt;bool,short,int&gt;::type&lt;0&gt; x=1;
    std::cout&lt;&lt;x&lt;&lt;std::endl;
}
///    true
</code></pre>
<p>扩展：</p>
<ol>
<li><a href="http://mail-archives.apache.org/mod_mbox/stdcxx-dev/200807.mbox/%3C4872AA41.7040005@roguewave.com%3E" target="_blank" rel="noopener"><code>std::ignore的实现</code></a></li>
<li><a href="http://blogs.microsoft.co.il/sasha/2015/01/12/implementing-tuple-part-1/" target="_blank" rel="noopener">Implementing <code>std::tuple</code></a></li>
</ol>
<h2 id="type-traits"><a href="#type-traits" class="headerlink" title="type_traits"></a><code>type_traits</code></h2><p>使用traits的目的主要有三种：分派（dispatch）、效率以及使得某些代码通过编译。</p>
<h4 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h4><p>假设有一个模板函数，由一个动物园提供，接受所有的动物。于是它向外界提供一个函数接受register：</p>
<pre><code class="cpp">template &lt;typename T&gt;
void AcceptAnimals(T animal) {
    ... //impl
}
</code></pre>
<p>但如果想要将是狮子与熊猫分开处理（饲养两种动物并不相同，可能对狮子需要提供肉，而对于熊猫只需要提供竹子）。可能想到的方法是分别提供两个不同的函数：<code>AcceptLion</code>与<code>AcceptPanda</code>，但是这种方法显得十分冗余（注册者可能既有狮子又有熊猫，这样就不得不调用不同的函数来注册，同时伴随着动物种类的增加，势必会导致向外提供的结构也随之增加，而注册者又不得不记住这些冗余的名字，而这显然没有只需要记住<code>AcceptAnimal</code>这一个名字来的简单）。如果想要保持这个模板函数，并将它作为向外界提供的唯一接口，则需要某种方式来获取类型<code>T</code>的<strong>特征（trait）</strong>，并按照不同的特征来采取不同的策略。</p>
<p>所以，解决办法是：<strong>规定所有的动物类（如<code>class Lion</code>，<code>class Panda</code>）都必须在类内部提供一个<code>typedef</code>类型，用于表明自己身份</strong>。</p>
<pre><code class="cpp">struct lion_tag { };    //这只是一个empty class，目的是用于激发function overloading
struct panda_tag { };
</code></pre>
<p>对于所有的狮子类，则有：</p>
<pre><code class="cpp">class Lion {
public:
    typedef lion_tag type;    //类型标志，表明这是Lion类
    ...
}
</code></pre>
<p>此时，动物园便可以在内部分别提供对狮子和熊猫的处理函数：</p>
<pre><code class="cpp">template &lt;typename T&gt;
void Accept(T lion, lion_tag) { ... }

template &lt;typename T&gt;
void Accept(T panda, panda_tag) { ... }
</code></pre>
<p>最后，之前的<code>Accept</code>函数可以改写为：</p>
<pre><code class="cpp">tmeplate &lt;typename T&gt;
void Accept(T animal) {
//如果T是lion类，则typename T::type就是lion_tag，那么typename T::type()将创建一个lion_tag类的临时对象，根据函数重载的规则，将会调用Accept(T,lion_tag)，这正是转向处理狮子的策略。
//typename用于告诉编译器T::type这是个类型，而不是static member
    Accept(animal, typename T::type());        //##
}
</code></pre>
<p>此时，所有的类型推导、函数重载都是在编译期完成，几乎不需要耗费任何runtime成本（除了创建lion_tag，panda_tag临时对象成成本，然而经过编译器的优化，这种成本将会消失）就能拥有可读性和可维护性高的代码。也许你会纳闷，traits在哪里，其实**<code>typename T::type</code>就是traits，只不过少了一层封装而已，可以如下改进：</p>
<pre><code class="cpp">template &lt;typename T&gt;
struct AnimalTraits {
    typedef T::type type;
}
</code></pre>
<p>所以，<code>##</code>处的代码可以改写为：</p>
<pre><code class="cpp">Accept(animal, typename AnimalTraits&lt;T&gt;::type());
</code></pre>
<h4 id="使得某些代码能够通过编译"><a href="#使得某些代码能够通过编译" class="headerlink" title="使得某些代码能够通过编译"></a>使得某些代码能够通过编译</h4><p>经过traits某些代码能够通过编译，例如<code>std::pair</code>的代码：</p>
<pre><code class="cpp">template &lt;typename T1, typename T2&gt;
struct pair {
    T1 first;
    T2 second;
    //如果T1或T2本身就是引用，则会出现编译错误，因为没有“引用的引用”
    pair(const T1&amp; nfirst, const T2&amp; nsecond):
        first(nfirst), second(nsecond) { }
};
</code></pre>
<p>此时，便可以使用一个traits（<code>std::type_traits</code>中的<code>std::add_reference</code>）来避免这样的编译错误。这个traits中包含一个typedef，如果<code>add_reference&lt;T&gt;</code>中的<code>T</code>为引用，则<code>typedef T type</code>；如果<code>T</code>不是引用，则有<code>typedef T&amp; type</code>。于是上述代码可改写为：</p>
<pre><code class="cpp">pair(add_reference&lt;const T1&gt;::type nfirst, add_reference&lt;cosnt T2&gt;::type nsecond) ...
</code></pre>
<h3 id="std-integral-constant"><a href="#std-integral-constant" class="headerlink" title="std::integral_constant"></a><code>std::integral_constant</code></h3><p>其可能实现为：</p>
<pre><code class="cpp">template &lt;typename T, T v&gt;
struct integral_constant {
    static constexpr T value;
    typedef T value_type;
    typedef integral_constant type;    //使用injected-class-name
    constexpr operator value_type() const noexcept { return value; }
    constexpr value_type operator () () const noexcept { return value; }
</code></pre>
<p><strong>injected-class-name:</strong>在类作用域中，当前类的name被当做一个public member name。在name的声明处之后紧随的是类的定义**。即injected-class-name意味着<code>X</code>被当成<code>X</code>的一个成员，以至于在<code>X</code>内部进行name lookup是总是会找到当前类，而不是在同一个封闭作用域中声明的其他<code>X</code>。</p>
<pre><code class="cpp">void X() { }
class X {
public:
  static X create() { return X(); }
};
</code></pre>
<p><code>create()</code>函数是产生一个临时<code>X</code>对象还是条用函数<code>X</code>？在命名空间范围内（namespace scope），它会调用函数，因此injected-class-name的目的是为了确保在类<code>X</code>内，name总是找到class本身（因为name look总是会会子啊class自身的范围内开始，然后再查看enclosing scope）。</p>
<p>它在类模板内也十分有用，injected-class-name可以在没有模板参数列表的情况下使用。例如可以使用简单的<code>Foo</code>而不是完整的<em>template-id</em><code>Foo&lt;bla,bla,bla&gt;</code>，因此可以很容易使用当前的实例（instantiation）。</p>
<p>例子：</p>
<pre><code class="cpp">int X;
struct X {
    void f() { 
        X* p;    //OK，X是一个injected-class-name
        ::X* q; //Error：name lookup找到的是变量名，它掩盖了struct 那么
    }
};
</code></pre>
<p>扩展阅读：<a href="https://www.boost.org/community/generic_programming.html#tag_dispatching" target="_blank" rel="noopener">Generic Programming Techniques</a></p>
<h4 id="true-type与false-type"><a href="#true-type与false-type" class="headerlink" title="true_type与false_type"></a><code>true_type</code>与<code>false_type</code></h4><pre><code class="cpp">typedef std::integral_constant&lt;bool, true&gt; true_type;
typedef std::integral_constant&lt;bool, false&gt; false_type;
</code></pre>
<h4 id="std-is-same"><a href="#std-is-same" class="headerlink" title="std::is_same"></a><code>std::is_same</code></h4><p>可能实现为：</p>
<pre><code class="cpp">template &lt;typename T, typename U&gt;
struct is_same : std::false_type { }

template &lt;typename T&gt;
struct is_same&lt;T, T&gt; : std::true_type { }
</code></pre>
<h4 id="std-add-pointer"><a href="#std-add-pointer" class="headerlink" title="std::add_pointer"></a><code>std::add_pointer</code></h4><p>可能实现为：</p>
<pre><code class="cpp">namespace detail {
template &lt;typename T, bool is_function_type = false&gt;
struct add_pointer {
    using type = typename std::reference&lt;T&gt;::type*;
}

template &lt;typename T&gt;
struct add_pointer&lt;T, true&gt; {
    using type = T;
};

template &lt;typename T, typename...Args&gt;
struct add_pointer&lt;T(Args...), true&gt; {
    using type = T(*)(Args...);
}

template &lt;typename T, typename...Args&gt;
struct add_pointer&lt;T(Args..., ...), true&gt; {
    using type = T(*)(Args..., ...);
};
}    //namespace detail

template &lt;typename T&gt;
struct add_pointer : detail::add_pointer&lt;T, std::is_function&lt;T&gt;::value&gt; { }
</code></pre>
<h4 id="std-is-pointer"><a href="#std-is-pointer" class="headerlink" title="std::is_pointer"></a><code>std::is_pointer</code></h4><p>检查<code>T</code>是否为a pointer to object or a pointer to function（注意：不是成员指针或者成员函数指针）。可能实现为：</p>
<pre><code class="cpp">template &lt;typename T&gt;
struct is_pointer_helper : std::false_type { };

template &lt;typename T&gt;
struct is_pointer_helper&lt;T*&gt; : std::true_type { };

template &lt;typename T&gt;
struct is_pointer : is_ponter_helper&lt;typename std::remove_cv&lt;T&gt;::type&gt; { };
</code></pre>
<p>例子：</p>
<pre><code class="cpp">struct A {
    void func();
};

int main() {
    std::cout&lt;&lt; std::boolalpha;
    std::cout&lt;&lt; std::is_pointer&lt;decltype(&amp;A::func)&gt;::value &lt;&lt;std::endl;
}
/// false
</code></pre>
<h4 id="std-remove-cv"><a href="#std-remove-cv" class="headerlink" title="std::remove_cv"></a><code>std::remove_cv</code></h4><p>可能实现为：</p>
<pre><code class="cpp">template &lt;typename T&gt; struct remove_const { typedef T type; };
template &lt;typename T&gt; struct remove_const&lt;const T&gt; { typedef T type; };

template &lt;typename T&gt; struct remove_volatile { typedef T type; };
template &lt;typename T&gt; struct remove_volatile&lt;volatile T&gt;  { typedef T type; };

template &lt;typename T&gt;
struct remove_cv {
    typedef typename std::remove_volatile&lt;typename std::remove_const&lt;T&gt;::type&gt;::type type;
};
</code></pre>
<h4 id="std-remove-reference"><a href="#std-remove-reference" class="headerlink" title="std::remove_reference"></a><code>std::remove_reference</code></h4><p>可能实现为：</p>
<pre><code class="cpp">template &lt;typename T&gt; struct remove_reference { typedef T type; };
template &lt;typename T&gt; struct remove_reference&lt;T&amp;&gt; { typedef T type; };
template &lt;typename T&gt; struct remove_reference&lt;T&amp;&amp;&gt; { typedef T type; };
</code></pre>
<h4 id="std-is-array"><a href="#std-is-array" class="headerlink" title="std::is_array"></a><code>std::is_array</code></h4><p>可能实现为：</p>
<pre><code class="cpp">template &lt;typename T&gt; struct is_array : std::false_type { };

template &lt;typename T&gt; struct is_array&lt;T[]&gt; : std::true_type { };

template &lt;typename T, std::size_t N&gt; struct is_array&lt;T[N]&gt; : std::true_type { };
</code></pre>
<h4 id="std-rank"><a href="#std-rank" class="headerlink" title="std::rank"></a><code>std::rank</code></h4><p>如果<code>T</code>是数组类型，将对外提供一个为数组维数的member constant value。若<code>T</code>为其他类型，则返回<code>0</code>。<br>可能实现为：</p>
<pre><code class="cpp">template &lt;typename T&gt;
struct rank : public std::integral_constant&lt;std::size_t, 0&gt; { };

template &lt;typename T&gt;
struct rank&lt;T[]&gt; : public std::integral_cosntant&lt;std::size_t, rank&lt;T&gt;::value + 1&gt; { };

template &lt;typename T, std::size_t&gt;
struct rank&lt;T[N]&gt; : public std::integral_constant&lt;std::size_t, rank&lt;T&gt;::value + 1&gt; { };
</code></pre>
<h4 id="std-extent"><a href="#std-extent" class="headerlink" title="std::extent"></a><code>std::extent</code></h4><p>如果<code>T</code>是数组类型，则对外提供一个member constant value，它的值等于该数组第<code>N</code>维的元素个数（前提是<code>N</code>的范围为<code>[0, std::rank&lt;T&gt;::value]</code>。如果<code>T</code>是其他类型，或者是一个第一维大小未知其<code>N</code>为<code>0</code>，则<code>value</code>的大小为<code>0</code>。</p>
<p>可能实现为：</p>
<pre><code class="cpp">//此版本默认是数组第一维的大小（即以为数组的大小）
template &lt;typename T, unsigned N = 0&gt;
struct extent : std::integral_constant&lt;std::size_t, 0&gt; { };

template &lt;typename T&gt;
struct extent&lt;T[], 0&gt; : std::integral_constant&lt;std::size_t&gt; { };

template &lt;typename T, unsigned N&gt;
struct extent&lt;T[], N&gt; : std::extent&lt;T, N-1&gt; { };

template &lt;typename T, std::size_t I&gt;
struct extent&lt;T[N], 0&gt; : std::integral_constant&lt;std::size_t, I&gt; { };

template &lt;typename T, std::size_t I, unsigned N&gt;
struct extent&lt;T[I], N&gt; : std::extent&lt;T, N-1&gt; { };
</code></pre>
<p>例子：</p>
<pre><code class="cpp">int main(){
    std::cout&lt;&lt;std::extent&lt;int[3]&gt;::value&lt;&lt;std::endl;            //3
    std::cout&lt;&lt;std::extent&lt;int[3][4], 1&gt;::value&lt;&lt;std::endl;      //4
    std::cout&lt;&lt;std::extent&lt;int[3][4], 2&gt;::value&lt;&lt;std::endl;   //0
}
</code></pre>
<h4 id="remove-extent"><a href="#remove-extent" class="headerlink" title="remove_extent"></a><code>remove_extent</code></h4><p><strong>对于多维数组，则只移除第一维</strong>，可能实现是：</p>
<pre><code class="cpp">template &lt;typename T&gt;
struct remove_extent { typedef T type; }

template &lt;typename T&gt;
struct remove_extent&lt;T[]&gt; { typedef T type; }

template &lt;typename T, std::size_t N&gt;
struct remove_extent&lt;T[N]&gt; { typedef T type; }
</code></pre>
<p>例子：</p>
<pre><code class="cpp">template &lt;typename T&gt;
typename std::enable_if&lt;std::rank&lt;T&gt;::value==1&gt;::type
print(const T&amp; t){
    std::copy(t,t+std::extent&lt;T&gt;::value,
        std::ostream_iterator&lt;typename std::remove_extent&lt;T&gt;::type&gt;(std::cout,&quot; &quot;));
}

int main(){
    int a[][3]={{1,2,3},{4,5,6}};
    print(a[1]);    //4,5,6
}
</code></pre>
<h3 id="is-convertible"><a href="#is-convertible" class="headerlink" title="is_convertible"></a><code>is_convertible</code></h3><p>原型为：</p>
<pre><code class="cpp">template &lt;typename From, typename To&gt;
struct is_convertible;
</code></pre>
<p>如果<code>To test() { return std::declval&lt;From&gt;(); }</code>为well-formed（合法的，即<code>std::declval&lt;From&gt;</code>能够用隐式转换转换为<code>To</code>，或 <code>From</code>和<code>To</code>均为可有cv-qualified的<code>void</code>），则提供等于<code>true</code>的成员常量<code>value</code>。否则<code>value</code>为<code>false</code>。</p>
<ol>
<li><a href="https://www.boost.org/doc/libs/1_65_0/boost/type_traits/is_convertible.hpp" target="_blank" rel="noopener">boost is_convertible的实现</a></li>
<li><a href="http://rextester.com/discussion/DZAJ63651/is-convertible" target="_blank" rel="noopener">is_convertible简易实现</a></li>
</ol>
<h3 id="std-conditional"><a href="#std-conditional" class="headerlink" title="std::conditional"></a><code>std::conditional</code></h3><p>其可能实现为：</p>
<pre><code class="cpp">template&lt;bool B, class T, class F&gt;
struct conditional { typedef T type; };

template&lt;class T, class F&gt;
struct conditional&lt;false, T, F&gt; { typedef F type; };
</code></pre>
<p>提供成员<code>typedef type</code>，若<code>B</code>在编译时为<code>true</code>则定义为<code>T</code>，或若<code>B</code>为<code>false</code>则定义为<code>F</code>。</p>
<p>例子：</p>
<pre><code class="cpp">int main() {
    typedef std::conditional&lt;true, int, double&gt;::type Type1;
    typedef std::conditional&lt;false, int, double&gt;::type Type2;
    typedef std::conditional&lt;sizeof(int) &gt;= sizeof(double), int, double&gt;::type Type3;

    std::cout &lt;&lt; typeid(Type1).name() &lt;&lt; &#39;\n&#39;;
    std::cout &lt;&lt; typeid(Type2).name() &lt;&lt; &#39;\n&#39;;
    std::cout &lt;&lt; typeid(Type3).name() &lt;&lt; &#39;\n&#39;;
}
/// int 
/// double
/// double
</code></pre>
<p>如何理解以下这段来自<em>utility file for VS 2017</em>的代码（其中<code>_Other1</code>和<code>_Other2</code> 是<code>std::pair</code>构造函数的参数，并利用<code>Other1</code>和<code>Other2</code>来初始化<code>first</code>和<code>second</code> ）：</p>
<pre><code class="cpp"> template&lt;class _Other1,
    class _Other2,
    class = enable_if_t&lt;is_constructible&lt;_Ty1, _Other1&gt;::value
                    &amp;&amp; is_constructible&lt;_Ty2, _Other2&gt;::value&gt;,
    enable_if_t&lt;is_convertible&lt;_Other1, _Ty1&gt;::value
            &amp;&amp; is_convertible&lt;_Other2, _Ty2&gt;::value, int&gt; = 0&gt;
    constexpr pair(pair&lt;_Other1, _Other2&gt;&amp;&amp; _Right)
        _NOEXCEPT_OP((is_nothrow_constructible&lt;_Ty1, _Other1&gt;::value
            &amp;&amp; is_nothrow_constructible&lt;_Ty2, _Other2&gt;::value))
    : first(_STD forward&lt;_Other1&gt;(_Right.first)),
        second(_STD forward&lt;_Other2&gt;(_Right.second))
    {   // construct from moved compatible pair
    }

template&lt;class _Other1,
    class _Other2,
    class = enable_if_t&lt;is_constructible&lt;_Ty1, _Other1&gt;::value
                    &amp;&amp; is_constructible&lt;_Ty2, _Other2&gt;::value&gt;,
    enable_if_t&lt;!is_convertible&lt;_Other1, _Ty1&gt;::value
            || !is_convertible&lt;_Other2, _Ty2&gt;::value, int&gt; = 0&gt;
    constexpr explicit pair(pair&lt;_Other1, _Other2&gt;&amp;&amp; _Right)
        _NOEXCEPT_OP((is_nothrow_constructible&lt;_Ty1, _Other1&gt;::value
            &amp;&amp; is_nothrow_constructible&lt;_Ty2, _Other2&gt;::value))
    : first(_STD forward&lt;_Other1&gt;(_Right.first)),
        second(_STD forward&lt;_Other2&gt;(_Right.second))
    {   // construct from moved compatible pair
    }
</code></pre>
<blockquote>
<p>I think is_constructible is enough, why are we using is_convertible here?</p>
</blockquote>
<p>在这里使用<code>is_convertible</code>的目的是为了处理显示构造（explicit construction）。现在只考虑<code>is_constructible</code>，并试图编写一个wrapper（在这里使用<code>REQUIRES</code>来隐藏想要的任何SFINAE方法）:</p>
<pre><code class="cpp">template &lt;class T&gt;
class wrapper {
public:
    template &lt;class U, REQUIRES(std::is_constructible&lt;T, U&amp;&amp;&gt;::value)&gt;
    wrapper(U&amp;&amp; u) : val(std::forward&lt;U&gt;(u)) { }
private:
    T val;
};
</code></pre>
<p>利用上述代码，可以得到：</p>
<pre><code class="cpp">struct Imp { Imp(int ); };
struct Exp { explicit Exp(int ); };

Imp i = 0; // ok
Exp e = 0; // error
wrapper&lt;Imp&gt; wi = 0; // ok
wrapper&lt;Exp&gt; we = 0; // ok?!?
</code></pre>
<p>我们绝对不希望最后一个能够通过编译，因为这样会破坏了<code>Exp</code>的期望。现在，如果可以从<code>U &amp;&amp;</code>直接初始化<code>T</code>，则<code>is_constructible &lt;T，U &amp;&amp;&gt;</code>为<code>true</code>—如果<code>T(std :: declval &lt;U &amp;&amp;&gt;())</code>是valid expression。</p>
<p>另一方面，<code>is_convertible &lt;U &amp;&amp;，T&gt;</code>检查是否可以从<code>U &amp;&amp;</code>拷贝初始化（copy-initialize）<code>T</code>。 也就是说，如果<code>T copy() { return std :: declval &lt;U &amp;&amp;&gt;(); }</code>是valid。</p>
<p>不同之处在于，如果转换是explicit，则后者不起作用：</p>
<table>
<thead>
<tr>
<th>type</th>
<th style="text-align:center"><code>is_constructible&lt;T, int&gt;</code></th>
<th style="text-align:right"><code>is_convertible&lt;int, T&gt;</code> </th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Impl</code></td>
<td style="text-align:center"><code>true_type</code></td>
<td style="text-align:right"><code>true_type</code> </td>
</tr>
<tr>
<td><code>Exp</code></td>
<td style="text-align:center"><code>true_type</code></td>
<td style="text-align:right"><code>false_type</code></td>
</tr>
</tbody>
</table>
<p>为了正确传播explicitness，我们需要同时使用两个traits—可以从中创建meta-trait：</p>
<pre><code class="cpp">template &lt;class T, class From&gt;
using is_explicitly_constructible = std::integral_constant&lt;bool,
    std::is_constructible&lt;T, From&gt;::value &amp;&amp;
    !std::is_convertible&lt;From, T&gt;::value&gt;;

template &lt;class T, class From&gt;
using is_implicitly_constructible = std::integral_constant&lt;bool,
    std::is_constructible&lt;T, From&gt;::value &amp;&amp;
    std::is_convertible&lt;From, T&gt;::value&gt;;
</code></pre>
<p>由于这两个traits是不重叠的，所以可以编写两个不同的ctor模板，其中一个ctor是显式的，而另一个不是：</p>
<pre><code class="cpp">template &lt;class T&gt;
class wrapper {
public:
    template &lt;class U, REQUIRES(is_explicitly_constructible&lt;T, U&amp;&amp;&gt;::value)&gt;
    explicit wrapper(U&amp;&amp; u) : val(std::forward&lt;U&gt;(u)) { }

    template &lt;class U, REQUIRES(is_implicitly_constructible&lt;T, U&amp;&amp;&gt;::value)&gt;
    wrapper(U&amp;&amp; u) : val(std::forward&lt;U&gt;(u)) { }
private:
    T val;
};
</code></pre>
<p>接下来便可以如我们所愿：</p>
<pre><code class="cpp">wrapper&lt;Imp&gt; wi = 0; // okay, calls non-explicit ctor
wrapper&lt;Exp&gt; we = 0; // error
wrapper&lt;Exp&gt; we2(0); // ok
</code></pre>
<p>扩展：<a href="https://stackoverflow.com/questions/35152818/stdconditional-vs-stdenable-if" target="_blank" rel="noopener">std::conditional vs std::enable_if
</a></p>
<h2 id="std-decay"><a href="#std-decay" class="headerlink" title="std::decay"></a><code>std::decay</code></h2><p>将类型<code>T</code>进行lvalue-to-rvalue，array-to-pointer以及function-to-pointer的隐式转换，移除cv-qualifiers，并对外提供一个<code>typedef type</code>成员：</p>
<ul>
<li>若<code>T</code>为“array of <code>U</code>”或“reference to array of <code>U</code>”类型，则成员<code>typedef type</code>为<code>U*</code>。</li>
<li>否则，若<code>T</code>为function type <code>F</code>或reference to function type，则成员 <code>typedef type</code>为<code>std::add_pointer&lt;F&gt;::type</code>。</li>
<li>否则，成员<code>typedef type</code>为 <code>std::remove_cv&lt;std::remove_reference&lt;T&gt;::type&gt;::type</code>。</li>
</ul>
<p>其可能实现为：</p>
<pre><code class="cpp">template&lt; class T &gt;
struct decay {
private:
    typedef typename std::remove_reference&lt;T&gt;::type U;
public:
    typedef typename std::conditional&lt; 
        std::is_array&lt;U&gt;::value,
        typename std::remove_extent&lt;U&gt;::type*,
        typename std::conditional&lt; 
            std::is_function&lt;U&gt;::value,
            typename std::add_pointer&lt;U&gt;::type,
            typename std::remove_cv&lt;U&gt;::type
        &gt;::type
    &gt;::type type;
};
</code></pre>
<p>例子：</p>
<pre><code class="cpp">template &lt;typename T, typename U&gt;
struct decay_equiv : 
    std::is_same&lt;typename std::decay&lt;T&gt;::type, U&gt;::type { };

int main() {
    std::cout &lt;&lt; std::boolalpha
              &lt;&lt; decay_equiv&lt;int, int&gt;::value &lt;&lt; &#39;\n&#39;
              &lt;&lt; decay_equiv&lt;int&amp;, int&gt;::value &lt;&lt; &#39;\n&#39;
              &lt;&lt; decay_equiv&lt;int&amp;&amp;, int&gt;::value &lt;&lt; &#39;\n&#39;
              &lt;&lt; decay_equiv&lt;const int&amp;, int&gt;::value &lt;&lt; &#39;\n&#39;
              &lt;&lt; decay_equiv&lt;int[2], int*&gt;::value &lt;&lt; &#39;\n&#39;
              &lt;&lt; decay_equiv&lt;int(int), int(*)(int)&gt;::value &lt;&lt; &#39;\n&#39;;
}

///true
///true
///true
///true
///true
///true
</code></pre>
<h2 id="实现tuple"><a href="#实现tuple" class="headerlink" title="实现tuple"></a>实现<code>tuple</code></h2><p>现在实现一个<code>tuple</code>可以使用C++ 11的新特性：variadic template，因为创建一个<code>tuple</code>需要任意数量的类型。首先需要一个class declaration：</p>
<pre><code class="cpp">template &lt;typename...Types&gt;
struct tuple;
</code></pre>
<p>接下来需要考虑的问题是：怎么表示<code>tuple</code>中的元素，即<code>tuple</code>应该具备怎样的成员。一个可靠的想法是让<code>tuple</code>直接继承它自己的types：</p>
<pre><code class="cpp">template &lt;typename...Types&gt;
struct tuple : Types... { };
</code></pre>
<p>但这是一个坏主意，因为：</p>
<ul>
<li>不能从像<code>int</code>、<code>char</code>之类的类型进行继承</li>
<li>不能同时继承同一个类型多次，即利用这种方法，<code>tuple&lt;string, string&gt;</code>是不可能实现的</li>
</ul>
<p>所以，可以从<code>n</code>个类型中获取参数<code>T1，...，Tn</code>，而不是从<code>T1，...，Tn</code>直接继承得到。此时，需要一个wrapper类型，称之为<code>tuple_element</code>。<code>tuple</code>将从<code>tuple_element</code>派生<code>n</code>次。现在只需要考虑如何声明<code>tuple_element</code>。</p>
<pre><code class="cpp">template &lt;typename T&gt;
struct tuple_element {
  T value_;
};
</code></pre>
<p>但应该怎样使得<code>tuple</code>可以从<code>tuple_element</code>派生<code>n</code>次：</p>
<pre><code class="cpp">template &lt;typename... Types&gt;
class tuple : tuple_element&lt;Types&gt;...{ };
</code></pre>
<p>虽然这比直接从<code>T1, …, Tn</code>继承要好，但仍然有问题。因为如果一些types相同，则它依旧无法正常运行。例如实例化一个<code>tuple&lt;int, int&gt;</code>，但不能从<code>tuple_element&lt;int&gt;</code>派生两次。可以使用<strong>添加索引</strong>的方式来消除<code>tuple_element</code>基类的歧义。</p>
<pre><code class="cpp">template &lt;size_t I, typename T&gt;
struct tuple_element {
  T value_;
};
</code></pre>
<p>这样，<code>tuple_element&lt;0, int&gt;</code>与<code>tuple_element&lt;1, int&gt;</code>便不再是相同类型，所以可以同时从这二者派生。现在问题是如何做到这一点：<code>tuple</code>如何从每个<code>tuple_element</code>派生出类型<code>T1，...，Tn</code>以及合适的索引<code>0，...，n-1</code>。现在需要在下面的类中加入什么：</p>
<pre><code class="cpp">template &lt;typename... Types&gt;
class tuple : tuple_element&lt;???, Types&gt;... { };
</code></pre>
<p>现在需要将<code>???</code>占位符更换为参数包<code>size_ts</code>。 如果已经有用户提供的这种参数包便可以执行以下操作：</p>
<pre><code class="cpp">template &lt;size_t... Indices, typename... Types&gt;
class tuple : tuple_element&lt;Indices, Types&gt;... {
};
</code></pre>
<p>如果<code>Indices</code>和<code>Types</code>是不同长度的参数包怎么办？这将造成编译错误。但如果两个参数包具有相同的长度，则包扩展运算符（pack expansion operator）（<code>...</code>）将使用index和type成功扩展每个<code>tuple_element</code>基类。  可以如下使用此类：</p>
<pre><code class="cpp">tuple&lt;0, 1, int, string&gt; tup;
</code></pre>
<p>现在需要自己提供索引（indices）。首先，将<code>tuple</code>类与indices分离—不希望用户看到额外所需的模板参数：</p>
<pre><code class="cpp">template &lt;size_t... Indices, typename... Types&gt;
struct tuple_impl : tuple_element&lt;Indices, Types&gt;...
{
};

template &lt;typename... Types&gt;
class tuple : tuple_impl&lt;???, Types...&gt;
{
};
</code></pre>
<p><code>tuple</code>类应该怎样为所有indices提供<code>tuple_impl</code>？ 首先要引入一些辅助类（supporting types）。 先从最简单的开始：</p>
<pre><code class="cpp">template &lt;size_t... Indices&gt;
struct index_sequence {
  using type = index_sequence&lt;Indices...&gt;;
};
</code></pre>
<p><code>index_sequence</code>只不过是一个封装了<code>size_t</code>参数包的类型（注：<code>index_sequence</code>和其他supporting types已经成为C++ 14标准）。<br>现在应该解决如何使用它，如何从sequence中提取出indices的问题。即要如何编写一个拥有<code>index_sequence</code>并打印序列（sequence）中所有整数的函数？以下是一个解决方案：</p>
<pre><code class="cpp">void f(size_t s) { cout &lt;&lt; s &lt;&lt; &#39;\n&#39;; }

template &lt;size_t... Indices&gt;
void g(index_sequence&lt;Indices...&gt;) {
  int ignore[] { 
      (f(Indices), 0)... 
  };
  (void) ignore; // silence compiler warnings about the unused local variable
}

g(index_sequence&lt;1, 2, 3, 4, 5&gt;{});
</code></pre>
<p>在上述代码中，函数<code>f</code>只print一个<code>size_t</code>元素。 接下来，函数<code>g</code>需要一系列索引（注意：该参数没有名称—实际上并不关心它的名称。 它只是一种将数据导入函数的方法，而有用的数据在参数包中）。 在<code>g</code>里面我们想为每个索引调用<code>f</code>。然而不幸的是，它不支持如下所示的的naked expansion：</p>
<pre><code class="cpp">f(Indices)...;
</code></pre>
<p>这就是为什么不得不使用奇怪的解决方法：用扩展的逗号表达式<code>(f(Indices),0)</code>声明了一个local array。 当用<code>Indices = [1,2,3]</code>调用<code>g</code>时，该表达式扩展为<code>(f(1),0)，(f(2),0)，(f(3),0)</code>。 以逗号分隔的<code>0</code>列表进入local array。最后，在调用<code>g</code>时，用户只需提供<code>index_sequence</code>的实例即可。 编译器从实例中推断出<code>Indices</code>参数包。 但是应该如何使用这种技术，以便能够从<code>tuple_element</code>派生出每个index？</p>
<p>现在需要一个拥有三种类型（<code>T0</code>，<code>T1</code>，<code>T2</code>）的<code>tuple</code>。可以使用如下的代码：</p>
<pre><code class="cpp">template &lt;typename T0, typename T1, typename T2&gt;
class tuple : tuple_impl&lt;0, 1, 2, T0, T1, T2&gt; {

};
</code></pre>
<p>对于三种类型来说非常好，但是当给定类型参数包（<code>typename ... Types</code>）时，应该如何使索引出现在列表中？ 可以尝试将<code>index_sequence</code>集成进来，重写<code>tuple_impl</code>：</p>
<pre><code class="cpp">template &lt;typename Sequence, typename... Types&gt;
struct tuple_impl; // undefined base; parameters are named for clarity only

template &lt;size_t... Indices, typename... Types&gt;
struct tuple_impl&lt;index_sequence&lt;Indices...&gt;, Types...&gt;
  : tuple_element&lt;Indices, Types&gt;... {
};
</code></pre>
<p> 第二个<code>tuple_impl</code>是模板特化，其参数共两个：参数包<code>...Indices</code>和类型参数<code>…Types</code>，此特化版本匹配<code>Sequence = index_sequence</code>的情况。 </p>
<p>现在需要一个拥有三种类型（<code>T0</code>，<code>T1</code>，<code>T2</code>）的<code>tuple</code>，可以做以下事情：</p>
<pre><code class="cpp">template &lt;typename T0, typename T1, typename T2&gt;
class tuple : tuple_impl&lt;index_sequence&lt;0, 1, 2&gt;, T0, T1, T2&gt; {

};
</code></pre>
<p>现在，当用<code>n</code>个types实例化<code>tuple</code>时，只需要使用<code>index_sequence &lt;0，...，n-1&gt;</code>，而不必使用任意索引序列（arbitrary sequence of indices），称之为<code>make_index_sequence</code>（它是一个meta-function，也就是说，<code>make_index_sequence::type</code>将成为<code>index_sequence &lt;0，...，n-1&gt;</code>的别名（alias），<code>using type = index_sequence &lt;0，...，n-1</code> ）。</p>
<p>实现<code>make_index_sequence</code>：</p>
<pre><code class="cpp">template &lt;size_t I, typename Sequence&gt;
struct cat_index_sequence;

template &lt;size_t I, size_t... Indices&gt;
struct cat_index_sequence&lt;I, index_sequence&lt;Indices...&gt;&gt;
  : index_sequence&lt;Indices..., I&gt;
{
};

template &lt;size_t N&gt;
struct make_index_sequence
  : cat_index_sequence&lt;N-1, typename make_index_sequence&lt;N-1&gt;::type&gt;::type
{
};

template &lt;&gt;
struct make_index_sequence&lt;1&gt; : index_sequence&lt;0&gt; {};
</code></pre>
<p><code>cat_index_sequence</code>是一个meta-function，它将index添加到当前索引序列的末尾，然后递归地将元素添加到增长的索引序列的末尾，以此来定义<code>make_index_sequence</code>元。 递归条件为<code>make_index_sequence &lt;1&gt;</code>，即<code>index_sequence &lt;0&gt;</code>。</p>
<p>此时重复<code>tuple_element</code>和<code>tuple_impl</code>的定义，只是为了让整个事情更加清晰：</p>
<pre><code class="cpp">template &lt;size_t, typename T&gt;
struct tuple_element
{
  T value_;
};

template &lt;typename Sequences, typename... Types&gt;
struct tuple_impl; // undefined base; parameters are named for clarity only

template &lt;size_t... Indices, typename... Types&gt;
struct tuple_impl&lt;index_sequence&lt;Indices...&gt;, Types...&gt;
  : tuple_element&lt;Indices, Types&gt;...
{
};

template &lt;typename... Types&gt;
class tuple
  : tuple_impl&lt;typename make_index_sequence&lt;sizeof...(Types)&gt;::type, Types...&gt;
{
};
</code></pre>
<p><code>sizeof...(Types)</code>是<code>tuple</code>中元素的数量（<code>n</code>），<code>make_index_sequence</code>生成<code>index_sequence&lt;0,1，...，n-1&gt;</code>，用索引实例化<code>tuple_impl</code>，以便它可以为每个索引从<code>tuple_element</code>进行派生。</p>
<p>此时，当使用<code>tuple&lt;int,string,float&gt;时</code>，将得到一个派生自<code>tuple_impl&lt;index_sequence&lt;0,1,2&gt;,int,string,float&gt;</code>的类型，后者又从<code>tuple_element&lt;0,int&gt;</code>，<code>tuple_element &lt;1,string&gt;</code>和<code>tuple_element&lt;2,float&gt;</code>派生。</p>
<p>接下来需要解决<code>tuple</code>对象的构造问题，即需要向<code>tuple_element</code>添加一些操作使其变得更有用。 例如可以根据它的值类型（value type）来构造它：</p>
<pre><code class="cpp">explicit tuple_element(T const&amp; value) : value_(value) {}
explicit tuple_element(T&amp;&amp; value) : value_(std::move(value)) {}
</code></pre>
<p>现在为<code>tuple</code>类创建一些基本操作（fundamental operations），以便可以更加简易地创建<code>tuple</code>。 需要定义下列操作：</p>
<ol>
<li>默认构造函数（default ctor）</li>
<li>拷贝构造函数（copy ctor）</li>
<li>移动构造函数（move ctor）</li>
<li>拷贝赋值运算符（copy assignment operator）</li>
<li>移动赋值运算符（move assignment operator）</li>
</ol>
<pre><code class="cpp">tuple() = default;
tuple(tuple const&amp;) = default;
tuple(tuple&amp;&amp;) = default;
tuple&amp; operator=(tuple const&amp; rhs) = default;
tuple&amp; operator=(tuple&amp;&amp;) = default;
</code></pre>
<p>对于<code>n</code>个类型的<code>tuple</code>，它需要<code>n</code>个元素并初始化该<code>tuple</code>，即按照如下的方式使用它：</p>
<pre><code class="cpp">tuple&lt;int, float&gt; t1(3, 3.14f);                 // exact match
tuple&lt;long long, double&gt; t2(3, 3.14f);  // widening conversions
tuple&lt;string&gt; t3(&quot;Hello, World&quot;);            // string construction from char const[]
</code></pre>
<p>显然，可以将这个构造函数写成一个template。 此外，它将采用万能引用（universal reference）—希望它支持lvalue和rvalue并实现完美转发（perfect forwarding）。</p>
<pre><code class="cpp">using base_t = tuple_impl&lt;typename make_index_sequence&lt;sizeof...(Types)&gt;::type, Types...&gt;;

template &lt;typename... OtherTypes&gt;
explicit tuple(OtherTypes&amp;&amp;... elements)
  : base_t(std::forward&lt;OtherTypes&gt;(elements)...)
{
}
</code></pre>
<p><code>tuple</code>对其元素的存储方式一无所知。 因此，它只是将参数转发（forward）给<code>tuple_impl</code>，而<code>tuple_impl</code>又需要将参数转发到其<code>tuple_element</code>基类。 </p>
<pre><code class="cpp">template &lt;typename... OtherTypes&gt;
explicit tuple_impl(OtherTypes&amp;&amp;... elements)
  : tuple_element&lt;Indices, Types&gt;(std::forward&lt;OtherTypes&gt;(elements))...
{
}
</code></pre>
<p>现在希望用base ctor调用参数包中的每个元素展开形式：<code>tuple_impl&lt;N, T&gt;(std::forward&lt;U&gt;(e))</code>。 这要求<code>...Indices, ...Types</code>和<code>...OtherTypes</code>参数包都具有相同的长度（否则会出现编译错误）。此外还需要在一些重载决议（overload management）中进行throw，以便在参数数量出错时不考虑这些构造函数：</p>
<pre><code class="cpp">template &lt;typename... OtherTypes,
          typename = typename std::enable_if&lt;
            sizeof...(OtherTypes) == sizeof...(Types)&gt;::type&gt;
explicit tuple(OtherTypes&amp;&amp;... elements)
  : base_t(std::forward&lt;OtherTypes&gt;(elements)...)
{
}
// and the same thing applies to tuple_impl&#39;s constructor
</code></pre>
<p>但上述代码有可能造成极其危险的后果。 对于单元素（single-element）<code>tuple</code>，此构造函数极有可能会影响拷贝构造函数。 考虑以下示例：</p>
<pre><code class="cpp">tuple&lt;int&gt; t1(3);  // good, construct from rvalue int
tuple&lt;int&gt; t2(t1); // which constructor are we calling?
</code></pre>
<p>也许令人惊讶的是，第二行将使用<code>OtherTypes = tuple&lt;int&gt;＆</code>调用模板构造函数（template ctor），它比拷贝构造函数（它采用<code>tuple &lt;int&gt; const＆</code>）以及移动构造函数（它采用<code>tuple&lt;int&gt;&amp;&amp;</code>）能够更好地进行匹配。所以我们试图用<code>OtherTypes = tuple&lt;int&gt;＆</code>来调用<code>tuple_impl</code>的构造函数，它反过来试图用<code>tuple &lt;int&gt;＆</code>来调用<code>tuple_element &lt;0, int&gt;</code>的构造函数，它会毫不意外地失败。解决办法是可以为<code>tuple_element</code>添加一个通用构造函数（universal ctor）：</p>
<pre><code class="cpp">template &lt;typename U&gt;
explicit tuple_element(U&amp;&amp; value) : value_(std::forward&lt;U&gt;(value)) {}
</code></pre>
<p>但它其实没什么用—如果仍然用<code>tuple &lt;int&gt;＆</code>来初始化<code>tuple_element&lt;0，int&gt;</code>，则意味着<code>tuple&lt;int&gt;＆</code>将被用来初始化<code>int(tuple_element&lt;0, int&gt;::value_)</code> 。</p>
<p>为了避免这种状况发生，需要再添加一些重载决议的逻辑。 简而言之，当处理的元素不是<code>tuple</code>时，则希望<code>tuple</code>的通用构造函数（universal ctor）能够reject tuples。 更重要的是，希望<code>tuple&lt;short&gt;</code>可以通过拷贝构造得到<code>tuple &lt;int&gt;</code>（这两者是不同的类型）：</p>
<pre><code class="cpp">template &lt;typename... OtherTypes&gt;
explicit tuple(tuple&lt;OtherTypes...&gt; const&amp; rhs) : base_t(rhs) {}

template &lt;typename... OtherTypes&gt;
explicit tuple(tuple&lt;OtherTypes...&gt;&amp;&amp; rhs) : base_t(std::move(rhs)) {}
</code></pre>
<p>This seems to further complicate things, because tuple_impl‘s constructor can now be called with its “home” tuple, tuples of some other types, and naked lists of the tuple’s elements.Here’s how we can fix this. The key problem lies within tuple_impl. It has to be able to tell other tuple_impl‘s (which represent copy/move construction) from anything else, which should be used to initialize the tuple_element‘s directly.</p>
<p>现在实现一个返回<code>bool</code>值的meta-function <code>is_tuple_impl &lt;T&gt;</code>，它用于判断<code>T</code>是否为<code>tuple_impl</code>。</p>
<pre><code class="cpp">template &lt;typename&gt;
struct is_tuple_impl
  : std::false_type {};

template &lt;size_t... Indices, typename... Types&gt;
struct is_tuple_impl&lt;tuple_impl&lt;index_sequence&lt;Indices...&gt;, Types...&gt;&gt;
  : std::true_type {};
</code></pre>
<p>有了这个meta-function，就可以去除<code>tuple_impl</code>的通用构造函数了。本质上，如果类型参数包中的元素的类型符合<code>is_tuple_impl</code>，则希望从重载集中删除构造函数（overload set）。</p>
<p>实现返回<code>bool</code>值的meta-function <code>is_any_of &lt;Op, ...Types&gt;</code>，它确定类型参数包<code>…Types</code>中的任意类型<code>T</code>是否满足<code>Op &lt;T&gt;::value == true</code>(注意，<code>Op</code>必须是template template parameter）。</p>
<p>现在使用<code>constexpr</code>函数来改进它，而不是使用无聊的<code>false_type</code>/<code>true_type</code>类：</p>
<pre><code class="cpp">template &lt;template &lt;class&gt; typename&gt;
constexpr bool is_any_of()
{
  return false;
}

template &lt;template &lt;class&gt; typename Op, typename Head, typename... Tail&gt;
constexpr bool is_any_of()
{
  return Op&lt;Head&gt;::value || is_any_of&lt;Op, Tail...&gt;();
}
</code></pre>
<p>对于使用<code>is_any_of&lt;is_tuple_impl, ...&gt;()</code>的类型列表而言，将获得一个编译时（compile-time）布尔值，用于表示这些类型中是否存在<code>tuple_impl</code>。 现在进行重载决议：</p>
<pre><code class="cpp">template &lt;typename... OtherTypes,
          typename = typename std::enable_if&lt;
            !is_any_of&lt;is_tuple_impl, typename std::decay&lt;OtherTypes&gt;::type...&gt;()
          &gt;::type
         &gt;
explicit tuple_impl(OtherTypes&amp;&amp;... elements)
  : tuple_impl&lt;Indices, Types&gt;(std::forward&lt;OtherTypes&gt;(elements))...
{
}
</code></pre>
<p>此处需要使用<code>std::decay</code>的原因：例如，如果使用lvalue <code>tuple_impl</code>进行调用，则<code>OtherTypes</code>可能包含<code>tuple_impl＆</code>。除非将<code>&amp;</code>删除，否则将被<code>is_tuple_impl</code> reject。</p>
<p>虽然拥有了一个可构造的<code>tuple</code>（constructible tuple）之后，但是没有办法通过索引或任何其他方式获取<code>tuple</code>中的元素。现在需要实现主访问器（main accessor）：<code>get&lt;&gt;</code>，用来读取和编写<code>tuple</code>中的元素。 <code>get&lt;&gt;</code>模板的实现有两种方式：</p>
<ul>
<li>get by index </li>
<li>get by type</li>
</ul>
<p>后者是自C ++ 14以来<code>tuple</code> interface的一部分。可以根据前者来实现后者。以下是<code>get&lt;&gt;</code>所需的重载：</p>
<pre><code class="cpp">template &lt;size_t I, typename... Types&gt;
??? get(tuple&lt;Types...&gt; const&amp; tup);

template &lt;size_t I, typename... Types&gt;
??? get(tuple&lt;Types...&gt;&amp; tup);

template &lt;size_t I, typename... Types&gt;
??? get(tuple&lt;Types...&gt;&amp;&amp; tup);
</code></pre>
<p>很明显，上述三个函数的返回类型和内容都非常相似，只需要确定它们的返回类型应该是什么。</p>
<p>实现meta-function <code>type_at_index&lt;I, Types...&gt;</code>，它的返回类型参数包<code>...Types</code>中第<code>1</code>个元素的类型。利用可变参数模板递归实现：</p>
<pre><code class="cpp">template &lt;size_t I, typename Head, typename... Tail&gt;
struct type_at_index
{
  using type = typename type_at_index&lt;I-1, Tail...&gt;::type;
};

template &lt;typename Head, typename... Tail&gt;
struct type_at_index&lt;0, Head, Tail...&gt;
{
  using type = Head;
};

template &lt;size_t I, typename... Types&gt;
using type_at_index_t = typename type_at_index&lt;I, Types...&gt;::type;
Great. We can now fill in the return types:

template &lt;size_t I, typename... Types&gt;
type_at_index_t&lt;I, Types...&gt; const&amp; get(tuple&lt;Types...&gt; const&amp; tup);

template &lt;size_t I, typename... Types&gt;
type_at_index_t&lt;I, Types...&gt;&amp; get(tuple&lt;Types...&gt;&amp; tup);

template &lt;size_t I, typename... Types&gt;
type_at_index_t&lt;I, Types...&gt;&amp;&amp; get(tuple&lt;Types...&gt;&amp;&amp; tup);
</code></pre>
<p>现在填写返回类型：</p>
<pre><code class="cpp">template &lt;size_t I, typename... Types&gt;
type_at_index_t&lt;I, Types...&gt; const&amp; get(tuple&lt;Types...&gt; const&amp; tup);

template &lt;size_t I, typename... Types&gt;
type_at_index_t&lt;I, Types...&gt;&amp; get(tuple&lt;Types...&gt;&amp; tup);

template &lt;size_t I, typename... Types&gt;
type_at_index_t&lt;I, Types...&gt;&amp;&amp; get(tuple&lt;Types...&gt;&amp;&amp; tup);
</code></pre>
<p>但是第三个声明是错误的。 如果<code>type_at_index</code>返回一个左值引用类型（lvalue reference type），那么返回类型也将是一个左值引用，因为引用折叠（reference collapsing）会将<code>&amp;&amp;&amp;</code>变为<code>＆</code>。 例如：</p>
<pre><code class="cpp">int x = 42;
tuple&lt;int&amp;&gt; t(x);
get&lt;0&gt;(std::move(t));    // returns int&amp;
</code></pre>
<p>这很容易解决：只需要删除引用修饰符（reference qualifier）<code>&amp;</code>：</p>
<pre><code class="cpp">template &lt;size_t I, typename... Types&gt;
std::remove_reference_t&lt;type_at_index_t&lt;I, Types...&gt;&gt;&amp;&amp; get(tuple&lt;Types...&gt;&amp;&amp; tup);
</code></pre>
<p>好的，现在这些方法的主体怎么样？ 从一开始就设计了<code>tuple</code>，以简化实现，然后<code>tuple_element</code>也已经已经注入索引，所以只需要将<code>tuple</code>实例强制转换为适当的基类，然后提取<code>value</code>字段即可。 例如：</p>
<pre><code class="cpp">template &lt;size_t I, typename... Types&gt;
type_at_index&lt;I, Types...&gt;&amp; get(tuple&lt;Types...&gt;&amp; tup)
{
  tuple_element&lt;I, type_at_index_t&lt;I, Types...&gt;&gt;&amp; base = tup;
  return base.value_;
}
</code></pre>
<p>另外两种方法显然相似。 现在让我们来看看另一种<code>get</code>—<code>get&lt;T&gt;</code>。 它需要验证类型在<code>tuple</code>中只出现一次，并返回该的元素。例如：</p>
<pre><code class="cpp">tuple&lt;int, string&gt; t1;
get&lt;int&gt;(t1) = 42;
get&lt;float&gt;(t1) = 3.14f;    // compilation error

tuple&lt;int, int&gt; t2;
get&lt;int&gt;(t2) = 42;    // compilation error
</code></pre>
<p>基本方法如下：计算<code>T</code>出现在<code>tuple</code>中的次数。 如果次数不是<code>1</code>，则throw编译错误。 否则，找到类型为<code>T</code>时的索引<code>I</code>并调用<code>get&lt;I&gt;</code>。 此时将再次使用<code>constexpr</code>函数进行大部分工作，因为它比使用struct更容易，更优雅：</p>
<pre><code class="cpp">template &lt;typename&gt;
constexpr int count()
{
  return 0;
}
template &lt;typename T, typename Head, typename... Tail&gt;
constexpr int count()
{
  return (std::is_same&lt;T, Head&gt;::value ? 1 : 0) + count&lt;T, Tail...&gt;();
}

template &lt;typename&gt;
constexpr int find(int)
{
  return -1;
}
template &lt;typename T, typename Head, typename... Tail&gt;
constexpr int find(int current_index = 0)
{
  return std::is_same&lt;T, Head&gt;::value
    ? current_index
    : find&lt;T, Tail...&gt;(current_index + 1);
}

template &lt;typename T, typename... Types&gt;
T&amp; get(tuple&lt;Types...&gt;&amp; tup)
{
  static_assert(count&lt;T, Types...&gt;() == 1, &quot;T must appear exactly once in ...Types&quot;);
  get&lt;find&lt;T, Types...&gt;()&gt;(tup);
}
</code></pre>
<p>此外，还可以在<code>tuple</code>类上实现一些额外的功能，例如：</p>
<ul>
<li>Copy and move assignment operators from tuple</li>
<li>Comparison operators: ==, !=, &lt;, &lt;=, &gt;, &gt;=</li>
<li>Tuple construction from <code>std::pair</code> and <code>std::array</code></li>
</ul>
<p>接下来实现一些<code>tuple</code>非成员函数和helpers。首先，实现一个非常简单的helper：<code>tuple_size</code>， 它是一个返回<code>tuple</code>中元素数量的元函数。</p>
<pre><code class="cpp">template &lt;typename&gt;
struct tuple_size; // undefined base template

template &lt;typename... Types&gt;
struct tuple_size&lt;tuple&lt;Types...&gt;&gt; : std::integral_constant&lt;size_t, sizeof...(Types)&gt; {

};
</code></pre>
<p>接着实现<code>forward_as_tuple</code>。Basic idea：提供一组元素，并且根据元素的值类别（value categories，即lavalue、rvalue等）返回具有左值或右值引用的<code>tuple</code>。 例如：</p>
<pre><code class="cpp">string s, t;
auto t1 = forward_as_tuple(s, t);       // t1 is tuple&lt;string&amp;, string&amp;&gt;
auto t2 = forward_as_tuple(move(s), t); // t2 is tuple&lt;string&amp;&amp;, string&amp;&gt;
</code></pre>
<p><code>forward_as_tuple</code>的实现：</p>
<pre><code class="cpp">template &lt;typename... Types&gt; 
tuple&lt;Types&amp;&amp;...&gt; forward_as_tuple(Types&amp;&amp;... elements)
{
  return tuple&lt;Types&amp;&amp;...&gt;(std::forward&lt;Types&gt;(elements)...);
}
</code></pre>
<p>接下来实现<code>tie</code>， 它是一个非常有用的helper，可以将<code>tuple</code>绑定到单个变量上。 例如（第二个例子假设<code>tuple</code>有一个接受<code>std::pair</code>的赋值运算符）：</p>
<pre><code class="cpp">int status_code; 
string status;
tie(status_code, status) = make_http_request(url); // returns tuple&lt;int, string&gt;

set&lt;string&gt; names;
bool inserted; 
set&lt;string&gt;::iterator iter;
tie(inserted, iter)   = names.insert(&quot;Sasha&quot;);
tie(inserted, ignore) = names.insert(&quot;Sasha&quot;); // assigns only to &#39;inserted&#39;
</code></pre>
<p>实现<code>tie</code>函数虽然看起来很难，其实只是创建一个带左值引用的<code>tuple</code>的问题！ 然后，这些引用可以由赋值运算符进行赋值。 </p>
<pre><code class="cpp">template  &lt;typename... Types&gt;
tuple&lt;Types&amp;...&gt; tie(Types&amp;... elements)
{
  return tuple&lt;Types&amp;...&gt;(elements...);
}
</code></pre>
<p>“ignore”用于简化类型实例，它可以忽略任何赋值尝试：</p>
<pre><code class="cpp">struct ignore_t {
  template &lt;typename U&gt;
  ignore_t&amp; operator=(U&amp;&amp;) {
    return *this;
  }
} ignore;
</code></pre>
<p>最后，需要实现<code>make_tuple</code>，它将一组元素打包成一个<code>tuple</code>（需要注意<code>make_tuple</code>如何对待<code>std::reference_wrapper</code>）。</p>
<p>实现<code>tuple_cat</code>，它将用于连接任意数量的元组。 例子：</p>
<pre><code class="cpp">auto t1 = tuple_cat(make_tuple(1), make_tuple(2)); // tuple&lt;int, int&gt;(1, 2)
auto t2 = tuple_cat(t1, make_tuple(3), make_tuple(4));
auto t3 = tuple_cat(t1, t1, t2, t2);
// t3 is a tuple of 12 ints: 1, 2, 1, 2, 1, 2, 3, 4, 1, 2, 3, 4
</code></pre>
<p>显然，<code>tuple_cat</code>是一个variadic function template。 <code>tuple</code>本身是一个variadic class template，现在需要尝试构建一个variadic function template，用于获取任意数量的variadic class template。先尝试解决一个简单的问题：给定一个元组，应该怎样调用一个接受所有<code>tuple</code>元素的函数？</p>
<p>编写一个函数<code>explode</code>，它接受任意长度的<code>tuple</code>并将其所有元素传递给另一个函数<code>f</code>。基本的想法是使用<code>index_sequence</code>。对于大小为<code>n</code>的<code>tuple</code>，需要生成<code>index_sequence&lt;0,1，...，n-1&gt;</code>。 然后，<code>index_sequence</code>的索引可以与<code>get&lt;I&gt;</code>函数一起使用，提取<code>tuple</code>中的元素。 由于不需要访问<code>tuple</code>的类型，因此可以简单地使用万能引用（universal reference），它可以简化代码并正确转发rvalue <code>tuple</code>：</p>
<pre><code class="cpp">template &lt;typename Tuple, size_t... Indices&gt;
void explode1(Tuple&amp;&amp; tup, index_sequence&lt;Indices...&gt;) {
  f(get&lt;Indices&gt;(std::forward&lt;Tuple&gt;(tup))...);
}

template &lt;typename Tuple&gt;
void explode(Tuple&amp;&amp; tup) {
  explode1(
    std::forward&lt;Tuple&gt;(tup),
    make_index_sequence&lt;tuple_size&lt;std::decay_t&lt;Tuple&gt;&gt;::value&gt;{}
  );
}
</code></pre>
<p>然而，<code>index_sequence</code>再次罢工！关键是调用<code>get&lt;Indices&gt;(tup)...</code>，它将扩展为<code>get</code>：<code>get&lt;0&gt;(tup), get&lt;1&gt;(tup), ..., get&lt;n-1&gt;(tup)</code>的多个调用，其中<code>n</code>是<code>tuple</code>的大小。 现在，如果有两个<code>tuple</code>，并且<code>f</code>被称为<code>make_tuple</code> 怎么办？</p>
<p>编写一个简化版本的<code>tuple_cat</code>，它连接两个<code>tuple</code>。</p>
<pre><code class="cpp">template &lt;typename Tuple1, size_t... Indices1, typename Tuple2, size_t... Indices2&gt;
auto tuple_cat1(Tuple1&amp;&amp; tup1, Tuple2&amp;&amp; tup2,
                index_sequence&lt;Indices1...&gt;, index_sequence&lt;Indices2...&gt;) {
  return make_tuple(
    get&lt;Indices1&gt;(std::forward&lt;Tuple1&gt;(tup1))...,
    get&lt;Indices2&gt;(std::forward&lt;Tuple2&gt;(tup2))...
  );
}

template &lt;typename Tuple1, typename Tuple2&gt;
auto tuple_cat(Tuple1&amp;&amp; tup1, Tuple2&amp;&amp; tup2) {
  tuple_cat1(
   std::forward&lt;Tuple1&gt;(tup1),
   std::forward&lt;Tuple2&gt;(tup2),
   make_index_sequence&lt;tuple_size&lt;std::decay_t&lt;Tuple1&gt;&gt;::value&gt;{},
   make_index_sequence&lt;tuple_size&lt;std::decay_t&lt;Tuple2&gt;&gt;::value&gt;{}
  );
}
</code></pre>
<p>因此，基本思想是调用<code>make_tuple</code>，并将两个<code>tuple</code>的元素作为其参数进行展开。 这两个参数包<code>…Indices1</code>和<code>…Indices2</code>有助于扩展每个单独的<code>tuple</code>。</p>
<pre><code class="cpp">template &lt;size_t, typename&gt;
struct type_at_tuple; // undefined base template

template &lt;size_t I, typename... Types&gt;
struct type_at_tuple&lt;I, tuple&lt;Types...&gt;&gt; : type_at_index&lt;I, Types...&gt;
{
};

template &lt;typename, typename, typename, typename&gt;
struct cat1_t; // undefined base template

template &lt;typename Tuple1, size_t... Indices1, typename Tuple2, size_t... Indices2&gt;
struct cat1_t&lt;
  Tuple1, index_sequence&lt;Indices1...&gt;,
  Tuple2, index_sequence&lt;Indices2...&gt;
&gt; {
  using type = tuple&lt;
    typename type_at_tuple&lt;Indices1, Tuple1&gt;::type...,
    typename type_at_tuple&lt;Indices2, Tuple2&gt;::type...
  &gt;;
};

template &lt;typename Tuple1, typename Tuple2&gt;
struct cat_t {
  static constexpr size_t Size1 = tuple_size&lt;std::decay_t&lt;Tuple1&gt;&gt;::value;
  static constexpr size_t Size2 = tuple_size&lt;std::decay_t&lt;Tuple2&gt;&gt;::value;
  using Seq1 = typename make_index_sequence&lt;Size1&gt;::type;
  using Seq2 = typename make_index_sequence&lt;Size2&gt;::type;
  using type = typename cat1_t&lt;Tuple1, Seq1, Tuple2, Seq2&gt;::type;
};
</code></pre>
<p>现在可以用<code>typename cat_t&lt;Tuple1, Tuple2&gt;::type</code>作为<code>tuple_cat</code>的返回类型（如果编译器不支持C++ 14，则可以用这种方式）。</p>
<p>实现通用版本的<code>tuple_cat</code>，用于连接任意数量的<code>tuple</code>（假设前一个示例中的<code>tuple_cat</code>仍然存在，并连接两个<code>tuple</code>。现在将其重命名为<code>tuple_cat2</code>，并递归地使用它：）：</p>
<pre><code class="cpp">template &lt;typename HeadTuple&gt;
HeadTuple&amp;&amp; tuple_cat(HeadTuple&amp;&amp; tup) {
  return std::forward&lt;HeadTuple&gt;(tup);
}

template &lt;typename Head1Tuple, typename Head2Tuple, typename... TailTuples&gt;
auto tuple_cat(Head1Tuple&amp;&amp; tup1, Head2Tuple&amp;&amp; tup2, TailTuples&amp;&amp;... tail) {
  return tuple_cat(
    tuple_cat2(
      std::forward&lt;Head1Tuple&gt;(tup1),
      std::forward&lt;Head2Tuple&gt;(tup2)
    ),
    std::forward&lt;TailTuples&gt;(tail)...
  );
}
</code></pre>
<p>如果当前编译器不支持C++ 14，则可以用<code>cat_t</code>模板来支持任意数量的<code>tuple</code>。</p>
<pre><code class="cpp">template &lt;typename, typename&gt;
struct cat_two_t; // undefined base template

template &lt;typename... Types1, typename... Types2&gt;
struct cat_two_t&lt;tuple&lt;Types1...&gt;, tuple&lt;Types2...&gt;&gt; {
  using type = tuple&lt;Types1..., Types2...&gt;;
};

template &lt;typename...&gt;
struct cat_many_t; // undefined base template

template &lt;typename Tuple&gt;
struct cat_many_t&lt;Tuple&gt; {
  using type = Tuple;
};

template &lt;typename Tuple1, typename Tuple2, typename... Tuples&gt;
struct cat_many_t&lt;Tuple1, Tuple2, Tuples...&gt; {
  using two_t = typename cat_two_t&lt;Tuple1, Tuple2&gt;::type;
  using type = typename cat_many_t&lt;two_t, Tuples...&gt;::type;
};
</code></pre>
<p>扩展：<a href="http://blogs.microsoft.co.il/sasha/2015/02/22/implementing-tuple-part-7/" target="_blank" rel="noopener">Implementing std::tuple From The Ground Up: Part 7, tuple_cat Take 2</a></p>
<h2 id="CRTP"><a href="#CRTP" class="headerlink" title="CRTP"></a>CRTP</h2><p>curiously recurring template pattern：把派生类作为基类的模板参数。其实质就是一种静态多态。</p>
<p><strong>特点：</strong></p>
<ul>
<li>继承自template class</li>
<li>使用派生类作为模板参数来特化基类</li>
</ul>
<p><strong>CRTP模板：</strong></p>
<pre><code class="cpp">template &lt;typename T&gt;
class Base {
    ...
};
// use the derived class itself as a template parameter of the base class

class Derived : public Base&lt;Derived&gt; {
    ...
};
</code></pre>
<p>上述代码的目的是：<strong>在基类中使用派生类，从基类的角度看，派生类其实也是基类（通过向下转型做到）。故可以通过<code>static_cast</code>把基类转换到派生类，从而使用派生类的成员</strong>。<br>形式如下：</p>
<pre><code class="cpp">template &lt;typename T&gt;
class Base {
public:
    void doWhat() {
        T&amp; derived = static_cast&lt;T&amp;&gt;(*this);
        // use derived...
    }
};
</code></pre>
<p><strong>注意:</strong> 这里不使用<code>dynamic_cast</code>是因为<code>dynamic_cast</code>一般是为了确保在运行期(run-time)时进行转换的正确性。CRTP的设计的目的是为了<strong>将派生类作为基类的模板参数（the Base class is designed to be inherited from by its template parameter）</strong>，此外再无他求。因此使用<code>static_cast</code>便足矣。</p>
<h3 id="1-易错点"><a href="#1-易错点" class="headerlink" title="1. 易错点"></a>1. 易错点</h3><p>当两个类继承自同一个CRTP 基类时，如下代码所示时将会出现错误（<code>Derived2</code>派生的基类模板参数应该为<code>Derived2</code>）：</p>
<pre><code class="cpp">class Derived1 : public Base&lt;Derived1&gt; {
    ...
};
class Derived2 : public Base&lt;Derived1&gt;  {// bug in this line of code
    ...
};
</code></pre>
<p>为了防止种错误的出现，可以写成如下的代码形式：</p>
<pre><code class="cpp">template &lt;typename T&gt;
class Base {
public:
    // ...
private:// import 
    Base(){};
    friend T;
};
</code></pre>
<p>解决办法是：在基类中添加一个private ctor，并且将模板参数<code>T</code>声明为<code>Base</code>类的友元。这样做可行是因为，派生类会调用基类的ctor（即使没有在代码中明确说明，编译器也这样做）。由于<code>Base</code>的ctor为private，除友元之外没有，其他东西可以访问，而基类唯一的friend class，就是template class。因此，<strong>如果派生类与模板类（template class）不同，则代码编译不过</strong>。</p>
<p>派生类会隐藏和基类同名的方法（因为被继承类的实现方法遮掩了，即基类的<code>do</code>方法被隐藏了），如下代码所示：</p>
<pre><code class="cpp">template &lt;typename T&gt;
class Base {
public:
    void do();
};
class Derived : public Base&lt;Derived&gt; {
public:
    void do(); // oops this hides the doSomething methods from the base class !
}
</code></pre>
<p><strong>CRTP两种常见用法：</strong></p>
<ul>
<li>Adding functionality（通过继承基类(CRTP)来扩展派生类的接口）</li>
<li>Static Interfaces（利用静态多态，编译期多态）</li>
</ul>
<h3 id="add-functionality"><a href="#add-functionality" class="headerlink" title="add functionality"></a>add functionality</h3><p>有些类提供了generic functionality，可以被许多其他类reuse。为了说明这一点，以一个表示的sensitivity类为例：</p>
<pre><code class="cpp">class Sensitivity {
public:
    double getValue() const;
    void setValue(double value);

    void scale(double multiplicator) {
        setValue(getValue() * multiplicator);
    }

    void square() {
        setValue(getValue() * getValue());
    }

    void setToOpposite() {
        scale(-1);
    };
};
</code></pre>
<p>如果现在有另一个类，它也有一个value，并且还拥有同<code>Sensitivity</code>一样的function， 难道要将这几个function又原封不动地copy-and-paste到新类吗？这就太违背OOP的设计初衷了，此时可以将这几个function提取出来封装成一个<code>NumericalFunctions</code>类：</p>
<pre><code class="cpp">template &lt;typename T&gt;
struct NumericalFunctions {
void scale(double multiplicator);
void square();
void setToOpposite();
};
</code></pre>
<p>然后再使用CRTP将<code>Sensitivity</code>重写：</p>
<pre><code class="cpp">class Sensitivity : public NumericalFunctions&lt;Sensitivity&gt; {
public:
    double getValue() const;
    void setValue(double value);
    // rest of the sensitivity&#39;s rich interface...
};
</code></pre>
<p>为此，这几个method需要访问<code>Sensitivity</code>类的<code>getValue</code>和<code>setValue</code>方法进行实现：</p>
<pre><code class="cpp">template &lt;typename T&gt;
struct NumericalFunctions {
    void scale(double multiplicator) {
        T&amp; underlying = static_cast&lt;T&amp;&gt;(*this);
        underlying.setValue(underlying.getValue() * multiplicator);
    }

    void square() {
        T&amp; underlying = static_cast&lt;T&amp;&gt;(*this);
        underlying.setValue(underlying.getValue() * underlying.getValue());
    }

    void setToOpposite(){
        scale(-1);
    };
};
</code></pre>
<p>通过使用CRTP，就能有效地将功能添加到<code>Sensitivity</code>类中，这就是<strong>add functionality</strong>。</p>
<h4 id="为什么不使用template-non-member-functions而选择CRTP。它们可能如下所示："><a href="#为什么不使用template-non-member-functions而选择CRTP。它们可能如下所示：" class="headerlink" title="为什么不使用template non-member functions而选择CRTP。它们可能如下所示："></a>为什么不使用template non-member functions而选择CRTP。它们可能如下所示：</h4><pre><code class="cpp">template &lt;typename T&gt;
void scale(T&amp; object, double multiplicator) {
    object.setValue(object.getValue() * multiplicator);
}

template &lt;typename T&gt;
void square(T&amp; object) {
    object.setValue(object.getValue() * object.getValue());
}

template &lt;typename T&gt;
void setToOpposite(T&amp; object) {
    object.scale(object, -1);
</code></pre>
<p>在non-member template function中使用CRTP至少需要一个参数：CRTP在如下接口（interface）<code>&lt;&gt;</code>中显示的那样。使用CRTP，可以看到<code>Sensitivity</code>提供了<code>NumericalFunctions</code>接口：</p>
<pre><code class="cpp">class Sensitivity : public NumericalFunctions&lt;Sensitivity&gt; {
public:
    double getValue() const;
    void setValue(double value);
    // rest of the sensitivity&#39;s rich interface...
};
</code></pre>
<p>即使知道这三个non-member functions的存在，也不能保证它们与特定的class兼容（可能它们调用<code>get()</code>或<code>getData()</code>，而不是<code>getValue()</code>）。 而对于用CRTP进行代码绑定（code binding）的<code>Sensitivity</code>早就已经编译完成，因此可以知道它们具备兼容的接口（compatible interface）。</p>
<h3 id="CRTP中的inheritance与classical-inheritance的区别："><a href="#CRTP中的inheritance与classical-inheritance的区别：" class="headerlink" title="CRTP中的inheritance与classical inheritance的区别："></a>CRTP中的inheritance与classical inheritance的区别：</h3><p><strong>【注意】：</strong>尽管CRTP使用了继承（inheritance），但使用它的过程同其他继承却不尽相同。通常，从另一个类派生的类表示<strong>derived class somehow conceptually “is a” base class</strong>。它的目的是能够在通用代码（generic code）中使用基类，同时使得对基类的调用能够redirect到派生类。</p>
<p>CRTP的情况完全不同：<strong>The derived class does not express the fact it “is a” base class</strong>。相反，它通过继承基类来扩展其接口，以便添加更多功能。</p>
<p>因此，基类不是interface，派生类也不是implementation。相反，它的meaning是：<strong>基类使用派生类方法（the base class uses the derived class methods）</strong>（例如<code>getValue</code>和<code>setValue</code>）。 在这方面，派生类为基类提供了接口。</p>
<h3 id="Static-interfaces"><a href="#Static-interfaces" class="headerlink" title="Static interfaces"></a>Static interfaces</h3><p>在这种情况下，the base class represent the interface, the derived one represent the implementation，同traditional polymorphism是一致的，只是与traditional polymorphism的区别在于：不涉及virtual（如virtual继承等），并且在编译期间（compilation）就完成所有调用。</p>
<p>现在用一个方法<code>getValue</code>来构建一个CRTP基类：</p>
<pre><code class="cpp">template &lt;typename T&gt;
class Amount {
public:
    double getValue() const {
        return static_cast&lt;T const&amp;&gt;(*this).getValue();
    }
};
</code></pre>
<p>现在这个接口有两个实现：一个总是返回常量，一个可以设置值。 这两个实现继承自CRTP <code>Amount</code>基类：</p>
<pre><code class="cpp">class Constant42 : public Amount&lt;Constant42&gt; {
public:
    double getValue() const {return 42;}
};

class Variable : public Amount&lt;Variable&gt; {
public:
    explicit Variable(int value) : value_(value) {}
    double getValue() const {return value_;}
private:
    int value_;
};
</code></pre>
<p>最后，为interface创建一个打印函数：</p>
<pre><code class="cpp">template&lt;typename T&gt;
void print(Amount&lt;T&gt; const&amp; amount) {
    std::cout &lt;&lt; amount.getValue() &lt;&lt; &#39;\n&#39;;
}
</code></pre>
<p>可以使用以下两种实现之一调用该函数：</p>
<pre><code class="cpp">Constant42 c42;
print(c42);
Variable v(43);
print(v);
///    42
///43
</code></pre>
<p>需要注意的是，尽管<code>Amount</code>类是以多态方式进行使用的，但代码中没有<code>virtual</code>。这就意味着多态调用（polymorphic call ）已经在编译期完成，从而避免了虚函数（virtual function）的运行时（run-time）成本。从设计的角度看，能够避免virtual calls的原因是：我们可以在编译期获得<code>Amount</code>类的信息。</p>
<h3 id="去除static-cast"><a href="#去除static-cast" class="headerlink" title="去除static_cast"></a>去除<code>static_cast</code></h3><p>在CRTP基类中编写冗余的<code>static_casts</code>会变得很麻烦，因为它不会给代码带来太多意义：</p>
<pre><code class="cpp">template &lt;typename T&gt;
struct NumericalFunctions {
    void scale(double multiplicator) {
        T&amp; underlying = static_cast&lt;T&amp;&gt;(*this);
        underlying.setValue(underlying.getValue() * multiplicator);
    }
    ...
};
</code></pre>
<p><code>static_casts</code>去除后将使得代码更紧凑。不过为了实现相同的效果，可以通过将基础类型forwarding到更高层次结构级别（higher hierarchy level）来实现：</p>
<pre><code class="cpp">template &lt;typename T&gt;
struct crtp {
    T&amp; underlying() { return static_cast&lt;T&amp;&gt;(*this); }
    T const&amp; underlying() const { return static_cast&lt;T const&amp;&gt;(*this); }
};
</code></pre>
<p>另外，它处理的是底层对象是const的情况，我们还没有提到过。可以通过以下方式使用此helper：</p>
<pre><code class="cpp">template &lt;typename T&gt;
struct NumericalFunctions : crtp&lt;T&gt; {
    void scale(double multiplicator) {
        this-&gt;underlying().setValue(this-&gt;underlying().getValue() * multiplicator);
    }
    ...
};
</code></pre>
<p>Note that the <code>static_cast</code> is gone and a <code>this-&gt;</code> appeared. Without it the code would not compile. Indeed, the compiler is not sure where <code>underlying</code> is declared. Even if it is declared in the template class <code>crtp</code>, in theory nothing guarantees that this template class won’t be specialized and rewritten on a particular type, that would not expose an <code>underlying</code> method. For that reason, names in template base classes are ignored in C++.</p>
<h3 id="Adding-several-functionalities-with-CRTP"><a href="#Adding-several-functionalities-with-CRTP" class="headerlink" title="Adding several functionalities with CRTP"></a>Adding several functionalities with CRTP</h3><p>为了演示，将CRTP类拆分为两个：一个用于scale values，另一个用于squares values：</p>
<pre><code class="cpp">template &lt;typename T&gt;
struct Scale : crtp&lt;T&gt; {
    void scale(double multiplicator) {
        this-&gt;underlying().setValue(this-&gt;underlying().getValue() * multiplicator);
    }
};

template &lt;typename T&gt;
struct Square : crtp&lt;T&gt; {
    void square() {
        this-&gt;underlying().setValue(this-&gt;underlying().getValue() * this-&gt;underlying().getValue());
    }
};
</code></pre>
<p>并将这两个功能添加到<code>Sensitivity</code>类：</p>
<pre><code class="cpp">class Sensitivity : public Scale&lt;Sensitivity&gt;, public Square&lt;Sensitivity&gt; {
public:
    double getValue() const { return value_; }
    void setValue(double value) { value_ = value; }
private:
    double value_;
};
</code></pre>
<p>乍一看还不错，但是一旦调用其中一个基类方法就会出现编译错误！</p>
<blockquote>
<p>error: <code>crtp&lt;Sensitivity&gt;</code>is an ambiguous base of <code>Sensitivity</code></p>
</blockquote>
<p>原因是出现了钻石继承（diamond inheritance）：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1351548-9398789c27f4099a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>另一种方法是通过让每个functionality（scale，square）继承自己的<code>crtp</code>类来避开钻石继承。这可以通过CRTP来实现。</p>
<p>实际上，可以在<code>crtp</code>类中添加一个与对基类相对应的的template parameter，此外需要注意<code>crtpType</code>模板参数的添加。</p>
<pre><code class="cpp">template &lt;typename T, template&lt;typename&gt; class crtpType&gt;
struct crtp {
    T&amp; underlying() { return static_cast&lt;T&amp;&gt;(*this); }
    T const&amp; underlying() const { return static_cast&lt;T const&amp;&gt;(*this); }
private:
    crtp(){}
    friend crtpType&lt;T&gt;;
};
</code></pre>
<p><strong>【注意】：</strong><code>crtpType</code>是一个template template parameter，；例如它的值可以是<code>Scale</code>。</p>
<p>类层次结构现在如下所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1351548-e1da4c45624513e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>CRTP是一种静态多态（static polymorphism/Static binding/Compile-Time binding)，与其对应的是动态多态(dynamic polymorphism/Dynamic binding/Run-Time binding)。 </p>
<p><strong>静态多态与和动态多态的区别是：</strong></p>
<ul>
<li>traditional多态是动态绑定（或运行时绑定，run-time binding）</li>
<li>CRTP是静态绑定（编译时绑定，compile-time binding）。</li>
</ul>
<p>其中，动态多态在实现多态时，需要重写虚函数（virtual function），这种运行时绑定的操作往往需要查找虚表等，效率较低。template的核心技术在于编译期多态机制，与运行期多态（run-time polymorphism）相比，这种动态机制能提供编译期多态性，赋予程序运行期无可比拟的效率优势。如果想在编译期确定通过基类来得到派生类的行为，CRTP便是一种绝佳的选择。</p>
<p>此外，<code>std::enable_shared_from_this</code>也采用了CRTP进行实现。</p>
<h3 id="std-enable-shared-from-this"><a href="#std-enable-shared-from-this" class="headerlink" title="std::enable_shared_from_this"></a><code>std::enable_shared_from_this</code></h3><p>定义在<code>&lt;memory&gt;</code>，其原型为：</p>
<pre><code class="cpp">template&lt; class T &gt; class enable_shared_from_this;
</code></pre>
<p><code>std::enable_shared_from_this</code>允许由<code>std::shared_ptr</code>实例<code>pt</code>进行管理的对象<code>t</code>可以安全地生成额外的<code>std::shared_ptr</code>实例<code>pt1，pt2，...</code>，这些实例与<code>pt</code>共享<code>t</code>的所有权（ownership）。</p>
<p>公开继承<code>std::enable_shared_from_this&lt;T&gt;</code>时，将会为类型<code>T</code>提供一个member function：<code>shared_from_this</code>。 如果<code>T</code>类型的对象<code>t</code>由<code>std::shared_ptr&lt;T&gt;</code>实例<code>pt</code>进行管理，则调用<code>T::shared_from_this</code>将返回一个新的<code>std::shared_ptr&lt;T&gt;</code>，它将与<code>pt</code>共享<code>t</code>的所有权。</p>
<h4 id="shared-from-this"><a href="#shared-from-this" class="headerlink" title="shared_from_this"></a><code>shared_from_this</code></h4><p>返回一个<code>std::shared_ptr&lt;T&gt;</code>，它与现存的所有<code>std::shared_ptr</code>对象共享<code>*this</code>的所有权。</p>
<p>例子：</p>
<pre><code class="cpp">struct Foo : public std::enable_shared_from_this&lt;Foo&gt; {
    Foo() { std::cout &lt;&lt; &quot;Foo::Foo\n&quot;; }
    ~Foo() { std::cout &lt;&lt; &quot;Foo::~Foo\n&quot;; } 
    std::shared_ptr&lt;Foo&gt; getFoo() { return shared_from_this(); }
};

int main() {
    Foo *f = new Foo();
    std::shared_ptr&lt;Foo&gt; p1;

    {
        std::shared_ptr&lt;Foo&gt; p2(f);
        p1 = p2-&gt;getFoo();  // shares ownership of object with p2
    }

    std::cout &lt;&lt; &quot;p2 is gone\n&quot;;   
}

///    Foo::Foo
///    p2 is gone
//    Foo::~Foo
</code></pre>
<p>扩展：</p>
<ul>
<li><a href="https://www.fluentcpp.com/2017/05/12/curiously-recurring-template-pattern/" target="_blank" rel="noopener">The Curiously Recurring Template Pattern (CRTP)</a></li>
<li><a href="https://eli.thegreenplace.net/2013/12/05/the-cost-of-dynamic-virtual-calls-vs-static-crtp-dispatch-in-c" target="_blank" rel="noopener">The cost of dynamic (virtual calls) vs. static (CRTP) dispatch in C++</a></li>
<li><a href="https://eli.thegreenplace.net/2011/05/17/the-curiously-recurring-template-pattern-in-c/" target="_blank" rel="noopener">The Curiously Recurring Template Pattern in C++</a></li>
</ul>
<h2 id="Functor"><a href="#Functor" class="headerlink" title="Functor"></a>Functor</h2><p>functor是一个定义了<code>operator()</code>的类， 这便可以创建一个“看起来像”函数的对象：</p>
<pre><code class="cpp">// this is a functor
struct add_x {
  add_x(int x) : x(x) { }
  int operator()(int y) const { return x + y; }

private:
  int x;
};

// Now you can use it like this:
add_x add42(42);     // create an instance of the functor class
int i = add42(8);         // and &quot;call&quot; it
assert(i == 50);         // and it added 42 to its argument

std::vector&lt;int&gt; in;   // assume this contains a bunch of values)
std::vector&lt;int&gt; out(in.size());
// Pass a functor to std::transform, which calls the functor on every element 
// in the input sequence, and stores the result to the output sequence
std::transform(in.begin(), in.end(), out.begin(), add_x(1)); 
///    why write there add_x, not the add42?
///    Both would have worked (but the effect would have been different). If I&#39;d used add42, I would have used the functor I created earlier, and added 42 to each value. With add_x(1) I create a new instance of the functor, one which only adds 1 to each value. It is simply to show that often, you instantiate the functor &quot;on the fly&quot;, when you need it, rather than creating it first, and keeping it around before you actually use it for anything
assert(out[i] == in[i] + 1);     // for all i
</code></pre>
<p>仿函数有几个好处：一个是与regular function不同，它们可以包含状态（state）。上面的示例中创建了一个函数，它可以将user提供的任何内容加上<code>42</code>。但是，值<code>42</code>不是hardcoded（”Hard Coding” means something that you want to embeded with your program or any project that can not be changed directly），当创建functor实例时，它被指定为构造函数（ctor）参数。此外，可以通过不同的值（调用构造函数）来创建加上<code>27</code>的adder。这使得user的可以很好地根据自己的需求来进行定制。</p>
<p>如最后一行所示，经常将functor作为参数传递给其他function（例如<code>std::transform</code>或其他STL algo）。此外，regular function pointer可以执行相同的操作，但functor可以进行customize，因为它们包含状态，使得它们更加灵活（如果想要使用function pointer，就必须编写一个function，并在它的参数中明确地加上<code>1</code>。functor更加general，只要在在初始化时添加了试图操作的value即可）。在上面的例子中，编译器确切地知道<code>std::transform</code>应该调用哪个函数。它应该调用<code>add_x::operator()</code>，这意味着此functor可以内联该函数调用。这如同为vector的每一个值手动调用函数样高效。</p>
<p><strong>【注意】：</strong>Functor必须拥有<code>operator()</code>, 因为caller就依靠它来进行invoke。至于是否必须拥有member functions, constructors, operators and member variables都完全取决于user。 （在functional programming中，定义了<code>operator()</code>的function（它不是class）属于functor，但在C++中却不是，因为在C++中的定义是：<strong>the functor is specifically a class used as a function</strong>）。</p>
<h2 id="RAII（Resource-Acquisition-Is-Initialization-）"><a href="#RAII（Resource-Acquisition-Is-Initialization-）" class="headerlink" title="RAII（Resource Acquisition Is Initialization ）"></a>RAII（Resource Acquisition Is Initialization ）</h2><blockquote>
<p>RAII, is a C++ programming technique which binds the life cycle of a resource that must be acquired before use (allocated heap memory, thread of execution, open socket, open file, locked mutex, disk space, database connection—anything that exists in limited supply) to the lifetime of an object.</p>
</blockquote>
<p>C++ RAII的通用形式：</p>
<pre><code class="cpp">class someResource {
    //internal representation holding pointers, handles etc.

public:
    someResource() {
        //Obtain resource.
    }

    ~someResource() {
    //Release resource.
    }

};
</code></pre>
<p><strong>总结：</strong></p>
<ul>
<li>将每个资源封装入一个类<ul>
<li>构造函数请求资源，并创建类的所有invariants（常量）或者在它无法完成时抛出异常</li>
<li>析构函数释放资源并，而且绝不会抛出异常</li>
</ul>
</li>
<li>通过RAII类实例进行使用的资源的特性为：<ul>
<li>该资源自身拥有automatic storage duration或temporary lifetime（临时生存期），或</li>
<li>该资源的lifetime与自动（automatic）对象或临时对象（temporary object）绑定</li>
</ul>
</li>
</ul>
<p>移动语义使得在维护资源安全的同时，在对象间、跨作用域以及线程内外移动安全移动所有权成为可能。</p>
<p>C++标准库遵循RAII来管理其自身的资源：<code>std::string</code>、<code>std::vector</code>、 <code>std::thread</code>，以及多数其他类在构造函数（错误时抛出异常）中获取其资源，并在其析构函数（决不抛出）中释放之，且不要求显式清理。</p>
<p>另外，标准库提供几种RAII wrappwer用于管理用户提供的资源：</p>
<ul>
<li><code>std::unique_ptr</code>及<code>std::shared_ptr</code>用于管理动态分配的内存或用普通指针表示的资源；</li>
<li><code>std::lock_guard</code>、<code>std::unique_lock</code>、<code>std::shared_lock</code>用于管理互斥。</li>
</ul>
<p><strong>例子：使用RAII阻止内存泄漏</strong><br>泄漏通常是不可接受的。 手动释放资源容易出错，RAII是防止泄漏的最简单也最系统的方式。</p>
<pre><code class="cpp">void f1(int i) {          // Bad: possibly leak
    int* p = new int[12];
    // ...
    if (i &lt; 17) throw Bad{&quot;in f()&quot;, i};
    // ...
}
</code></pre>
<p>可以在throw之前小心地释放资源：</p>
<pre><code class="cpp">oid f2(int i)   {        // 笨拙且容易出错： explicit release
    int* p = new int[12];
    // ...
    if (i &lt; 17) {
        delete[] p;
        throw Bad{&quot;in f()&quot;, i};
    }
    // ...
}
</code></pre>
<p>上述代码显得十分冗余， 在具有多个可能throw的较大代码中，explicit版本变得重复且容易出错。</p>
<pre><code class="cpp">void f3(int i) {`  // OK: resource management done by a handles
    auto p = make_unique&lt;int[]&gt;(12);
    // ...
    if (i &lt; 17) throw Bad{&quot;in f()&quot;, i};
    // ...
}
</code></pre>
<p>注意，即使throw是隐式的，因为它发生在被调用的函数中，这也是有效的：</p>
<pre><code class="cpp">void f4(int i)  {    // OK: resource management done by a handle 
    auto p = make_unique&lt;int[]&gt;(12);
    // ...
    helper(i);   // may throw
    // ...
}
</code></pre>
<p>除非确实需要指针语义（pointer semantics），否则请使用本地资源对象（local resource object）：</p>
<pre><code class="cpp">void f5(int i)  {      // OK: resource management done by local object
    vector&lt;int&gt; v(12);
    // ...
    helper(i);   // may throw
    // ...
}
</code></pre>
<p>这更简单，更安全，而且效率更高。</p>
<p>扩展阅读：</p>
<ol>
<li><a href="https://www.hackcraft.net/raii/#sect0" target="_blank" rel="noopener">The RAII Programming Idiom</a></li>
<li><a href="https://stackoverflow.com/questions/2321511/what-is-meant-by-resource-acquisition-is-initialization-raii" target="_blank" rel="noopener">What is meant by Resource Acquisition is Initialization (RAII)?</a><h2 id="static-cast-VS-const-static-VS-dynamic-cast-VS-reinterpret-cast"><a href="#static-cast-VS-const-static-VS-dynamic-cast-VS-reinterpret-cast" class="headerlink" title="static_cast VS const_static VS dynamic_cast VS reinterpret_cast"></a><code>static_cast</code> VS <code>const_static</code> VS <code>dynamic_cast</code> VS <code>reinterpret_cast</code></h2></li>
</ol>
<h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a><code>static_cast</code></h3><p><code>static_cast</code>的行为类似类型之间的隐式转换（例如从<code>int</code>到<code>float</code>或指向<code>void*</code>类型的指针），它还可以调用显式转换函数（或隐式转换函数）。 在许多情况下，明确声明<code>static_cast</code>不是必需的，但要注意<code>T(something)</code>语法等同于<code>(T)somthing</code>，并且应该避免这样做。 但是，<code>T(something,something_else)</code>是安全的，并且保证可以调用构造函数。</p>
<p><code>static_cast</code>也可以通过继承体系进行转换。 向上转型时（即向base class转型）时是不必要的，但向下转型时，只要不是通过virtual inheritance进行强制转换就可以使用它。 It does not do checking, however, and it is undefined behavior to <code>static_cast</code> down a hierarchy to a type that isn’t actually the type of the object.</p>
<h3 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a><code>const_cast</code></h3><p><code>const_cast</code>主要是用于<strong>在有不同cv-qualified的类型之间进行转换</strong>，去除或者添加<code>const</code>修饰符。</p>
<p><code>const_cast &lt; new_type &gt; ( expression );</code>。仅适用于以下4种情况：</p>
<ol>
<li>指向同一类型的两个多级指针可以相互转换（不管每一级有多少cv-qualifier）</li>
<li>任意类型<code>T</code>的lvalue可以被转换为<code>T</code>类型的lvalue or rvalue reference。同样的，一个rvalue可以被转换为rvalue reference</li>
<li>null pointer value可以被转换为值为<code>new_type</code>的null pointer value<br><strong>【注】：</strong><code>const_cast</code>对函数指针和成员函数指针都不起作用。</li>
</ol>
<p>例子：</p>
<pre><code class="cpp">struct type {
    type() :i(3) {}
    void m1(int v) const {
        // this-&gt;i = v;                 // 编译错误：这是指向 const 的指针
        const_cast&lt;type*&gt;(this)-&gt;i = v; // 只要对象不是 const 就 OK
    }
    int i;
};

int main() {
    int i = 3;                    // i 不声明为 const
    const int&amp; cref_i = i; 
    const_cast&lt;int&amp;&gt;(cref_i) = 4; // OK ：修改 i
    std::cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; &#39;\n&#39;;

    type t; // note, if this is const type t;, then t.m1(4); is UB
    t.m1(4);
    std::cout &lt;&lt; &quot;type::i = &quot; &lt;&lt; t.i &lt;&lt; &#39;\n&#39;;

    const int j = 3; // j 声明为 const
    int* pj = const_cast&lt;int*&gt;(&amp;j);
    // *pj = 4;         // 未定义行为！

    void (type::*mfp)(int) const = &amp;type::m1; // 指向成员函数指针
//  const_cast&lt;void(type::*)(int)&gt;(mfp); // 编译错误： const_cast 对函数指针不起作用
}
/// i=4
///type::i=4
</code></pre>
<h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a><code>dynamic_cast</code></h3><pre><code class="cpp">dynamic_cast &lt; new_type &gt; ( expression )
</code></pre>
<p><code>dynamic_cast</code>主要用于处理多态性。可以使用它而不仅仅是向下转型，也可以向上或者侧向转换到类的指针或引用。</p>
<ul>
<li>若转型成功，则返回<code>new_type</code>类型的值</li>
<li>若转型失败且<code>new_type</code>是指针类型，则它返回该类型的空指针</li>
<li>若转型失败且<code>new_type</code>是引用类型，则它抛出匹配类型 异常（<code>std::bad_cast</code>）</li>
</ul>
<p>仅下列转换适用于<code>dynamic_cast</code>：</p>
<ol>
<li>如果<code>expression</code>的类型恰好是<code>new_type</code>或<code>new_type</code>的较少cv-qualified版本，则返回<code>new_type</code>类型的<code>expression</code>（换言之，<code>dynamic_cast</code>可用以添加constness。隐式转型和<code>static_cast</code>也能进行此转换。）</li>
<li>如果<code>expression</code>是空指针值，则返回<code>new_type</code>类型的空指针值。</li>
<li>如果<code>new_type</code>是<code>Base</code>的指针或引用（即基类指针或者引用），且<code>expression</code>是<code>Derived</code>类型的指针或引用（即派生类指针或者引用），其中<code>Base</code>是<code>Derived</code>的单一可访问基类，则返回<code>Base</code>类子对象的指针或引用（注意：隐式转型和<code>static_cast</code>也能进行此转换）</li>
<li>如果<code>expression</code>是多态类型的引用或指针，且<code>new_type</code>是<code>void</code>指针，则返回<code>expression</code>所指向或引用对象的最终派生类的指针。</li>
<li>若<code>expression</code>是多态类型<code>Base</code>的指针或引用，且 <code>new_type</code>是<code>Derived</code>类型的指针或引用，则进行run-time检查：<ul>
<li>a) The most derived object pointed/identified by <code>expression</code> is examined. If, in that object, <code>expression</code> points/refers to a public base of <code>Derived</code>, and if only one subobject of <code>Derived</code> type is derived from the subobject pointed/identified by <code>expression</code>, then the result of the cast points/refers to that <code>Derived</code> subobject. (This is known as a <strong>downcast</strong>)</li>
<li>b) Otherwise, if <code>expression</code> points/refers to a public base of the most derived object, and, simultaneously, the most derived object has an unambiguous public base class of type <code>Derived</code>, the result of the cast points/refers to that <code>Derived</code> (This is known as a <strong>sidecast</strong>)</li>
<li>c) Otherwise, the runtime check fails. If the <code>dynamic_cast</code> is used on pointers, the null pointer value of type <code>new_type</code> is returned. If it was used on references, the exception <code>std::bad_cast</code> is thrown.<br>6) <code>dynamic_cast</code>用于构造函数或析构函数时（直接或间接），且<code>expression</code>指向正在构造/析构的对象时，该对象被认为是最终派生对象。如果<code>new_type</code>不是到构造函数/析构函数自身的类或其基类之一的指针，则行为未定义。</li>
</ul>
</li>
</ol>
<p>例子</p>
<pre><code class="cpp">struct V {
    virtual void f() {};  // must be polymorphic to use runtime-checked dynamic_cast
};
struct A : virtual V {};
struct B : virtual V {
  B(V* v, A* a) {
    // casts during construction (see the call in the constructor of D below)
    dynamic_cast&lt;B*&gt;(v); // well-defined: v of type V*, V base of B, results in B*
    dynamic_cast&lt;B*&gt;(a); // undefined behavior: a has type A*, A not a base of B
  }
};
struct D : A, B {
    D() : B((A*)this, this) { }
};

struct Base {
    virtual ~Base() {}
};

struct Derived: Base {
    virtual void name() {}
};

int main()
{
    D d; // the most derived object
    A&amp; a = d; // upcast, dynamic_cast may be used, but unnecessary
    D&amp; new_d = dynamic_cast&lt;D&amp;&gt;(a); // downcast
    B&amp; new_b = dynamic_cast&lt;B&amp;&gt;(a); // sidecast


    Base* b1 = new Base;
    if(Derived* d = dynamic_cast&lt;Derived*&gt;(b1))
    {
        std::cout &lt;&lt; &quot;downcast from b1 to d successful\n&quot;;
        d-&gt;name(); // safe to call
    }

    Base* b2 = new Derived;
    if(Derived* d = dynamic_cast&lt;Derived*&gt;(b2))
    {
        std::cout &lt;&lt; &quot;downcast from b2 to d successful\n&quot;;
        d-&gt;name(); // safe to call
    }

    delete b1;
    delete b2;
}
///downcast from b2 to d successful
</code></pre>
<h2 id="copy-and-swap-idiom"><a href="#copy-and-swap-idiom" class="headerlink" title="copy-and-swap idiom"></a>copy-and-swap idiom</h2><h3 id="1-为什么需要copy-and-swap-idiom"><a href="#1-为什么需要copy-and-swap-idiom" class="headerlink" title="1. 为什么需要copy-and-swap idiom"></a>1. 为什么需要copy-and-swap idiom</h3><p>任何管理资源的类（即wrapper，例如智能指针）都需要实现<strong>The big Three</strong>。 虽然拷贝构造函数（copy ctor）和析构函数（dtor）的作用和实现都很简单，但拷贝赋值运算符（copy assignment operator）可以说是最微妙和最困难的。</p>
<p>copy-and-swap idiom是解决方案，可以帮助赋值操作符（assignment operator）完美地实现两件事：<strong>避免代码重复，并提供强大的异常保证</strong>。</p>
<h3 id="2-工作机制"><a href="#2-工作机制" class="headerlink" title="2. 工作机制"></a>2. 工作机制</h3><p>从概念上讲，它通过使用拷贝构造函数（copy ctor）创建数据的本地副本，然后使用swap函数获取拷贝的数据，利用新数据swap旧数据。最后销毁临时拷贝，并用它来获取旧数据。我们留下了新数据的副本。</p>
<p><strong>为了使用copy-and-swap idiom，需要三件事：拷贝构造函数，析构函数以及一个swap函数</strong>。</p>
<p>swap函数是一种nonp-throwing函数，它交换类的两个对象以及各自的成员。我们可能想要使用<code>std::swap</code>而不是提供我们自己的，但这是不可能的。<code>std::swap</code>在其实现中使用了copy ctor和copy-assignment operator，我们只需根据自身需求定义赋值运算符（assignment operator）。</p>
<p>（不仅如此，但对swap的不合格调用将使用我们的自定义交换运算符，跳过std :: swap所需的不必要的构造和类的破坏。）</p>
<h3 id="3-深入理解"><a href="#3-深入理解" class="headerlink" title="3. 深入理解"></a>3. 深入理解</h3><p>考虑一个具体案例，现试图在一个类中管理一个动态数组。 先从一个构造函数，拷贝构造函数和析构函数开始：</p>
<pre><code class="cpp">#include &lt;algorithm&gt; // std::copy
#include &lt;cstddef&gt; // std::size_t

class dumb_array {
public:
    // (default) constructor
    dumb_array(std::size_t size = 0)
        : mSize(size),
          mArray(mSize ? new int[mSize]() : nullptr) { }

    // copy-constructor
    dumb_array(const dumb_array&amp; other)
        : mSize(other.mSize),
          mArray(mSize ? new int[mSize] : nullptr) {
        // note that this is non-throwing, because of the data
        // types being used; more attention to detail with regards
        // to exceptions must be given in a more general case, however
        std::copy(other.mArray, other.mArray + mSize, mArray);
    }

    // destructor
    ~dumb_array() {
        delete [] mArray;
    }

private:
    std::size_t mSize;
    int* mArray;
};
</code></pre>
<p>这个类基本上可以管理数组了，但它还需要<code>operator =</code>才能正常工作。</p>
<p>现在有一个naive的实现：</p>
<pre><code class="cpp">// the hard part
dumb_array&amp; operator=(const dumb_array&amp; other) {
    if (this != &amp;other) {// (1)
        // get rid of the old data...
        delete [] mArray; // (2)
        mArray = nullptr; // (2) *(see footnote for rationale)

        // ...and put in the new
        mSize = other.mSize; // (3)
        mArray = mSize ? new int[mSize] : nullptr; // (3)
        std::copy(other.mArray, other.mArray + mSize, mArray); // (3)
    }

    return *this;
}
</code></pre>
<p>现在成功地管理一个数组，并且没有内存泄漏。但是，它存在三个问题，在代码中已用数字标出。</p>
<ol>
<li>首先是self-assignment test。这个检查有两个目的：利用简单的方法来阻止在自我赋值上运行不必要的代码；可以免受微妙的错误（例如删除数组只是为了尝试复制它）。但在其他情况下，它只会降低程序的运行速度，并会冗余代码；self-assignment（自我赋值）很少发生，因此在大多数的情况在，这种检查是浪费。如果没有它， 可以正常工作会更好。</li>
<li><p>第二是它只提供基本的异常（exception）保证。如果<code>new int [mSize]</code>失败，<code>*this</code>将被修改（即size错误，数据都将遗失）。而对于强大的异常保证，它需要类似于：</p>
<pre><code class="cpp">dumb_array＆operator =（const dumb_array＆other）{
 if（this！=＆other）{//（1）  
     //在替换旧数据之前应先准备好新数据
     std :: size_t newSize = other.mSize;
     int * newArray = newSize？ new int [newSize]（）：nullptr; //（3）
     std :: copy（other.mArray，other.mArray + newSize，newArray）; //（3）

     //替换旧数据（都是non-throwing）
     delete[] mArray;
     mSize = newSize;
     mArray = newArray;
 }

 return *this;
}
</code></pre>
</li>
<li>代码快速膨胀导致了第三个问题：代码重复。我们的赋值运算符（assignment operator）拷贝了我们已经在其他地方写过的所有代码，这是一件非常糟糕的事情。</li>
</ol>
<p>在上述的例子中，它的核心只有两行（allocation和copy），但是对于更复杂的资源，代码膨胀问题可能非常麻烦。我们应该精良不要重复自己。</p>
<h3 id="正确的做法"><a href="#正确的做法" class="headerlink" title="正确的做法"></a>正确的做法</h3><p>copy-and-swap idiom可以解决这些问题，但现在还需要一个swap函数。 虽然<strong>The Rule of Three</strong>可以确保我们的拷贝构造函数（copy ctor），赋值运算符（assignment operator）和析构函数（dtor）存在，但它应该被称为<strong>The Big Three and A Half</strong>：只要你的类需要管理资源，就应该提供交换一个swap函数。</p>
<p>现需要在我们的类中添加swap功能：</p>
<pre><code class="cpp">class dumb_array {
public:
    // ...

    friend void swap(dumb_array&amp; first, dumb_array&amp; second) {// nothrow
        // enable ADL (not necessary in our case, but good practice)
        using std::swap;

        // by swapping the members of two objects,
        // the two objects are effectively swapped
        swap(first.mSize, second.mSize);
        swap(first.mArray, second.mArray);
    }

    // ...
};
</code></pre>
<p>现在我们不仅可以swap我们的<code>dumb_array</code>，而且swap更有效率。 它只是swap pointers和sizes，而不是allocate和copy整个数组。 除了功能和效率方面的优势，也为copy-and-swap idiom的实现做好了铺垫。</p>
<p>赋值运算符的实现为：</p>
<pre><code class="cpp">dumb_array&amp; operator=(dumb_array other) {// (1)
    swap(*this, other); // (2)

    return *this;
}
</code></pre>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>首先注意到一个特征：参数是以值传递的方式。 虽然可以轻松地实现以下操作：</p>
<pre><code class="cpp">dumb_array&amp; operator=(const dumb_array&amp; other) {
    dumb_array temp(other);
    swap(*this, temp);

    return *this;
}
</code></pre>
<p>无论哪种方式，这种获取资源的方法是消除代码重复的关键：可以使用copy-constructor中的代码来创建副本，而不需重复它。现在副本已经创建完成，便已准备好进行swap。</p>
<p>注意，在进入该函数时，新数据已经allocate，copy完成，可随时使用。这就提供强有力的异常保证：如果副本创建失败，将不会进入swap函数，因此也不可能改变<code>*this</code>的状态。</p>
<p>将当前数据与复制的数据进行swap，安全地改变我们的状态，并将旧数据放入临时数据中，然后在函数返回时释放旧数据。</p>
<p>因为idiom不重复代码，所以不能在运算符（operator）中引入错误。这意味着我们不需要进行自我赋值检查（self-assignment check），从而允许只实现一个<code>operator =</code>。</p>
<p>这就是copy-and-swap idiom。</p>
<p>其他解释：</p>
<blockquote>
<p>assignment的两个主要步骤：拆除对象的旧状态，并将其新状态构建为其他对象状态的副本。<br>基本上，这就是析构函数和拷贝构造函数的作用，因此第一个想法是将工作委托给它们。然而，由于析构（destruction）必定不会失败，而构造（construction）可能，我们实际上想要反其道而行之：首先执行construction，如果成功，再进行destruction。copy-and-swap idiom是这样做的：它首先调用类的拷贝构造函数来创建temporary，然后用temporary交换数据，然后让temporary的析构函数（dtor）销毁旧状态。<br>由于<code>swap()</code>永远不会失败，因此唯一可能失败的部分是拷贝构造的时候。首先执行此操作，如果失败，则目标对象不会更改任何内容。</p>
</blockquote>
<h2 id="const与constexpr的区别"><a href="#const与constexpr的区别" class="headerlink" title="const与constexpr的区别"></a><code>const</code>与<code>constexpr</code>的区别</h2><p><code>constexpr</code>的主要用处：</p>
<ul>
<li>拓宽常量表达式的范围</li>
<li>提供显示要求表达式编译时（compile-time）求值的方法</li>
</ul>
<p>拓宽常量表达式的范围的理由：<br>例如<code>INT_MAX</code>是C语言的遗物，C++更希望大家使用<code>std::numeric_limits&lt;int&gt;::max()</code>作为<code>int</code>的上限，然而它是个函数调用而不是常量，使用起来可能需要考虑更多，没有前者那么易用。</p>
<p>例如标准文件流，它的构造函数可以如下使用：<code>std::fstream foo(&quot;foo.txt&quot;, std::ioss::in | std::ios::out);</code>。这个参数是<code>openmode</code>类型，由实现具体定义的一种bitmask类型。出于类型安全的考虑，通常使用枚举值实现而不是整形。但这样会造成一个问题，同样是写<code>std::ios::in|std::ios|out</code>，如果用整型的话可以作为常量表达式使用，而为了类型安全考虑换用枚举实现（尤其是重载 <code>|</code> 操作符）后，就再也不可能是常量表达式了。</p>
<pre><code class="cpp">inline openmode operator|(openmode lhs, openmode rhs) {
    return openmode(int_type(lhs) | int_type(rhs));
}
</code></pre>
<p>虽然是简单的函数，但对它的调用却不是常量表达式。这就让委员会陷入了必须在类型安全和效率中二选一的境地。标准委员会正好借此机会将原本标准中对于常量表达式（尤其是整形常量表达式）复杂的定义重构简化，引入<code>constexpr</code>便合情合理。</p>
<p><strong>注意，<code>constexpr</code>函数并不能个编译时求值划等号。</strong>，它只是表达了这个函数具备这样的能力。所以才有了<code>constexpr</code>的第二个功能：显示要求表达式在编译时进行求值。把它放到变量定义前，那么用来初始化这个变量的表达式必须是常量表达式，否则将会报错。</p>
<p><code>constexpr</code>函数只有同时满足一下条件时才会触发编译期求值（如果只有参数是常量表达式而结果不是，那么是否会触发编译时求值则取决于具体实现）：</p>
<ul>
<li>所有参数都是常量表达式</li>
<li>返回的结果被用于常量表达式（比如用于初始化<code>constexpr</code>数据）</li>
</ul>
<p><code>constexpr</code>的常见应用场景（一般在模板元编程中）：<br><strong>1. 简化元函数：</strong></p>
<pre><code class="cpp">template &lt;typename U, typename V&gt;
constexpr bool is_same_v = std::is_same&lt;U, V&gt;::value;
</code></pre>
<p>可以直接这样<code>auto x = is_same_v&lt;int, float&gt;;</code>进行调用。</p>
<p><strong>2. 用于元编程的常量成员</strong></p>
<pre><code class="cpp">template &lt;typename U, typename V&gt;
struct is_same {
    static constexpr int value = false;
}

template &lt;typename T&gt;
struct is_same&lt;T, T&gt; {
    static constexpr int value = true;
}
</code></pre>
<p>便可以通过<code>is_same&lt;X, X&gt;::value;</code>来调用这个元函数。<br><strong>3. 修饰常函数</strong></p>
<pre><code class="cpp">constexpr int add(int a, int b) { return a+b; }
</code></pre>
<p><strong>4. 修饰分支</strong><br><code>if constexpr () {}</code><br><strong>其实可以将<code>constexpr</code>修饰的东西看成元函数的变量。</strong><br>两个关键字都能用于对象和函数的声明。两者在声明对象时的主要差别为：</p>
<ul>
<li><code>const</code>将对象声明为常量（constant）。这就意味着一旦被初始化，则对象的值将不再改变，并且编译器可以利用这一事实进行优化。从外，它还能防止程序员修改某些不能再被修改的对象。</li>
<li><code>constexpr</code>声明一个对象，使得该对象可以在标准中称为的constant expression中使用。</li>
</ul>
<p>两者在声明函数时的主要差别为：</p>
<ul>
<li><code>const</code>只能用于非静态成员函数（non-static member function），而并不是所有的函数。其确保成员函数不会修改任何非静态数据成员。</li>
<li><code>constexpr</code>能同时用于成员函数和非成员函数。其将函数声明为constant expression。</li>
</ul>
<p>扩展：<a href="https://stackoverflow.com/questions/14116003/difference-between-constexpr-and-const" target="_blank" rel="noopener">Difference between <code>constexpr</code> and <code>const</code>
</a></p>
<h2 id="迭代器（iterator）"><a href="#迭代器（iterator）" class="headerlink" title="迭代器（iterator）"></a>迭代器（iterator）</h2><h3 id="插入迭代器（insert-iterator）"><a href="#插入迭代器（insert-iterator）" class="headerlink" title="插入迭代器（insert_iterator）"></a>插入迭代器（<code>insert_iterator</code>）</h3><p>被绑定到一个容器上，可以向容器插入元素。</p>
<ul>
<li><strong><code>back_inserter</code>：</strong>只要迭代器被赋值，容器内的<code>push_back()</code>成员函数将被调用。</li>
<li><strong><code>front_inserter</code>：</strong>创建一个使用<code>push_front</code>的迭代器。</li>
<li><strong><code>inserter</code>：</strong>创建一个使用<code>insert</code>的迭代器。元素将被插入到指定迭代器所表示的元素之前。<h3 id="移动迭代器（move-iterator）"><a href="#移动迭代器（move-iterator）" class="headerlink" title="移动迭代器（move_iterator）"></a>移动迭代器（<code>move_iterator</code>）</h3>不是拷贝其中的元素，而是移动它们。一个move iterator通过改变给定迭代器的dereference operator的行为来适配此迭代器。一般来说，一个迭代器的dereference operator将返回一个指向元素的左值。与其他迭代器不同，move iterator的dereference operator将返回一个右值引用。通过<code>make_move_iterator</code>可以将一个普通迭代器转换为一个move iterator。</li>
</ul>
<p>其可能实现为：</p>
<pre><code class="cpp">template &lt;typename Iterator&gt;
std::move_iterator&lt;Iterator&gt; std::make_move_iterator(Iterator i) {
    return std::move_iterator&lt;Iterator&gt;(i);
}
</code></pre>
<p>例子：</p>
<pre><code class="cpp">int main() {
    std::list&lt;std::string&gt; s{&quot;one&quot;, &quot;two&quot;, &quot;three&quot;};

    std::vector&lt;std::string&gt; v1(s.begin(), s.end()); // copy

    std::vector&lt;std::string&gt; v2(std::make_move_iterator(s.begin()),
                                std::make_move_iterator(s.end())); // move

    std::cout &lt;&lt; &quot;v1 now holds: &quot;;
    for (auto str : v1)
            std::cout &lt;&lt; &quot;\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\&quot; &quot;;
    std::cout &lt;&lt; &quot;\nv2 now holds: &quot;;
    for (auto str : v2)
            std::cout &lt;&lt; &quot;\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\&quot; &quot;;
    std::cout &lt;&lt; &quot;\noriginal list now holds: &quot;;
    for (auto str : s)
            std::cout &lt;&lt; &quot;\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\&quot; &quot;;
    std::cout &lt;&lt; &#39;\n&#39;;
}

//v1 now holds: &quot;one&quot; &quot;two&quot; &quot;three&quot;
//v2 now holds: &quot;one&quot; &quot;two&quot; &quot;three&quot;
//original list now holds: &quot;&quot; &quot;&quot; &quot;&quot;
</code></pre>
<h3 id="流迭代器（ostream-iterator）"><a href="#流迭代器（ostream-iterator）" class="headerlink" title="流迭代器（ostream_iterator）"></a>流迭代器（<code>ostream_iterator</code>）</h3><h4 id="istream-iterator"><a href="#istream-iterator" class="headerlink" title="istream_iterator"></a><code>istream_iterator</code></h4><p>读取输入流，其使用<code>&gt;&gt;</code>操作符来读取流。<strong>因此， <code>istream_iterator</code>要读取的类型必须定义了输入运算符。</strong>当创建一个<code>istream_iterator</code>时，便可以将它绑定到一个流。</p>
<p>例子：</p>
<pre><code class="cpp">/// demo1
std::istream_iterator&lt;int&gt; int_iter(std::cin);        //从cin读取int
std::istream_iterator&lt;int&gt; in_eof;            //尾后迭代器
std::ifstream in(&quot;afile&quot;);
std::istream_iterator&lt;std::string&gt; str_iter(in);    //从afile读取字符串

///demo2
int main() {
    std::istringstream stream(&quot;1 2 3 4 5&quot;);
    std::copy(
        std::istream_iterator&lt;int&gt;(stream),
        std::istream_iterator&lt;int&gt;(),
        std::ostream_iterator&lt;int&gt;(std::cout, &quot; &quot;)
    );
}
// 1 2 3 4 5

///demo3  用istream_iterator从标准输入读取数据，存入vector
std::istream_iterator&lt;int&gt; in_iter(std::cin);
std::istream_iterator&lt;int&gt; eof;
while(in_iter != eof) {
    vec.push_back(*in_iter++);
}
</code></pre>
<h4 id="ostream-iterator"><a href="#ostream-iterator" class="headerlink" title="ostream_iterator"></a><code>ostream_iterator</code></h4><p>构造函数为：</p>
<pre><code class="cpp">///以stream为关联流（associated stream），并且以delim作为分隔符（delimiter）
ostream_iterator(ostream_type&amp; stream, const CharT* delim);
///以stream为关联流（associated stream），并且以空指针（null pointer）作为分隔符（delimiter）
ostream_iterator(ostream_type&amp; stream);
</code></pre>
<p>例子：</p>
<pre><code class="cpp">int main(){
    std::istringstream str(&quot;0.1 0.2 0.3 0.4&quot;);
    std::partial_sum(std::istream_iterator&lt;double&gt;(str),
        std::istream_iterator&lt;double&gt;(),
        std::ostream_iterator&lt;double&gt;(std::cout,&quot; &quot;));
}
/// 0.1 0.3 0.6 1
</code></pre>
<p><strong><code>std::partial_sum</code></strong><br>可能实现为：</p>
<pre><code class="cpp">template &lt;typename InputIt, typename OutputIt&gt;
OutputIt partial_sum(InputIt first, InputIt last, OutputIt d_first) {
    if(first == last) return d_first;

    typename std::iterator_traits&lt;InputIt&gt;::value_type sum = *first;
    *d_first = sum;

    while(++first != last) {
        sum = std::move(sum) + *first;
        *++d_first = sum;
    }
    return ++d_first;
}
</code></pre>
<p>例子：</p>
<pre><code class="cpp">std::vector&lt;int&gt; vec = {1,2,3,4};
//partial_sum &lt;numeric&gt;
std::partial_sum(vec.begin(), vec.end(), std::multiplies&lt;int&gt;());
///1 2 6 24
</code></pre>
<h2 id="variadic-function"><a href="#variadic-function" class="headerlink" title="variadic function"></a>variadic function</h2><p>variadic function是使用可变数量参数的函数（例如<code>printf</code>）。它在最后一个参数后加<code>...</code>声明，例如 int printf(const char* format, …); 。定义在<code>&lt;stdarg.h&gt;</code>头文件中。</p>
<h3 id="1-va-list："><a href="#1-va-list：" class="headerlink" title="1. va_list："></a>1. <code>va_list</code>：</h3><p>其实现为：</p>
<pre><code class="cpp">typedef char* va_list;
</code></pre>
<p>它是一个complete object，用于保存<code>va_start</code>，<code>va_copy</code>，<code>va_arg</code>和<code>va_end</code>的信息。</p>
<p>若创建一个<code>va_list</code>实例，并将其传递给另一个函数，则在该函数中需要通过<code>va_arg</code>来使用它。此外，在此调用方函数中的任何后继调用必须继续调用<code>va_end</code>。</p>
<h3 id="2-va-start："><a href="#2-va-start：" class="headerlink" title="2. va_start："></a>2. <code>va_start</code>：</h3><pre><code class="cpp">void va_start( va_list ap, parmN );
</code></pre>
<p>使函数能访问参数<code>parmN</code>之后的可变参数。在任何对<code>va_arg</code>的调用前，需要使用合法的<code>va_list</code>对象<code>ap</code>调用<code>va_start</code>。其实现为：</p>
<pre><code class="cpp">#define va_list(list,param1) (list=(va_list)&amp;param1+sizeof(param1))
</code></pre>
<p>【注】其中路<code>list</code>是类型为<code>va_list</code>的指针，<code>param1</code>是可变参数最左边的参数</p>
<h3 id="4-va-arg"><a href="#4-va-arg" class="headerlink" title="4. va_arg"></a>4. <code>va_arg</code></h3><pre><code class="cpp">T va_arg( va_list ap, T );
</code></pre>
<p>它将展开成<code>T</code>类型的表达式（此表达式对应<code>va_list ap</code>的下个参数）。</p>
<p>调用<code>va_arg</code>前，必须调用<code>va_start</code>或<code>va_copy</code>初始化<code>ap</code>，中间不能有<code>va_end</code>调用。每次调用<code>va_arg</code>宏都会修改<code>ap</code>，令它指向下一个可变参数。</p>
<p>其实现为：</p>
<pre><code class="cpp">#define va_arg(list,mode) ((mode*)(list+=sizeof(mode)))[-1]
</code></pre>
<h3 id="4-va-end"><a href="#4-va-end" class="headerlink" title="4. va_end"></a>4. <code>va_end</code></h3><p>清空<code>va_list</code>或许<code>var_copy</code>进行初始化的可变参数列表。</p>
<p>可能实现为：</p>
<pre><code class="cpp">#define va_end(list） （list=（va_list）0）
</code></pre>
<p>【注】：以上<code>sizeof()</code>只是为了说明工作原理，实际实现中，增加的字节数需要保证为int的整数倍。例如：</p>
<pre><code class="cpp">#define _INTSIZEOF(n) ((SIZEOF(n)+sizeof(int)-1)&amp;~(sizeof(int)-1))
</code></pre>
<p>最复杂的宏是<code>va_arg</code>，它必须返回一个由<code>va_list</code>所指向的恰当的类型的数值，同时递增<code>va_list</code>，使它指向参数列表中的一个参数（即递增的大小等于<code>va_arg</code>宏所返回的数值具有相同类型的对象的长度）。因为类型转换的结果不能作为赋值运算的目标，所以<code>va_arg</code>宏首先使用<code>sizeof</code>来确定需要递增的大小，然后把它直接加到<code>va_list</code>上，这样得到的指针再转换为要求的类型。因为该指针现在指向的“过”了一个类型单位的大小，所以使用下标<code>-1</code>来存取正确的返回参数。</p>
<p>例子：</p>
<pre><code class="cpp">/// demo1
int add_nums(int count,...){
    int result=0;
    va_list args;
    va_start(args,count);
    for(int i=0;i&lt;count;i++){
        result+=va_arg(args,int);
    }
    va_end(args);
    return result;
}

int main(){
    std::cout&lt;&lt;add_nums(4,1,2,3,4)&lt;&lt;std::endl;
}
///    10

///demo2：定制错误打印函数error
void error(char* format, ...) {
    va_list al;
    va_start(al, format);
    fprintf(stderr, &quot;error: &quot;);
    vfprintf(stderr, format, al);
    va_end(al);
    fprintf(stderr, &quot;\n&quot;);
    return;
}
</code></pre>
<h2 id="variadic-template"><a href="#variadic-template" class="headerlink" title="variadic template"></a>variadic template</h2><p>对于variadic template，我们无法直接获取参数包（parameter pack）中的每个参数，只能通过展开（expand）参数包的方式，来获取参数包中的每个参数，这就是使用variadic template的主要特征，但这也是最大的难点：<strong>如何展开variadic template parameter</strong>。</p>
<p>展开variadic template function有两种方法：</p>
<ul>
<li>通过递归函数来展开参数包</li>
<li>通过逗号表达式（comma expression）来展开参数包</li>
</ul>
<h3 id="通过递归函数来展开参数包"><a href="#通过递归函数来展开参数包" class="headerlink" title="通过递归函数来展开参数包"></a>通过递归函数来展开参数包</h3><p>使用这种方法时，需<strong>要提供一个参数包展开函数和一个递归终止函数（用于终止递归）</strong>。</p>
<p>例子：</p>
<pre><code class="cpp">/// Recursive termination function
void print() {
    std::cout&lt;&lt;&quot;empty&quot;&lt;&lt;std::endl;
}

///    expansion function
template &lt;typename T, typename...Args&gt;
void print(T head, Args...args) {
    std::cout&lt;&lt;&quot;parameter &quot;&lt;&lt;head&lt;&lt;std::endl;
    print(args...);
}

int main() {
    print(1,2,3,4);
}

///    parameter 1
///    parameter 2
///    parameter 3
///    parameter 4
///    empty
</code></pre>
<p>递归调用的过程为：</p>
<pre><code class="cpp">print(1,2,3,4);
print(2,3,4);
print(3,4);
print(4);
print();
</code></pre>
<p>例子：</p>
<pre><code class="cpp">/// 用于求和
template &lt;typename T&gt;
T sum(T t) {
    return t;
}

template &lt;typename T, typename...Args&gt;
T sum(T head, Args...args) {
    return head+sum&lt;T&gt;(args...);
}

int main() {
    std::cout&lt;&lt;sum(1,2,3,4)&lt;&lt;std::endl;
}

///    10
</code></pre>
<h3 id="逗号表达式展开参数包"><a href="#逗号表达式展开参数包" class="headerlink" title="逗号表达式展开参数包"></a>逗号表达式展开参数包</h3><p>递归函数展开参数包是一种标准做法，也比较好理解，但也有一个缺点：<strong>必须要一个重载的递归终止函数（即必须要有一个同名的终止函数来终止递归，这样可能会造成不便）</strong>。借助逗号表达式和初始化列表可以解决这一问题。</p>
<p>例子：</p>
<pre><code class="cpp">///    用comma expression改写之前的print
template &lt;class T&gt;
void print(T t) {
   std::cout &lt;&lt; t &lt;&lt; std::endl;
}

template &lt;class ...Args&gt;
void expand(Args... args) {
   int arr[] = {(print(args), 0)...};
}

int main() {
    expand(1,2,3,4);
}
///    1
///    2
///    3
///    4
</code></pre>
<p>这种展开参数包的方式，不需要通过递归终止函数，而是直接在<code>expand</code>函数体中展开，<code>print</code>不再是一个递归终止函数，而只是一个处理参数包中每一个参数的函数。这种方式的关键是逗号表达式（comma expression）。逗号表达式会按顺序执行逗号前面的表达式，比如：</p>
<pre><code class="cpp">d = (a = b, c); 
</code></pre>
<p>这个表达式会按顺序执行为：<code>b</code>会先赋值给<code>a</code>，接着括号中的逗号表达式返回<code>c</code>的值，因此<code>d</code>将等于<code>c</code>。</p>
<p><code>expand</code>中的逗号表达式<code>(print(args), 0)</code>也是按照这个顺序执行。先执行<code>print(args)</code>，再根据逗号表达式的特性，得到结果<code>0</code>。此外还用到了C++11的initializer list特性。</p>
<p>通过initializer list来初始化一个变长数组，<code>{(print(args), 0)...}</code>将会展开成<code>((print(arg1),0), (print(arg2),0), (print(arg3),0),  ... )</code>。最终会创建一个元素值都为<code>0</code>的数组：<code>int arr[sizeof...(Args)]</code>。由于是逗号表达式，在创建数组的过程中，首先会执行逗号表达式中的<code>print(args)</code>，打印出参数（即在构造<code>int</code>数组的过程中就已经将参数包展开了，这个数组是为了在数组构造的过程中展开参数包）。</p>
<p>将上面的例子改进一下：将函数作为参数，便可以支持lambda expression，从而可以少写一个递归终止函数。</p>
<pre><code class="cpp">template &lt;typename F, typename...Args&gt;
void expand(const F&amp; f, Args...args) {
    std::initializer_list&lt;int&gt;{(f(std::forward&lt;Args&gt;(args)),0)...};
}
int main() {
    expand([](int i) {
        std::cout&lt;&lt;i&lt;&lt;std::endl;
    },1,2,3);
}
///    1
///    2
///    3
</code></pre>
<p>如果使用C++14的generic lambda，则可以写更泛化的lambda表达式：</p>
<pre><code class="cpp">expand([](auto i) {
    std::cout&lt;&lt;i&lt;&lt;std::endl;
}, 1,2.0,”test”);
</code></pre>
<h3 id="variadic-template-class"><a href="#variadic-template-class" class="headerlink" title="variadic template class"></a>variadic template class</h3><p>variadic template class的展开（expansion）一般需要以下几个declaration：类声明（class declaration）和偏特化模板类（partial template specialization）。</p>
<p>例子：</p>
<pre><code class="cpp">///此demo用于在编译期计算parameter pack中参数类型的size之和

///    forwarding declaration
/// 声明Sum类是一个variadic template class
template &lt;typename...Args&gt;
struct Sum;

///    primary template definition
/// 定义了一个部分展开的variadic template class，它告诉编译器如何递归地展开parameter pack
template &lt;typename Head, typename...Rest&gt;
struct Sum&lt;Head, Rest...&gt; {
    enum {
        value=Sum&lt;Head&gt;::value+Sum&lt;Rest...&gt;::value
    };
};

/// terminate the recursion
template &lt;typename Tail&gt;
struct Sum&lt;Tail&gt; {
    enum {
        value=sizeof(Tail)
    };
};

int main(){
    std::cout&lt;&lt;Sum&lt;int,int,int&gt;::value&lt;&lt;std::endl;
}
</code></pre>
<p>其实可以将上述的forwarding declaration进行更改，现在要求<code>Sum</code>的模板参数至少有一个，因为variadic template class的模板参数可以为<code>0</code>个（有时候<code>0</code>个模板参数没有意义），于是就可以通过下面的声明方式，来限定模板参数不能为<code>0</code>个。上面的这种三段式的定义也可以改为两段式的，可以将forwarding declaration去除：</p>
<pre><code class="cpp">template&lt;typename Head, typename... Rest&gt;
struct Sum {
    enum { 
        value = Sum&lt;Head&gt;::value + Sum&lt;Rest...&gt;::value 
    };
};

template&lt;typename Tail&gt;
struct Sum&lt;Tail&gt; {
    enum { 
        value = sizeof(Tail) 
    };
};
</code></pre>
<p>递归终止模板类可以有多种写法，比如上例的递归终止模板类还可以这样写：</p>
<pre><code class="cpp">template&lt;typename... Args&gt; struct Sum;

template&lt;typename Head, typename Tail&gt;
struct Sum&lt;Head, Tail&gt; { 
    enum { 
        //在展开到最后两个参数时终止
        value = sizeof(First) +sizeof(Last) 
    };
};
</code></pre>
<p>在展开到<code>0</code>个参数时终止：</p>
<pre><code class="cpp">template&lt;&gt;
struct Sum&lt;&gt; { 
    enum{ value = 0 }; 
};
</code></pre>
<p>可以使用<code>std::integral_constant</code>来消除枚举定义<code>value</code>。由于<code>std::integral_constant</code>可以获得编译期常量，可以将之前的<code>Sum</code>例子进行改写：</p>
<pre><code class="cpp">///    forwarding decla
template&lt;typename Head, typename... Args&gt;
struct Sum;

///    primary template class
template&lt;typename Head, typename... Rest&gt;
struct Sum&lt;Head, Rest...&gt; : std::integral_constant&lt;int, Sum&lt;Head&gt;::value + Sum&lt;Rest...&gt;::value&gt; { };

///    terminate the recursion
template&lt;typename Tail&gt;
struct Sum&lt;Tail&gt; : std::integral_constant&lt;int, sizeof(Tail)&gt; { };
</code></pre>
<h3 id="通过继承方式展开参数包"><a href="#通过继承方式展开参数包" class="headerlink" title="通过继承方式展开参数包"></a>通过继承方式展开参数包</h3><p>例子：</p>
<pre><code class="cpp">/// 整形序列的定义
template&lt;int...&gt;
struct index_sequence { };

//通过继承方式，开始展开参数包
template&lt;int N, int... Indices&gt;
struct make_index : make_index&lt;N - 1, N - 1, Indices...&gt; { };

// 模板特化，终止展开参数包的条件
template&lt;int... Indices&gt;
struct make_index&lt;0, Indices...&gt; {
    typedef index_sequence&lt;Indices...&gt; type;
};

int main() {
    using T = make_index&lt;3&gt;::type;
    std::cout &lt;&lt;typeid(T).name() &lt;&lt; std::endl;
}
///    struct index_sequence&lt;0,1,2&gt;
</code></pre>
<p>其中<code>make_index</code>的作用是为了生成一个variadic template class的整数序列。</p>
<p><code>make_index</code>继承于自身的一个特化模板（template specialization），此特化模板同时也在展开参数包，这个展开过程是通过继承发起的，直到遇到特化的终止条件，展开过程才结束。</p>
<p><code>make_index&lt;1,2,3&gt;::type</code>的展开过程是这样的：</p>
<pre><code class="cpp">make_index&lt;3&gt; : make_index&lt;2, 2&gt;{ }
make_index&lt;2, 2&gt; : make_index&lt;1, 1, 2&gt;{ }
make_index&lt;1, 1, 2&gt; : make_index&lt;0, 0, 1, 2&gt; {
    typedef index_sequence&lt;0, 1, 2&gt; type;
}
</code></pre>
<p>通过不断的继承递归调用，最终得到整型序列<code>index_sequence&lt;0, 1, 2&gt;</code>。如果不希望通过继承方式生成整形序列，则可以通过下面的方式生成：</p>
<pre><code class="cpp">template&lt;int N, int... Indices&gt;
struct make_index {
    using type = typename make_index&lt;N - 1, N - 1, Indices...&gt;::type;
};

template&lt;int... Indices&gt;
struct make_index&lt;0, Indices...&gt; {
    typedef index_sequence&lt;Indices...&gt; type;
};
</code></pre>
<h3 id="利用variadic-template去除repeated-code"><a href="#利用variadic-template去除repeated-code" class="headerlink" title="利用variadic template去除repeated code"></a>利用variadic template去除repeated code</h3><p>C++11之前如果要写一个泛化的工厂函数，这个工厂函数能接受任意类型的参数，并且参数的个数要能满足大部分的应用需求的话，就不得不定义很多重复的模版定义：</p>
<pre><code class="cpp">template&lt;typename T&gt;
T* Instance() {
    return new T();
}

template&lt;typename T, typename T0&gt;
T* Instance(T0 arg0) {
    return new T(arg0);
}

template&lt;typename T, typename T0, typename T1&gt;
T* Instance(T0 arg0, T1 arg1) {
    return new T(arg0, arg1);
}

template&lt;typename T, typename T0, typename T1, typename T2&gt;
T* Instance(T0 arg0, T1 arg1, T2 arg2) {
    return new T(arg0, arg1, arg2);
}

template&lt;typename T, typename T0, typename T1, typename T2, typename T3&gt;
T* Instance(T0 arg0, T1 arg1, T2 arg2, T3 arg3) {
    return new T(arg0, arg1, arg2, arg3);
}

template&lt;typename T, typename T0, typename T1, typename T2, typename T3, typename T4&gt;
T* Instance(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4) {
    return new T(arg0, arg1, arg2, arg3, arg4);
}
struct A {
    A(int){}
};

struct B {
    B(int,double){}
};

A* pa = Instance&lt;A&gt;(1);
B* pb = Instance&lt;B&gt;(1,2);
</code></pre>
<p>这个泛型工厂函数存在大量的重复的模板定义，并且限定了模板参数。用variadic template可以消除重复，同时可以去掉参数数量的限制。优化后的工厂函数如下：</p>
<pre><code class="cpp">template&lt;typename…  Args&gt;
T* Instance(Args&amp;&amp;… args) {
    return new T(std::forward&lt;Args&gt;(args)…);
}

A* pa = Instance&lt;A&gt;(1);
B* pb = Instance&lt;B&gt;(1,2);
</code></pre>
<h3 id="利用variadic-template实现C-中的delegate"><a href="#利用variadic-template实现C-中的delegate" class="headerlink" title="利用variadic template实现C#中的delegate"></a>利用variadic template实现C#中的delegate</h3><p>C#中的delegate的基本用法：</p>
<pre><code class="cpp">///    声明委托类型
delegate int AggregateDelegate(int x, int y);

int Add(int x, int y){return x+y;}
int Sub(int x, int y){return x-y;}

AggregateDelegate add = Add;
add(1,2);                                        //调用委托对象求和
AggregateDelegate sub = Sub;
sub(2,1);                                        // 调用委托对象相减
</code></pre>
<p>C#在使用delegate时，需要先定义一个delegate类型，这个delegate类型不能泛化（即delegate类型一旦声明之后，就不能再用来接受其它类型的函数）。例如：</p>
<pre><code class="cpp">int Fun(int x, int y, int z) { return x+y+z;}
int Fun1(string s, string r) { return s.Length+r.Length; }
AggregateDelegate fun = Fun;         //编译报错，只能赋值相同类型的函数
AggregateDelegate fun1 = Fun1;      //编译报错，参数类型不匹配
</code></pre>
<p>这里不能泛化的原因是：声明delegate类型的时候就限定了参数类型和数量。利用variadic template实现一个功能更加泛化的C++版本的delegate：</p>
<pre><code class="cpp">template &lt;typename T, typename R, typename...Args&gt;
struct delegate {
public:
    delegate(T* t, R (T::*f)(Args...))
    :m_t(t),m_f(f) {}

    R operator()(Args&amp;&amp;...args) {
        return (m_t-&gt;*m_f)(std::forward&lt;Args&gt;(args)...);
    }
private:
    T* m_t;
    R (T::*m_f)(Args...);
};

template &lt;typename T, typename R, typename...Args&gt;
delegate&lt;T, R, Args...&gt; create_delegate(T* t, R (T::*f)(Args...)) {
    return delegate&lt;T, R, Args...&gt;(t, f);
}

struct A {
    void Fun(int i) { std::cout&lt;&lt;i&lt;&lt;std::endl; }
    void Fun1(int i, double j) { std::cout&lt;&lt;i+j&lt;&lt;std::endl; }
};

int main() {
    A a;
    auto d1=create_delegate(&amp;a, &amp;A::Fun);
    d1(1);
    auto d2 = create_delegate(&amp;a, &amp;A::Fun1); 
    d2(1, 2.5); 
}                                              
</code></pre>
<p><code>delegate</code>实现的关键是内部定义了一个能接受任意类型和数量参数的universal function：<code>R (T::*m_f)(Args...)</code>。正是由于variadic template的特性，所以才能够让<code>m_f</code>接受任意参数。</p>
<h2 id="如何打印variadic-template-parameter"><a href="#如何打印variadic-template-parameter" class="headerlink" title="如何打印variadic template parameter"></a>如何打印variadic template parameter</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><pre><code class="cpp">template &lt;typename T&gt;
void print(T t) {
    std::cout&lt;&lt; t &lt;&lt;std::endl;
}

template &lt;typename T, typename...Args&gt;
void print(T t, Args...args&gt; {
    print(t);
    print(args...);
}
</code></pre>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><pre><code class="cpp">template &lt;typename T&gt;
void print(T t) {
    std::cout&lt;&lt; t &lt;&lt;std::endl;
}

template &lt;typename...Args&gt;
void print_impl(Args...args) {
    std::initializer_list&lt;int&gt;{ (print(args),0)... };
}
</code></pre>
<h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><pre><code class="cpp">template &lt;typename...Args&gt;
void print(Args...args) {
    std::initializer_list&lt;int&gt; {
        ([&amp;]{std::cout&lt;&lt; args &lt;&lt;std::endl;}(),0)...};
}

template &lt;typename...Args&gt;
void print_impl(Args...args) {
    std::initializer_list&lt;int&gt;{(std::cout&lt;&lt; args &lt;&lt;std::endl,0 )...};
}

int main() {
    print(1,2,3,4);
    print_impl(1,2,3,4);
}
</code></pre>
<h3 id="方法四"><a href="#方法四" class="headerlink" title="方法四"></a>方法四</h3><pre><code class="cpp">///    当到达tuple的最后一个元素时，便什么也不做
template &lt;std::size_t I=0, typename Tuple&gt;
typename std::enable_if&lt;I==std::tuple_size&lt;Tuple&gt;::value&gt;::type print(Tuple t) {}

template &lt;std::size_t I=0, typename Tuple&gt;
typename std::enable_if&lt;I &lt; std::tuple_size&lt;Tuple&gt;::value&gt;::type print(Tuple t) {
    std::cout&lt;&lt;std::get&lt;I&gt;(t)&lt;&lt;std::endl;
    print&lt;I+1&gt;(t);
}

template &lt;typename...Args&gt;
void print_impl(Args...args) {
    print(std::make_tuple(args...));
}

int main() {
    print_impl(1,3,5,7);
}
</code></pre>
<h3 id="方法五"><a href="#方法五" class="headerlink" title="方法五"></a>方法五</h3><pre><code class="cpp">template &lt;int N&gt;
struct printer{
public:
    template &lt;typename Tuple&gt;
    static void print(const Tuple&amp; t) {
        printer&lt;N-1&gt;::print(t);
        std::cout&lt;&lt;std::get&lt;N-1&gt;(t)&lt;&lt;std::endl;    //ascending order
    }
};

template &lt;&gt;
struct printer&lt;0&gt; {
public:
    template &lt;typename Tuple&gt;
    static void print(const Tuple&amp; t) {}
};

template &lt;typename...Args&gt;
void print_impl(const Args...args) {
    auto p=std::make_tuple(args...);
    printer&lt;sizeof...(args)&gt;::print(p);
}

int main() {
    print_impl(1,2,3,4);
}
</code></pre>
<h3 id="方法六"><a href="#方法六" class="headerlink" title="方法六"></a>方法六</h3><pre><code class="cpp">template &lt;int...&gt;
struct index_tuple {};

template &lt;int N, int...Indices&gt;
struct make_index : make_index&lt;N-1, N-1, Indices...&gt; {};

template &lt;int...Indices&gt;
struct make_index&lt;0, Indices...&gt; {
    typedef index_tuple&lt;Indices...&gt; type;
};

template &lt;int...Indices, typename...Args&gt;
void print_helper(index_tuple&lt;Indices...&gt;, std::tuple&lt;Args...&gt;&amp;&amp; t) {
    std::initializer_list&lt;int&gt;{ ([&amp;]{std::cout&lt;&lt;std::get&lt;Indices&gt;(t)&lt;&lt;std::endl;}(), 0)...};
}

template &lt;typename...Args&gt;
void print(Args...args) {
    print_helper(typename make_index&lt;sizeof...(Args)&gt;::type(), std::make_tuple(args...));
}

int main() {
    print(0,1,2,3);
}
</code></pre>
<p>先将参数包转换为<code>tuple</code>，接着又将<code>tuple</code>转换为参数包。</p>
<h2 id="variadic-template的应用"><a href="#variadic-template的应用" class="headerlink" title="variadic template的应用"></a>variadic template的应用</h2><h3 id="在compile-time获取一个integer-sequence中的最大值"><a href="#在compile-time获取一个integer-sequence中的最大值" class="headerlink" title="在compile-time获取一个integer sequence中的最大值"></a>在compile-time获取一个integer sequence中的最大值</h3><pre><code class="cpp">template &lt;std::size_t Head, std::size_t...Rest&gt;
struct integer_sequence {};

template &lt;std::size_t Head&gt;
struct integer_sequence&lt;Head&gt; : std::integral_constant&lt;std::size_t, Head&gt; {};

template &lt;std::size_t Head, std::size_t Next, std::size_t...Rest&gt;
struct integer_sequence&lt;Head, Next, Rest...&gt; 
: std::integral_constant&lt;std::size_t, 
                        Head &gt;= Next? integer_sequence&lt;Head, Rest...&gt;::value:integer_sequence&lt;Next, Rest...&gt;::value&gt; {};

int main() {
    std::cout&lt;&lt; integer_sequence&lt;1,2,3,4&gt;::value &lt;&lt;std::endl;
}
</code></pre>
<h3 id="获取众多类型中的size的最大值"><a href="#获取众多类型中的size的最大值" class="headerlink" title="获取众多类型中的size的最大值"></a>获取众多类型中的size的最大值</h3><pre><code class="cpp">template &lt;typename...Args&gt;
struct max_align : std::integral_constant&lt;int, 
                    integer_sequence&lt;std::alignment_of&lt;Args&gt;::value...&gt;::value&gt; {};
</code></pre>
<h4 id="std-alignment-of"><a href="#std-alignment-of" class="headerlink" title="std::alignment_of"></a><code>std::alignment_of</code></h4><p>对外提供类型<code>T</code>的alignment的member constant value，如同用<code>alignof</code>表达式获得。如果<code>T</code>是数组类型，则返回元素类型的alignment requiremet；如果<code>T</code>是引用类型，则返回引用所指向的元素的alignment requirement。</p>
<p>可能实现为：</p>
<pre><code class="cpp">template &lt;typename T&gt;
struct aligement_of : std::integral_constant&lt; std::size_t, alignof(T)&gt; {};
</code></pre>
<h3 id="判断是否包含某个类型"><a href="#判断是否包含某个类型" class="headerlink" title="判断是否包含某个类型"></a>判断是否包含某个类型</h3><pre><code class="cpp">template &lt;typename T, typename...Rest&gt;
struct Contains;

template &lt;typename T, typename Head, typename...Rest&gt;
struct Contains&lt;T, Head, Rest...&gt; 
        : std::conditional&lt; std::is_same&lt;T, Head&gt;::value, 
            std::true_type, Contains&lt;T, Rest...&gt;&gt;::type {};

template &lt;typename T&gt;
struct Contains&lt;T&gt; : std::false_type {};

int main() {
    std::cout&lt;&lt;std::boolalpha;
    std::cout&lt;&lt; Contains&lt;int,short,char,int,double&gt;::value &lt;&lt;std::endl;
}
</code></pre>
<h3 id="获取类型的索引"><a href="#获取类型的索引" class="headerlink" title="获取类型的索引"></a>获取类型的索引</h3><pre><code class="cpp">template &lt;typename T, typename...Rest&gt;
struct index_of;

template &lt;typename T, typename Head, typename...Rest&gt;
struct index_of&lt;T, Head, Rest...&gt; {
    enum {
        value=index_of&lt;T, Rest...&gt;::value+1
    };
};

template &lt;typename T, typename...Rest&gt;
struct index_of&lt;T, T, Rest...&gt; {
    enum { value=0 };
};

template &lt;typename T&gt;
struct index_of&lt;T&gt; {
    enum { value=-1 };
};
</code></pre>
<h3 id="在编译器遍历类型"><a href="#在编译器遍历类型" class="headerlink" title="在编译器遍历类型"></a>在编译器遍历类型</h3><pre><code class="cpp">template &lt;typename T&gt;
void print() {
    std::cout&lt;&lt; typeid(T).name() &lt;&lt;std::endl;
}

template &lt;typename...Args&gt;
void for_each() {
    std::initializer_list&lt;int&gt;{ (print&lt;Args&gt;(), 0)... };
}
</code></pre>
<h3 id="function-traits"><a href="#function-traits" class="headerlink" title="function traits"></a>function traits</h3><p>function_traits用来获取函数语义的可调用对象的一些属性，比如函数类型、返回类型、函数指针类型和参数类型等。</p>
<pre><code class="cpp">template &lt;typename T&gt;
struct function_traits;

template &lt;typename T, typename...Args&gt;
struct function_traits&lt;T(Args...)&gt; {
public:
    enum { size=sizeof...(Args) };
    using return_type=T;
    typedef T function_type(Args...);  
    using stl_function_type=std::function&lt;function_type&gt;;
    typedef T (*pointer)(Args...);

    template &lt;std::size_t I&gt;
    struct argument_type {
        static_assert(I&lt;size, &quot;index error&quot;);
        using type=typename std::tuple_element&lt;I, std::tuple&lt;Args...&gt;&gt;::type;
    };
};

/// function pointer
template &lt;typename T, typename...Args&gt;
struct function_traits&lt;T(*)(Args...)&gt; : 
            function_traits&lt;T(Args...)&gt;{};

/// std::function
template &lt;typename T, typename...Args&gt;
struct function_traits&lt;std::function&lt;T(Args...)&gt;&gt; :
            function_traits&lt;T(Args...)&gt; {};

/// member function
#define FUNCTION_TRAITS(...) \
    template &lt;typename RetrurnType, typename ClassType, typename...Args&gt; \
    struct function_traits&lt;RetrurnType(ClassType::*)(Args...) __VA_ARGS__&gt;： \
            function_traits&lt;RetrurnType(Args...)&gt;{}; \

FUNCTION_TRAITS()
FUNCTION_TRAITS(const)
FUNCTION_TRAITS(volatile)
FUNCTION_TRAITS(const volatile)

/// function object
template &lt;typename Callable&gt;
struct function_traits : 
        function_traits&lt;decltype(&amp;Callable::operator())&gt; {};

template &lt;typename T&gt;
void print() {
    std::cout&lt;&lt; typeid(T).name() &lt;&lt;std::endl;
}

int main() {
    std::function&lt;int(int)&gt; fun=[](int a) { return a; };
    print&lt;function_traits&lt;std::function&lt;int(int)&gt;&gt;::function_type&gt;();    ///int __cdecl(int)
    print&lt;function_traits&lt;decltype(fun)&gt;::function_type&gt;();                   ///int __cdecl(int)
    std::cout&lt;&lt;function_traits&lt;decltype(fun)&gt;::size&lt;&lt;std::endl;            ///1
}
</code></pre>
<h3 id="根据索引查找类型"><a href="#根据索引查找类型" class="headerlink" title="根据索引查找类型"></a>根据索引查找类型</h3><pre><code class="cpp">template &lt;int Index, typename...Types&gt;
struct At;

template &lt;int Index, typename Head, typename...Types&gt;
struct At&lt;Index, Head, Types...&gt; {
    using type = typename At&lt;Index-1, Types...&gt;::type;
};

template &lt;typename T, typename...Types&gt;
struct At&lt;0, T, Types...&gt; {
    using type = T;
};

int main() {
    using type_ = At&lt;0,int,double,char&gt;::type;
    std::cout&lt;&lt; typeid(type_).name() &lt;&lt;std::endl;
}
</code></pre>
<h3 id="实现variant"><a href="#实现variant" class="headerlink" title="实现variant"></a>实现<code>variant</code></h3><pre><code class="cpp">template &lt;typename...Types&gt;
struct variant {
///实现variant，首先需要定义一个足够大的缓冲区用来存放不同的类型的值，这个缓类型冲区实际上是用来擦除类型的。不同的类型都通过placement new在这个缓冲区上创建对象，因为类型长度不同，所以需要考虑内存对齐。C++11提供了内存对齐的缓冲区aligned_storage。它的第一个参数是缓冲区的长度，第二个参数是缓冲区内存对齐的大小

///由于varaint可以接受多种类型，所以需要获取最大的type size，保证缓冲区足够大。然后还要获取最大的内存对齐大小，可以通过前面实现的integer_sequenece和max_align。varaint中内存对齐的缓冲区定义如下：
    enum {
        data_size = integer_sequence&lt;sizeof(Types...)&gt;::value;
        align_size = max_align&lt;Types...&gt;::value;
    };
    using data_t = typename std::aligned_storage&lt;data_size, align_size&gt;::type;        ///内存对齐的缓冲区类型
public:
    template &lt;int Index&gt;
    using index_type = typename At&lt;Index, Types...&gt;::type;

    variant(void):m_type_index(typeid(void)) {}
    variant(variant&lt;Types...&gt;&amp;&amp; old) : m_type_index(old.m_type_index) {
        move(old.m_type_index, &amp;old.m_data, &amp;m_data);
    }
    variant(const variant&lt;Types...&gt;&amp; old) : m_type_index(old.m_type_index) {
        copy(old.m_type_index, &amp;old.m_data, &amp;m_data);
    }
    ~variant() { destroy(m_type_index,&amp;m_data); }

///通过初始化列表和逗号表达式来展开variadic template，在展开的过程中查找对应的类型，如果找到了则直接析构。在variant构造时还需要注意，variant不能接受没有预先定义的类型。所以在构造variant时，需要限定类型必须在预定义的类型范围当中。此处通过enable_if来限定模板参数的类型。

///enbale_if的条件Contains的值，当没有在预定义的类型中找到对应的类型时，则Contains返回false，编译期会报一个编译错误。
    template &lt;typename T,
        typename = typename std::enable_if&lt;
            Contains &lt;
                typename std::remove_reference&lt;T&gt;::type, Types...&gt;
            ::value&gt;
        ::type&gt;
    variant(T&amp;&amp; value) : m_type_index(typeid(void)) {
        destroy(m_type_index, &amp;m_data);
        typedef typename std::remove_reference&lt;T&gt;::type U;
        new(&amp;m_data) U(std::forward&lt;T&gt;(value));
        m_type_index = type_index(typeid(U));
    }

    template &lt;typename T&gt;
    bool is() const {
        return (m_type_index == type_index(typeid(T)));
    }

    template &lt;typename Y&gt;
    typename std::decay&lt;T&gt;::type&amp; get() {
        typedef typename std::decay&lt;T&gt;::type U;
        if(!is&lt;U&gt;()) {
            std::cout&lt;&lt; typeid(U).name() &lt;&lt;&quot; is not defined. &quot;
                &lt;&lt; &quot;current type is &quot; &lt;&lt; m_type_index.name() &lt;&lt;std::endl;
            throw std::bad_cast();
        }
        return *(U*)(&amp;m_data);
    }

///visit的实现需要先通过定义一系列的访问函数，然后再遍历这些函数。遍历过程中，判断函数的第一个参数类型的type_index是否与当前的type_index相同，如果相同则获取当前类型的值。

///visit功能的实现利用了variadic template和function_traits通过variadic template来遍历一系列的访问函数遍历过程中，通过function_traits来获取第一个参数的类型。如果和variant当前的type_index相同的，则取值。

///为什么要获取访问函数第一个参数的类型呢？因为variant的值是唯一的，只有一个值，所以获取的访问函数的第一个参数的类型就是variant中存储的对象的实际类型。
    template &lt;typename T, typename...Rest&gt;
    void visit(T&amp;&amp; t, Rest&amp;&amp;...rest) {
        using Type = typename Function_traits&lt;T&gt;::template argument_type&lt;0&gt;::type;
        if(is&lt;Type&gt;()) {
            visit(std::forward&lt;T&gt;(t));
        }else {
            visit(std::forward&lt;Rest&gt;(rest)...);
        }
    }
private:

///还需要实现对缓冲区的构造、拷贝、析构和移动，因为variant重新赋值的时候需要将缓冲区中原来的类型析构掉，拷贝构造和移动构造时则需要拷贝和移动。以析构为例，需要根据当前的type_index来遍历variant的所有类型，找到对应的类型，然后调用该类型的析构函数。
    void destroy(const type_index&amp; index, void* buffer) {
        std::initializer_list&lt;int&gt; { (destory_helper&lt;Types&gt;(index, buffer), 0)...};
    }

     template &lt;typename T&gt;
     void destory_helper(const type_index&amp; index, void* data) {
         if(index == type_index(typeid(T))) {
             reinterpret_cast&lt;T*&gt;(data)-&gt; ~T();
         }
     }

     void move(const type_index&amp; old_t, void* old_v, void* new_v) {
         std::initializer_list&lt;int&gt; { (move_helper&lt;Types&gt;(old_t, old_v, new_v,), 0)...};
     }

     template &lt;typename T&gt;
     void move_helper(const type_index&amp; old_t, void* old_v, void* new_v) {
         if(old_t == type_index(typeid(T))) {
             new (new_v) T(std::move(*reinterpret_cast&lt;T*&gt;(old_v)));
         }
     }

     void copy(const type_index&amp; old_t, void* old_v, void* new_v) {
         std::initializer_list&lt;int&gt; { (copy_hepler&lt;Types&gt;(old_t, old_v, new_v), 0)...};
     }

     template &lt;typename T&gt;
     void copy_hepler(const type_index&amp; old_t, void* old_v, void* new_v) {
         if(old_t == type_index(typeid(T))) {
             new (new_v) T (*reinterpret_cast&lt;const T*&gt;(old_v));
         }
     }

 private:
     data_t m_data;
     std::type_index m_type_index;
};
</code></pre>
<h3 id="std-type-index"><a href="#std-type-index" class="headerlink" title="std::type_index"></a><code>std::type_index</code></h3><p><code>std::type_index</code>是一个<code>std::type_info</code>的wrapper，它可作为关联容器和关联无序容器的索引。它与<code>std::type_info</code>对象的关系通过一个指针联系，所以它为 CopyConstructible</p>
<p>它有一个member function：<code>name()</code>，返回<code>std::type_info</code>对象的name。</p>
<p>例子：</p>
<pre><code class="cpp">struct A {
    virtual ~A() {}
};

struct B : A {};
struct C : A {};

int main()
{
    std::unordered_map&lt;std::type_index, std::string&gt; type_names;

    type_names[std::type_index(typeid(int))] = &quot;int&quot;;
    type_names[std::type_index(typeid(double))] = &quot;double&quot;;
    type_names[std::type_index(typeid(A))] = &quot;A&quot;;
    type_names[std::type_index(typeid(B))] = &quot;B&quot;;
    type_names[std::type_index(typeid(C))] = &quot;C&quot;;

    int i;
    double d;
    A a;

    // note that we&#39;re storing pointer to type A
    std::unique_ptr&lt;A&gt; b(new B);
    std::unique_ptr&lt;A&gt; c(new C);

    std::cout &lt;&lt; &quot;i is &quot; &lt;&lt; type_names[std::type_index(typeid(i))] &lt;&lt; &#39;\n&#39;;
    std::cout &lt;&lt; &quot;d is &quot; &lt;&lt; type_names[std::type_index(typeid(d))] &lt;&lt; &#39;\n&#39;;
    std::cout &lt;&lt; &quot;a is &quot; &lt;&lt; type_names[std::type_index(typeid(a))] &lt;&lt; &#39;\n&#39;;
    std::cout &lt;&lt; &quot;b is &quot; &lt;&lt; type_names[std::type_index(typeid(*b))] &lt;&lt; &#39;\n&#39;;
    std::cout &lt;&lt; &quot;c is &quot; &lt;&lt; type_names[std::type_index(typeid(*c))] &lt;&lt; &#39;\n&#39;;
}
///    i is int
///    d is double
///    a is A
///    b is B
///    c is C
</code></pre>
<h4 id="std-type-index与std-type-info的区别"><a href="#std-type-index与std-type-info的区别" class="headerlink" title="std::type_index与std::type_info的区别"></a><code>std::type_index</code>与<code>std::type_info</code>的区别</h4><blockquote>
<p><code>type_index</code> is “a simple wrapper for <code>type_info</code> which can be used as an index type in associative containers (23.4) and in unordered associative containers (23.5)”. If you use <code>type_index</code> instead of <code>type_info*</code>, you will free yourself from having to provide an explicit comparator in your maps. The only cost is that you need to <code>#include &lt;typeindex&gt;</code>.</p>
</blockquote>
<h4 id="std-aligned-storage"><a href="#std-aligned-storage" class="headerlink" title="std::aligned_storage"></a><code>std::aligned_storage</code></h4><p>定义在<code>&lt;type_traits&gt;</code>，其可能实现为：</p>
<pre><code class="cpp">template &lt;std::size_t Len, std::size_t Align /* default alignment not implemented */&gt;
struct aligned_storage {
    struct type {
        alignas(Align) unsigned char data[Len];
    };
};
</code></pre>
<p>提供一个nested type（为trivial standard-layout type），可以作为任何大小至多为<code>Len</code>，对齐要求为<code>Align</code>的对象的uninitialized storage。</p>
<p><code>Align</code>的默认值是大小至多为<code>Len</code>的对象的最大对齐要求。若不使用默认值，则<code>Align</code>的大小为<code>alignof(T)</code>，否则UB。若<code>Len == 0</code>，则UB。</p>
<p>例子：</p>
<pre><code class="cpp">template &lt;typename T, std::size_t N&gt;
struct static_vector {
    typename std::aligned_storage&lt;sizeof(T), alignof(T)&gt;::type data[N];
    std::size_t m_size = 0;
public:
    // create an object in aligned storage
    template &lt;typename...Args&gt;
    void emplace_back(Args...args) {
        if(m_size &gt;= N)    throw std::bad_alloc{};
    new(data+m_size) T(std::forward&lt;Args&gt;(args)...);
    ++m_size;
    }

    // acess an object in aligned storage
    const T&amp; operator[](std::size_t pos) const {
        return *reinterpret_cast&lt;const T*&gt;(data+pos);
    }

    //delete objects from aligned object
    ~static_vector() {
        for(std::size_t pos=0; pos&lt;m_size; ++pos) {
            reinterpret_cast&lt;const T*&gt;(data+pos)-&gt; ~T();
        }
    }
};

int main() {
    static_vector&lt;std::string,5&gt; v1;
    v1.emplace_back(5, &#39;*&#39;);
    v1.emplace_back(10, &#39;*&#39;);
    std::cout&lt;&lt; v1[0] &lt;&lt;&#39;\n&#39; &lt;&lt;v1[1] &lt;&lt;&#39;\n&#39;;
}
/// *****
/// **********
</code></pre>
<p>扩展：<a href="https://stackoverflow.com/questions/28187732/placement-new-in-stdaligned-storage" target="_blank" rel="noopener">Placement new in std::aligned_storage?</a></p>
<h4 id="std-forward-lt-Args-gt-or-std-forward-lt-Args-gt"><a href="#std-forward-lt-Args-gt-or-std-forward-lt-Args-gt" class="headerlink" title="std::forward&lt;Args&gt; or std::forward&lt;Args...&gt;"></a><code>std::forward&lt;Args&gt;</code> or <code>std::forward&lt;Args...&gt;</code></h4><pre><code class="cpp">template &lt;typename... Args&gt;
void foo(Args&amp;&amp;... args) {
    bar(std::forward&lt;Args&gt;(args)...);      // #1
    bar(std::forward&lt;Args...&gt;(args)...);   // #2
}
</code></pre>
<p>在上述代码中，正确的是<code>#1</code>。如果参数包为空，则<code>#1</code>会扩展为<code>bar()</code>，它为valid。但<code>#2</code>将会扩展为<code>bar(std::forward&lt;&gt;())</code>，它为ill-formed，因为<code>forward</code>丢失了它的参数。</p>
<p>如果参数包有一个元素，则两个都会扩展为<code>bar(std::forward&lt;T&gt;(t))</code>，它们都是valid。</p>
<p>如果参数包有两个元素，则<code>#1</code>将扩展为<code>bar(std::forward&lt;T1&gt;(t1), std::forward&lt;T2&gt;(t2))</code>，它为valid。但<code>#2</code>会扩展为<code>std::forward&lt;T1, T2&gt;(t1, t2))</code>，然而它们是ill-formed，因为<code>std::forward</code>只能拥有一个template parameter和一个function parameter。</p>
<p>所以，<code>#1</code>总是valid，但<code>#2</code>只在参数包只有一个元素时才是valid（况且，当只有一个template parameter时，为何还要使用variadic template呢）。</p>
<h4 id="alignas"><a href="#alignas" class="headerlink" title="alignas"></a><code>alignas</code></h4><p><code>alignas</code>可用于变量（variable）或非位域类数据成员（non-bitfield class data member）的声明，或用于<code>class</code>、<code>struct</code>、<code>union</code> 或<code>enum</code>的声明或定义。它不能用于函数参数或<code>catch</code>与句的异常参数。</p>
<blockquote>
<p>The object or the type declared by such a declaration will have its alignment requirement equal to the strictest (largest) non-zero expression of all <code>alignas</code> specifiers used in the declaration, unless it would weaken the natural alignment of the type.</p>
</blockquote>
<p>例子：</p>
<pre><code class="cpp">// every object of type sse_t will be aligned to 16-byte boundary
struct alignas(16) sse_t {
    float sse_data[4];
};

// the array &quot;cacheline&quot; will be aligned to 128-byte boundary
alignas(128) char cacheline[128];

int main() {
    sse_t i;
    std::cout &lt;&lt;  sizeof(i) &lt;&lt;std::endl;
}
///    16
</code></pre>
<h4 id="alignof-VS-alignas"><a href="#alignof-VS-alignas" class="headerlink" title="alignof VS alignas"></a><code>alignof</code> VS <code>alignas</code></h4><blockquote>
<p><code>alignof</code> is an operator that will tell you the byte-multiple for an object’s memory location.<br><code>alignas</code> will change the alignment to something perhaps more coarse, but never finer.</p>
</blockquote>
<p>假设有一个32位的计算机，现在希望有：<code>alignof(array) ==4</code>。注意，如果数组正好在奇数边界（odd boundary）上，则下列语句可能会导致程序为ill-formed：</p>
<pre><code class="cpp">double * pd = static_cast&lt;double *&gt;(array);
</code></pre>
<p>如果知道如何对齐对象，就可以在声明和定义数组的时候就是用alignment specifier。</p>
<pre><code class="cpp">alignas(double) char array[sizeof(double)];
</code></pre>
<p>扩展：<a href="https://stackoverflow.com/questions/17091382/memory-alignment-how-to-use-alignof-alignas" target="_blank" rel="noopener">Memory alignment : how to use alignof / alignas?
</a></p>
<p><strong>variadic macro</strong></p>
<ol>
<li><a href="https://gcc.gnu.org/onlinedocs/cpp/Standard-Predefined-Macros.html#Standard-Predefined-Macros" target="_blank" rel="noopener">Standard Predefined Macros</a></li>
<li><a href="https://gcc.gnu.org/onlinedocs/cpp/Variadic-Macros.html" target="_blank" rel="noopener">Variadic Macros</a></li>
</ol>
<h2 id="利用using代替typedef声明function-pointer"><a href="#利用using代替typedef声明function-pointer" class="headerlink" title="利用using代替typedef声明function pointer"></a>利用<code>using</code>代替<code>typedef</code>声明function pointer</h2><p>利用<code>typedef</code>进行声明：</p>
<pre><code class="cpp">typedef void (*pointer)();
</code></pre>
<p>利用<code>using</code>进行声明：</p>
<pre><code class="cpp">using pointer = void (*)();
</code></pre>
<p>或者：</p>
<pre><code class="cpp">void f() {}

using FunctionPtr = std::add_pointer&lt;void()&gt;::type;
FunctionPtr ptr = f;
</code></pre>
<h3 id="根据元素类型获取tuple中的元素"><a href="#根据元素类型获取tuple中的元素" class="headerlink" title="根据元素类型获取tuple中的元素"></a>根据元素类型获取<code>tuple</code>中的元素</h3><pre><code class="cpp">template &lt;typename T, std::size_t N, typename...Args&gt;
struct index_of;

template &lt;typename T, std::size_t N, typename...Args&gt;
struct index_of&lt;T, N, T, Args...&gt; {
    enum { value = N };
};

template &lt;typename T, std::size_t N, typename F, typename...Args&gt;
struct index_of&lt;T, N, F, Args...&gt; {
    enum {
        value = index_of&lt;T, N+1, Args...&gt;::value
    };
};

template &lt;typename T, std::size_t N&gt;
struct index_of&lt;T, N&gt; {
    enum { value=-1 };
    static_assert(value!=-1, &quot;type is non-existing&quot;);
};

template &lt;typename T, typename...Args&gt;
T get_element_by_name(const std::tuple&lt;Args...&gt;&amp; t) {
    return std::get&lt;index_of&lt;T, 0, Args...&gt;::value&gt;(t);
}

int main() {
    std::tuple&lt;char,int,double&gt; t 
        = std::make_tuple(&#39;a&#39;,1,1.111);
    std::cout&lt;&lt; get_element_by_name&lt;double&gt;(t) &lt;&lt;std::endl;
}
</code></pre>
<p>将<code>enum</code>换成<code>const int</code>也可以。现在将上述代码完全改为C++ 11的方式，使用<code>std::integral_constant</code>：</p>
<pre><code class="cpp">template &lt;typename T, std::size_t N, typename...Args&gt;
struct index_of;

template &lt;typename T, std::size_t N, typename...Args&gt;
struct index_of&lt;T, N, T, Args...&gt; : std::integral_constant&lt;int, N&gt; {};

template &lt;typename T, std::size_t N, typename F, typename...Args&gt;
struct index_of&lt;T, N, F, Args...&gt; : std::integral_constant&lt;int, index_of&lt;T, N+1, Args...&gt;::value&gt; {};

template &lt;typename T, std::size_t N&gt;
struct index_of&lt;T, N&gt; : std::integral_constant&lt;int, -1&gt; {};

template &lt;typename T, typename...Args&gt;
T get_element_by_name(const std::tuple&lt;Args...&gt;&amp; t) {
    return std::get&lt;index_of&lt;T, 0, Args...&gt;::value&gt;(t);
}

int main() {
    std::tuple&lt;char,int,double&gt; t 
        = std::make_tuple(&#39;a&#39;,1,1.111);
    std::cout&lt;&lt; get_element_by_name&lt;double&gt;(t) &lt;&lt;std::endl;
}
</code></pre>
<h2 id="问题一："><a href="#问题一：" class="headerlink" title="问题一："></a>问题一：</h2><pre><code class="cpp">#include &lt;iostream&gt;
auto main = []() -&gt;int { return 0; }
</code></pre>
<pre><code class="cpp">#include &lt;iostream&gt;
int func() { return 0; }
int (*main)() = func;
</code></pre>
<p>上述代码无法运行的原因（标准规定）：</p>
<blockquote>
<p>The function main shall not be used within a program. The linkage of main is implementation-defined. A program that defines main as deleted or that declares main to be inline, static, or constexpr is ill-formed. The main function shall not be declared with a linkage-specification. A program that declares a variable main at global scope or that declares the name main with C language linkage (in any namespace) is ill-formed. The name main is not otherwise reserved. [ Example: Member functions, classes, and enumerations can be called main, as can entities in other namespaces. —end example ]</p>
</blockquote>
<h2 id="问题二："><a href="#问题二：" class="headerlink" title="问题二："></a>问题二：</h2><pre><code class="cpp">template &lt;typename T&gt;
using remove_reference=T;
</code></pre>
<p>此时，想要特化一个<code>T&amp;</code>的版本：</p>
<pre><code class="cpp">template &lt;typename T&gt;
using remove_reference&lt;T&amp;&gt;=T;
</code></pre>
<p>上述的语法不正确。</p>
<blockquote>
<p>Because an <em>alias-declaration</em> cannot declare a <em>template-id</em>, it is not possible to partially or explicitly specialize an alias template.因为别名声明不能声明模板 id ，故不可能部分或显式特化一个别名模版。</p>
</blockquote>
<p>即：<strong>别名模板不能显示特化或者偏特化</strong>。</p>
<p>所以正确的写法为：</p>
<pre><code class="cpp">template &lt;typename T&gt;
struct remove_reference { using type = T; }

template &lt;typename T&gt;
struct remove_reference&lt;T&amp;&gt; { using type = T; }

template &lt;typename T&gt;
struct remove_reference&lt;T&amp;&amp;&gt; { using type = T; }

template &lt;typename T&gt;
using remove_reference_t = typename remove_reference&lt;T&gt;::type;
</code></pre>

        
    

    
</div>


                

                <!-- Post Comments -->
                
                    
                
            </div>

            <!-- Post Prev & Next Nav -->
            <nav class="material-nav mdl-color-text--grey-50 mdl-cell mdl-cell--12-col">
    <!-- Prev Nav -->
    
        <a href="/2018/07/09/Compiler（上）/" id="post_nav-newer" class="prev-content">
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_back</i>
            </button>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            新篇
        </a>
    

    <!-- Section Spacer -->
    <div class="section-spacer"></div>

    <!-- Next Nav -->
    
</nav>

        </div>
    </div>



                    
                        <!-- Overlay For Active Sidebar -->
<div class="sidebar-overlay"></div>

<!-- Material sidebar -->
<aside id="sidebar" class="sidebar sidebar-colored sidebar-fixed-left" role="navigation">
    <div id="sidebar-main">
        <!-- Sidebar Header -->
        <div class="sidebar-header header-cover" style="background-image: url(/img/sidebar_header.png);">
    <!-- Top bar -->
    <div class="top-bar"></div>

    <!-- Sidebar toggle button -->
    <button type="button" class="sidebar-toggle mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon" style="display: initial;" data-upgraded=",MaterialButton,MaterialRipple">
        <i class="material-icons">clear_all</i>
        <span class="mdl-button__ripple-container">
            <span class="mdl-ripple">
            </span>
        </span>
    </button>

    <!-- Sidebar Avatar -->
    <div class="sidebar-image">
        <img src="/img/avatar.png" alt="Magicmanoooo's avatar">
    </div>

    <!-- Sidebar Email -->
    <a data-toggle="dropdown" class="sidebar-brand" href="#settings-dropdown">
        838713968@qq.com
        <b class="caret"></b>
    </a>
</div>


        <!-- Sidebar Navigation  -->
        <ul class="nav sidebar-nav">
    <!-- User dropdown  -->
    <li class="dropdown">
        <ul id="settings-dropdown" class="dropdown-menu">
            
                <li>
                    <a href="mailto: 838713968@qq.com" target="_blank" title="Email Me">
                        
                            <i class="material-icons sidebar-material-icons sidebar-indent-left1pc-element">email</i>
                        
                        Email Me
                    </a>
                </li>
            
        </ul>
    </li>

    <!-- Homepage -->
    
        <li id="sidebar-first-li">
            <a href="/">
                
                    <i class="material-icons sidebar-material-icons">home</i>
                
                主页
            </a>
        </li>
        
    

    <!-- Archives  -->
    
        <li class="dropdown">
            <a href="#" class="ripple-effect dropdown-toggle" data-toggle="dropdown">
                
                    <i class="material-icons sidebar-material-icons">inbox</i>
                
                    归档
                <b class="caret"></b>
            </a>
            <ul class="dropdown-menu">
            <li>
                <a class="sidebar_archives-link" href="/archives/2018/11/">十一月 2018<span class="sidebar_archives-count">3</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/10/">十月 2018<span class="sidebar_archives-count">5</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/09/">九月 2018<span class="sidebar_archives-count">3</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/08/">八月 2018<span class="sidebar_archives-count">4</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/07/">七月 2018<span class="sidebar_archives-count">5</span></a>
            </ul>
        </li>
        
    

    <!-- Categories  -->
    
        <li class="dropdown">
            <a href="#" class="ripple-effect dropdown-toggle" data-toggle="dropdown">
                
                    <i class="material-icons sidebar-material-icons">chrome_reader_mode</i>
                
                分类
                <b class="caret"></b>
            </a>
            <ul class="dropdown-menu">
                <li>
                
            </ul>
        </li>
        
    

    <!-- Pages  -->
    

    <!-- Article Number  -->
    
        <li>
            <a href="/archives">
                文章总数
                <span class="sidebar-badge">20</span>
            </a>
        </li>
        
    
</ul>


        <!-- Sidebar Footer -->
        <!--
I'm glad you use this theme, the development is no so easy, I hope you can keep the copyright, I will thank you so much.
If you still want to delete the copyrights, could you still retain the first one? Which namely "Theme Material"
It will not impact the appearance and can give developers a lot of support :)

很高兴您使用并喜欢该主题，开发不易 十分谢谢与希望您可以保留一下版权声明。
如果您仍然想删除的话 能否只保留第一项呢？即 "Theme Material"
它不会影响美观并可以给开发者很大的支持和动力。 :)
-->

<!-- Sidebar Divider -->

    <div class="sidebar-divider"></div>


<!-- Theme Material -->


<!-- Help & Support -->
<!--

    <a href="mailto:hiviosey@gmail.com" class="sidebar-footer-text-a">
        <div class="sidebar-text mdl-button mdl-js-button mdl-js-ripple-effect sidebar-footer-text-div" data-upgraded=",MaterialButton,MaterialRipple">
        sidebar.help
        <span class="mdl-button__ripple-container">
          <span class="mdl-ripple"></span>
        </span>
      </div>
    </a>

-->

<!-- Feedback -->
<!--

    <a href="https://github.com/viosey/hexo-theme-material/issues" target="_blank" class="sidebar-footer-text-a">
        <div class="sidebar-text mdl-button mdl-js-button mdl-js-ripple-effect sidebar-footer-text-div" data-upgraded=",MaterialButton,MaterialRipple">
        sidebar.feedback
        <span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span></div>
    </a>

-->

<!-- About Theme -->
<!--

    <a href="https://blog.viosey.com/index.php/Material.html" target="_blank" class="sidebar-footer-text-a">
        <div class="sidebar-text mdl-button mdl-js-button mdl-js-ripple-effect sidebar-footer-text-div" data-upgraded=",MaterialButton,MaterialRipple">
             sidebar.about_theme
            <span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span></div>
    </a>

-->

    </div>

    <!-- Sidebar Image -->
    

</aside>

                    

                    
                        <!-- Footer Top Button -->
                        <div id="back-to-top" class="toTop-wrap">
    <a href="#top" class="toTop">
        <i class="material-icons footer_top-i">expand_less</i>
    </a>
</div>

                    

                    <!--Footer-->
<footer class="mdl-mini-footer" id="bottom">
    
        <!-- Paradox Footer Left Section -->
        <div class="mdl-mini-footer--left-section sns-list">
    <!-- Twitter -->
    

    <!-- Facebook -->
    

    <!-- Google + -->
    

    <!-- Weibo -->
    
        <a href="https://weibo.com/5345088988/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-weibo">
                <span class="visuallyhidden">Weibo</span>
            </button><!--
     --></a>
    

    <!-- Instagram -->
    

    <!-- Tumblr -->
    

    <!-- Github -->
    
        <a href="https://github.com/Azurery" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-github">
                <span class="visuallyhidden">Github</span>
            </button><!--
     --></a>
    

    <!-- LinkedIn -->
    

    <!-- Zhihu -->
    
        <a href="https://www.zhihu.com/people/zhang-tao-60-41/activities" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-zhihu">
                <span class="visuallyhidden">Zhihu</span>
            </button><!--
     --></a>
    

    <!-- Bilibili -->
    
        <a href="https://space.bilibili.com/94222521/#/" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-bilibili">
                <span class="visuallyhidden">Bilibili</span>
            </button><!--
     --></a>
    

    <!-- Telegram -->
    
    
    <!-- V2EX -->
    
</div>


        <!--Copyright-->
        <div id="copyright">
            Copyright&nbsp;©&nbsp;2017&nbsp;-<script type="text/javascript">var fd = new Date();document.write("&nbsp;" + fd.getFullYear() + "&nbsp;");</script>Azurery
            
                <br>
                
                    只有永不遏止的奋斗，才能使青春之花，即使是凋谢，也是壮丽地凋谢
                
            
        </div>

        <!-- Paradox Footer Right Section -->

        <!--
        I am glad you use this theme, the development is no so easy, I hope you can keep the copyright.
        It will not impact the appearance and can give developers a lot of support :)

        很高兴您使用该主题，开发不易，希望您可以保留一下版权声明。
        它不会影响美观并可以给开发者很大的支持。 :)
        -->

        <div class="mdl-mini-footer--right-section">
            <div>
                <div class="footer-develop-div">Powered by <a href="https://hexo.io" target="_blank" class="footer-develop-a">Hexo</a></div>
                <div class="footer-develop-div">Theme - <a href="https://github.com/viosey/hexo-theme-material" target="_blank" class="footer-develop-a">Material</a></div>
            </div>
        </div>
    
</footer>


                    <!-- Import JS File -->

    <script>lsloader.load("lazyload_js","/js/lazyload.min.js?1BcfzuNXqV+ntF6gq+5X3Q==", true)</script>



    <script>lsloader.load("js_js","/js/js.min.js?V/53wGualMuiPM3xoetD5Q==", true)</script>



    <script>lsloader.load("np_js","/js/nprogress.js?pl3Qhb9lvqR1FlyLUna1Yw==", true)</script>


<script type="text/ls-javascript" id="NProgress-script">
    NProgress.configure({
        showSpinner: true
    });
    NProgress.start();
    $('#nprogress .bar').css({
        'background': '#29d'
    });
    $('#nprogress .peg').css({
        'box-shadow': '0 0 10px #29d, 0 0 15px #29d'
    });
    $('#nprogress .spinner-icon').css({
        'border-top-color': '#29d',
        'border-left-color': '#29d'
    });
    setTimeout(function() {
        NProgress.done();
        $('.fade').removeClass('out');
    }, 800);
</script>













<!-- UC Browser Compatible -->
<script>
	var agent = navigator.userAgent.toLowerCase();
	if(agent.indexOf('ucbrowser')>0) {
		document.write('<link rel="stylesheet" href="/css/uc.css">');
	   alert('由于 UC 浏览器使用极旧的内核，而本网站使用了一些新的特性。\n为了您能更好的浏览，推荐使用 Chrome 或 Firefox 浏览器。');
	}
</script>

<!-- Import prettify js  -->

    
        
            <script>lsloader.load("prettify_js","/js/prettify.min.js?WN07fivHQSMKWy7BmHBB6w==", true)</script>
        
    



<!-- Window Load -->
<!-- add class for prettify -->
<script type="text/ls-javascript" id="window-load">
    $(window).on('load', function() {
        // Post_Toc parent position fixed
        $('.post-toc-wrap').parent('.mdl-menu__container').css('position', 'fixed');
    });

    
        
            $(function() {
                $('pre').addClass('prettyprint linenums').attr('style', 'overflow:auto;');
                prettyPrint();
                })
        
    
    
</script>

<!-- MathJax Load-->


<!-- Bing Background -->


<script type="text/ls-javascript" id="lazy-load">
    // Offer LazyLoad
    queue.offer(function(){
        $('.lazy').lazyload({
            effect : 'show'
        });
    });

    // Start Queue
    $(document).ready(function(){
        setInterval(function(){
            queue.execNext();
        },200);
    });
</script>

<!-- Custom Footer -->



<script>
    (function(){
        var scriptList = document.querySelectorAll('script[type="text/ls-javascript"]')

        for (var i = 0; i < scriptList.length; ++i) {
            var item = scriptList[i];
            lsloader.runInlineScript(item.id,item.id);
        }
    })()
console.log('\n %c © Material Theme | Version: 1.5.0 | https://github.com/viosey/hexo-theme-material %c \n', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-left-radius:5px;border-bottom-left-radius:5px;', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-right-radius:5px;border-bottom-right-radius:5px;');
</script>

                </main>
            </div>
        </body>
    
</html>
